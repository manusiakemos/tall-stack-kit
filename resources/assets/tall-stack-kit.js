(() => { "use strict"; var e = { 95: (e, t, n) => { n.d(t, { Z: () => o }); var r = n(645), i = n.n(r)()((function (e) { return e[1] })); i.push([e.id, '.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{background-color:#333;border-radius:4px;color:#fff;font-size:14px;line-height:1.4;outline:0;position:relative;transition-property:transform,visibility,opacity;white-space:normal}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{border-top-color:initial;border-width:8px 8px 0;bottom:-7px;left:0;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:initial;border-width:0 8px 8px;left:0;top:-7px;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-left-color:initial;border-width:8px 0 8px 8px;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{border-right-color:initial;border-width:8px 8px 8px 0;left:-7px;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{color:#333;height:16px;width:16px}.tippy-arrow:before{border-color:transparent;border-style:solid;content:"";position:absolute}.tippy-content{padding:5px 9px;position:relative;z-index:1}', ""]); const o = i }, 645: e => { e.exports = function (e) { var t = []; return t.toString = function () { return this.map((function (t) { var n = e(t); return t[2] ? "@media ".concat(t[2], " {").concat(n, "}") : n })).join("") }, t.i = function (e, n, r) { "string" == typeof e && (e = [[null, e, ""]]); var i = {}; if (r) for (var o = 0; o < this.length; o++) { var s = this[o][0]; null != s && (i[s] = !0) } for (var a = 0; a < e.length; a++) { var l = [].concat(e[a]); r && i[l[0]] || (n && (l[2] ? l[2] = "".concat(n, " and ").concat(l[2]) : l[2] = n), t.push(l)) } }, t } }, 379: (e, t, n) => { var r, i = function () { return void 0 === r && (r = Boolean(window && document && document.all && !window.atob)), r }, o = function () { var e = {}; return function (t) { if (void 0 === e[t]) { var n = document.querySelector(t); if (window.HTMLIFrameElement && n instanceof window.HTMLIFrameElement) try { n = n.contentDocument.head } catch (e) { n = null } e[t] = n } return e[t] } }(), s = []; function a(e) { for (var t = -1, n = 0; n < s.length; n++)if (s[n].identifier === e) { t = n; break } return t } function l(e, t) { for (var n = {}, r = [], i = 0; i < e.length; i++) { var o = e[i], l = t.base ? o[0] + t.base : o[0], c = n[l] || 0, u = "".concat(l, " ").concat(c); n[l] = c + 1; var d = a(u), h = { css: o[1], media: o[2], sourceMap: o[3] }; -1 !== d ? (s[d].references++, s[d].updater(h)) : s.push({ identifier: u, updater: g(h, t), references: 1 }), r.push(u) } return r } function c(e) { var t = document.createElement("style"), r = e.attributes || {}; if (void 0 === r.nonce) { var i = n.nc; i && (r.nonce = i) } if (Object.keys(r).forEach((function (e) { t.setAttribute(e, r[e]) })), "function" == typeof e.insert) e.insert(t); else { var s = o(e.insert || "head"); if (!s) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); s.appendChild(t) } return t } var u, d = (u = [], function (e, t) { return u[e] = t, u.filter(Boolean).join("\n") }); function h(e, t, n, r) { var i = n ? "" : r.media ? "@media ".concat(r.media, " {").concat(r.css, "}") : r.css; if (e.styleSheet) e.styleSheet.cssText = d(t, i); else { var o = document.createTextNode(i), s = e.childNodes; s[t] && e.removeChild(s[t]), s.length ? e.insertBefore(o, s[t]) : e.appendChild(o) } } function p(e, t, n) { var r = n.css, i = n.media, o = n.sourceMap; if (i ? e.setAttribute("media", i) : e.removeAttribute("media"), o && "undefined" != typeof btoa && (r += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o)))), " */")), e.styleSheet) e.styleSheet.cssText = r; else { for (; e.firstChild;)e.removeChild(e.firstChild); e.appendChild(document.createTextNode(r)) } } var f = null, m = 0; function g(e, t) { var n, r, i; if (t.singleton) { var o = m++; n = f || (f = c(t)), r = h.bind(null, n, o, !1), i = h.bind(null, n, o, !0) } else n = c(t), r = p.bind(null, n, t), i = function () { !function (e) { if (null === e.parentNode) return !1; e.parentNode.removeChild(e) }(n) }; return r(e), function (t) { if (t) { if (t.css === e.css && t.media === e.media && t.sourceMap === e.sourceMap) return; r(e = t) } else i() } } e.exports = function (e, t) { (t = t || {}).singleton || "boolean" == typeof t.singleton || (t.singleton = i()); var n = l(e = e || [], t); return function (e) { if (e = e || [], "[object Array]" === Object.prototype.toString.call(e)) { for (var r = 0; r < n.length; r++) { var i = a(n[r]); s[i].references-- } for (var o = l(e, t), c = 0; c < n.length; c++) { var u = a(n[c]); 0 === s[u].references && (s[u].updater(), s.splice(u, 1)) } n = o } } } } }, t = {}; function n(r) { var i = t[r]; if (void 0 !== i) return i.exports; var o = t[r] = { id: r, exports: {} }; return e[r](o, o.exports, n), o.exports } n.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return n.d(t, { a: t }), t }, n.d = (e, t) => { for (var r in t) n.o(t, r) && !n.o(e, r) && Object.defineProperty(e, r, { enumerable: !0, get: t[r] }) }, n.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { var e, t, r, i, o = !1, s = !1, a = []; function l(e) { !function (e) { a.includes(e) || a.push(e); s || o || (o = !0, queueMicrotask(u)) }(e) } function c(e) { let t = a.indexOf(e); -1 !== t && a.splice(t, 1) } function u() { o = !1, s = !0; for (let e = 0; e < a.length; e++)a[e](); a.length = 0, s = !1 } var d = !0; function h(e) { t = e } var p = [], f = [], m = []; function g(e, t) { "function" == typeof t ? (e._x_cleanups || (e._x_cleanups = []), e._x_cleanups.push(t)) : (t = e, f.push(t)) } function y(e, t) { e._x_attributeCleanups && Object.entries(e._x_attributeCleanups).forEach((([n, r]) => { (void 0 === t || t.includes(n)) && (r.forEach((e => e())), delete e._x_attributeCleanups[n]) })) } var v = new MutationObserver(S), b = !1; function w() { v.observe(document, { subtree: !0, childList: !0, attributes: !0, attributeOldValue: !0 }), b = !0 } function D() { (x = x.concat(v.takeRecords())).length && !C && (C = !0, queueMicrotask((() => { S(x), x.length = 0, C = !1 }))), v.disconnect(), b = !1 } var x = [], C = !1; function k(e) { if (!b) return e(); D(); let t = e(); return w(), t } var A = !1, E = []; function S(e) { if (A) return void (E = E.concat(e)); let t = [], n = [], r = new Map, i = new Map; for (let o = 0; o < e.length; o++)if (!e[o].target._x_ignoreMutationObserver && ("childList" === e[o].type && (e[o].addedNodes.forEach((e => 1 === e.nodeType && t.push(e))), e[o].removedNodes.forEach((e => 1 === e.nodeType && n.push(e)))), "attributes" === e[o].type)) { let t = e[o].target, n = e[o].attributeName, s = e[o].oldValue, a = () => { r.has(t) || r.set(t, []), r.get(t).push({ name: n, value: t.getAttribute(n) }) }, l = () => { i.has(t) || i.set(t, []), i.get(t).push(n) }; t.hasAttribute(n) && null === s ? a() : t.hasAttribute(n) ? (l(), a()) : l() } i.forEach(((e, t) => { y(t, e) })), r.forEach(((e, t) => { p.forEach((n => n(t, e))) })); for (let e of n) if (!t.includes(e) && (f.forEach((t => t(e))), e._x_cleanups)) for (; e._x_cleanups.length;)e._x_cleanups.pop()(); t.forEach((e => { e._x_ignoreSelf = !0, e._x_ignore = !0 })); for (let e of t) n.includes(e) || e.isConnected && (delete e._x_ignoreSelf, delete e._x_ignore, m.forEach((t => t(e))), e._x_ignore = !0, e._x_ignoreSelf = !0); t.forEach((e => { delete e._x_ignoreSelf, delete e._x_ignore })), t = null, n = null, r = null, i = null } function M(e) { return N(F(e)) } function O(e, t, n) { return e._x_dataStack = [t, ...F(n || e)], () => { e._x_dataStack = e._x_dataStack.filter((e => e !== t)) } } function T(e, t) { let n = e._x_dataStack[0]; Object.entries(t).forEach((([e, t]) => { n[e] = t })) } function F(e) { return e._x_dataStack ? e._x_dataStack : "function" == typeof ShadowRoot && e instanceof ShadowRoot ? F(e.host) : e.parentNode ? F(e.parentNode) : [] } function N(e) { let t = new Proxy({}, { ownKeys: () => Array.from(new Set(e.flatMap((e => Object.keys(e))))), has: (t, n) => e.some((e => e.hasOwnProperty(n))), get: (n, r) => (e.find((e => { if (e.hasOwnProperty(r)) { let n = Object.getOwnPropertyDescriptor(e, r); if (n.get && n.get._x_alreadyBound || n.set && n.set._x_alreadyBound) return !0; if ((n.get || n.set) && n.enumerable) { let i = n.get, o = n.set, s = n; i = i && i.bind(t), o = o && o.bind(t), i && (i._x_alreadyBound = !0), o && (o._x_alreadyBound = !0), Object.defineProperty(e, r, { ...s, get: i, set: o }) } return !0 } return !1 })) || {})[r], set: (t, n, r) => { let i = e.find((e => e.hasOwnProperty(n))); return i ? i[n] = r : e[e.length - 1][n] = r, !0 } }); return t } function B(e) { let t = (n, r = "") => { Object.entries(Object.getOwnPropertyDescriptors(n)).forEach((([i, { value: o, enumerable: s }]) => { if (!1 === s || void 0 === o) return; let a = "" === r ? i : `${r}.${i}`; var l; "object" == typeof o && null !== o && o._x_interceptor ? n[i] = o.initialize(e, a, i) : "object" != typeof (l = o) || Array.isArray(l) || null === l || o === n || o instanceof Element || t(o, a) })) }; return t(e) } function _(e, t = (() => { })) { let n = { initialValue: void 0, _x_interceptor: !0, initialize(t, n, r) { return e(this.initialValue, (() => function (e, t) { return t.split(".").reduce(((e, t) => e[t]), e) }(t, n)), (e => R(t, n, e)), n, r) } }; return t(n), e => { if ("object" == typeof e && null !== e && e._x_interceptor) { let t = n.initialize.bind(n); n.initialize = (r, i, o) => { let s = e.initialize(r, i, o); return n.initialValue = s, t(r, i, o) } } else n.initialValue = e; return n } } function R(e, t, n) { if ("string" == typeof t && (t = t.split(".")), 1 !== t.length) { if (0 === t.length) throw error; return e[t[0]] || (e[t[0]] = {}), R(e[t[0]], t.slice(1), n) } e[t[0]] = n } var L = {}; function P(e, t) { L[e] = t } function I(e, t) { return Object.entries(L).forEach((([n, r]) => { Object.defineProperty(e, `$${n}`, { get() { let [e, n] = re(t); return e = { interceptor: _, ...e }, g(t, n), r(t, e) }, enumerable: !1 }) })), e } function $(e, t, n, ...r) { try { return n(...r) } catch (n) { z(n, e, t) } } function z(e, t, n) { Object.assign(e, { el: t, expression: n }), console.warn(`Alpine Expression Error: ${e.message}\n\n${n ? 'Expression: "' + n + '"\n\n' : ""}`, t), setTimeout((() => { throw e }), 0) } var j = !0; function H(e, t, n = {}) { let r; return V(e, t)((e => r = e), n), r } function V(...e) { return W(...e) } var W = q; function q(e, t) { let n = {}; I(n, e); let r = [n, ...F(e)]; if ("function" == typeof t) return function (e, t) { return (n = (() => { }), { scope: r = {}, params: i = [] } = {}) => { J(n, t.apply(N([r, ...e]), i)) } }(r, t); let i = function (e, t, n) { let r = function (e, t) { if (K[e]) return K[e]; let n = Object.getPrototypeOf((async function () { })).constructor, r = /^[\n\s]*if.*\(.*\)/.test(e) || /^(let|const)\s/.test(e) ? `(() => { ${e} })()` : e; let i = (() => { try { return new n(["__self", "scope"], `with (scope) { __self.result = ${r} }; __self.finished = true; return __self.result;`) } catch (n) { return z(n, t, e), Promise.resolve() } })(); return K[e] = i, i }(t, n); return (i = (() => { }), { scope: o = {}, params: s = [] } = {}) => { r.result = void 0, r.finished = !1; let a = N([o, ...e]); if ("function" == typeof r) { let e = r(r, a).catch((e => z(e, n, t))); r.finished ? (J(i, r.result, a, s, n), r.result = void 0) : e.then((e => { J(i, e, a, s, n) })).catch((e => z(e, n, t))).finally((() => r.result = void 0)) } } }(r, t, e); return $.bind(null, e, t, i) } var K = {}; function J(e, t, n, r, i) { if (j && "function" == typeof t) { let o = t.apply(n, r); o instanceof Promise ? o.then((t => J(e, t, n, r))).catch((e => z(e, i, t))) : e(o) } else e(t) } var U = "x-"; function G(e = "") { return U + e } var X = {}; function Y(e, t) { X[e] = t } function Z(e, t, n) { if (t = Array.from(t), e._x_virtualDirectives) { let n = Object.entries(e._x_virtualDirectives).map((([e, t]) => ({ name: e, value: t }))), r = Q(n); n = n.map((e => r.find((t => t.name === e.name)) ? { name: `x-bind:${e.name}`, value: `"${e.value}"` } : e)), t = t.concat(n) } let r = {}, i = t.map(oe(((e, t) => r[e] = t))).filter(le).map(function (e, t) { return ({ name: n, value: r }) => { let i = n.match(ce()), o = n.match(/:([a-zA-Z0-9\-:]+)/), s = n.match(/\.[^.\]]+(?=[^\]]*$)/g) || [], a = t || e[n] || n; return { type: i ? i[1] : null, value: o ? o[1] : null, modifiers: s.map((e => e.replace(".", ""))), expression: r, original: a } } }(r, n)).sort(he); return i.map((t => function (e, t) { let n = () => { }, r = X[t.type] || n, [i, o] = re(e); !function (e, t, n) { e._x_attributeCleanups || (e._x_attributeCleanups = {}), e._x_attributeCleanups[t] || (e._x_attributeCleanups[t] = []), e._x_attributeCleanups[t].push(n) }(e, t.original, o); let s = () => { e._x_ignore || e._x_ignoreSelf || (r.inline && r.inline(e, t, i), r = r.bind(r, e, t, i), ee ? te.get(ne).push(r) : r()) }; return s.runCleanups = o, s }(e, t))) } function Q(e) { return Array.from(e).map(oe()).filter((e => !le(e))) } var ee = !1, te = new Map, ne = Symbol(); function re(e) { let n = [], [i, o] = function (e) { let n = () => { }; return [i => { let o = t(i); return e._x_effects || (e._x_effects = new Set, e._x_runEffects = () => { e._x_effects.forEach((e => e())) }), e._x_effects.add(o), n = () => { void 0 !== o && (e._x_effects.delete(o), r(o)) }, o }, () => { n() }] }(e); n.push(o); return [{ Alpine: Ge, effect: i, cleanup: e => n.push(e), evaluateLater: V.bind(V, e), evaluate: H.bind(H, e) }, () => n.forEach((e => e()))] } var ie = (e, t) => ({ name: n, value: r }) => (n.startsWith(e) && (n = n.replace(e, t)), { name: n, value: r }); function oe(e = (() => { })) { return ({ name: t, value: n }) => { let { name: r, value: i } = se.reduce(((e, t) => t(e)), { name: t, value: n }); return r !== t && e(r, t), { name: r, value: i } } } var se = []; function ae(e) { se.push(e) } function le({ name: e }) { return ce().test(e) } var ce = () => new RegExp(`^${U}([^:^.]+)\\b`); var ue = "DEFAULT", de = ["ignore", "ref", "data", "id", "bind", "init", "for", "mask", "model", "modelable", "transition", "show", "if", ue, "teleport"]; function he(e, t) { let n = -1 === de.indexOf(e.type) ? ue : e.type, r = -1 === de.indexOf(t.type) ? ue : t.type; return de.indexOf(n) - de.indexOf(r) } function pe(e, t, n = {}) { e.dispatchEvent(new CustomEvent(t, { detail: n, bubbles: !0, composed: !0, cancelable: !0 })) } var fe = [], me = !1; function ge(e = (() => { })) { return queueMicrotask((() => { me || setTimeout((() => { ye() })) })), new Promise((t => { fe.push((() => { e(), t() })) })) } function ye() { for (me = !1; fe.length;)fe.shift()() } function ve(e, t) { if ("function" == typeof ShadowRoot && e instanceof ShadowRoot) return void Array.from(e.children).forEach((e => ve(e, t))); let n = !1; if (t(e, (() => n = !0)), n) return; let r = e.firstElementChild; for (; r;)ve(r, t), r = r.nextElementSibling } function be(e, ...t) { console.warn(`Alpine Warning: ${e}`, ...t) } var we = [], De = []; function xe() { return we.map((e => e())) } function Ce() { return we.concat(De).map((e => e())) } function ke(e) { we.push(e) } function Ae(e) { De.push(e) } function Ee(e, t = !1) { return Se(e, (e => { if ((t ? Ce() : xe()).some((t => e.matches(t)))) return !0 })) } function Se(e, t) { if (e) { if (t(e)) return e; if (e._x_teleportBack && (e = e._x_teleportBack), e.parentElement) return Se(e.parentElement, t) } } function Me(e, t = ve) { !function (e) { ee = !0; let t = Symbol(); ne = t, te.set(t, []); let n = () => { for (; te.get(t).length;)te.get(t).shift()(); te.delete(t) }; e(n), ee = !1, n() }((() => { t(e, ((e, t) => { Z(e, e.attributes).forEach((e => e())), e._x_ignore && t() })) })) } function Oe(e, t) { return Array.isArray(t) ? Te(e, t.join(" ")) : "object" == typeof t && null !== t ? function (e, t) { let n = e => e.split(" ").filter(Boolean), r = Object.entries(t).flatMap((([e, t]) => !!t && n(e))).filter(Boolean), i = Object.entries(t).flatMap((([e, t]) => !t && n(e))).filter(Boolean), o = [], s = []; return i.forEach((t => { e.classList.contains(t) && (e.classList.remove(t), s.push(t)) })), r.forEach((t => { e.classList.contains(t) || (e.classList.add(t), o.push(t)) })), () => { s.forEach((t => e.classList.add(t))), o.forEach((t => e.classList.remove(t))) } }(e, t) : "function" == typeof t ? Oe(e, t()) : Te(e, t) } function Te(e, t) { return t = !0 === t ? t = "" : t || "", n = t.split(" ").filter((t => !e.classList.contains(t))).filter(Boolean), e.classList.add(...n), () => { e.classList.remove(...n) }; var n } function Fe(e, t) { return "object" == typeof t && null !== t ? function (e, t) { let n = {}; return Object.entries(t).forEach((([t, r]) => { n[t] = e.style[t], t.startsWith("--") || (t = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase()), e.style.setProperty(t, r) })), setTimeout((() => { 0 === e.style.length && e.removeAttribute("style") })), () => { Fe(e, n) } }(e, t) : function (e, t) { let n = e.getAttribute("style", t); return e.setAttribute("style", t), () => { e.setAttribute("style", n || "") } }(e, t) } function Ne(e, t = (() => { })) { let n = !1; return function () { n ? t.apply(this, arguments) : (n = !0, e.apply(this, arguments)) } } function Be(e, t, n = {}) { e._x_transition || (e._x_transition = { enter: { during: n, start: n, end: n }, leave: { during: n, start: n, end: n }, in(n = (() => { }), r = (() => { })) { Re(e, t, { during: this.enter.during, start: this.enter.start, end: this.enter.end }, n, r) }, out(n = (() => { }), r = (() => { })) { Re(e, t, { during: this.leave.during, start: this.leave.start, end: this.leave.end }, n, r) } }) } function _e(e) { let t = e.parentNode; if (t) return t._x_hidePromise ? t : _e(t) } function Re(e, t, { during: n, start: r, end: i } = {}, o = (() => { }), s = (() => { })) { if (e._x_transitioning && e._x_transitioning.cancel(), 0 === Object.keys(n).length && 0 === Object.keys(r).length && 0 === Object.keys(i).length) return o(), void s(); let a, l, c; !function (e, t) { let n, r, i, o = Ne((() => { k((() => { n = !0, r || t.before(), i || (t.end(), ye()), t.after(), e.isConnected && t.cleanup(), delete e._x_transitioning })) })); e._x_transitioning = { beforeCancels: [], beforeCancel(e) { this.beforeCancels.push(e) }, cancel: Ne((function () { for (; this.beforeCancels.length;)this.beforeCancels.shift()(); o() })), finish: o }, k((() => { t.start(), t.during() })), me = !0, requestAnimationFrame((() => { if (n) return; let o = 1e3 * Number(getComputedStyle(e).transitionDuration.replace(/,.*/, "").replace("s", "")), s = 1e3 * Number(getComputedStyle(e).transitionDelay.replace(/,.*/, "").replace("s", "")); 0 === o && (o = 1e3 * Number(getComputedStyle(e).animationDuration.replace("s", ""))), k((() => { t.before() })), r = !0, requestAnimationFrame((() => { n || (k((() => { t.end() })), ye(), setTimeout(e._x_transitioning.finish, o + s), i = !0) })) })) }(e, { start() { a = t(e, r) }, during() { l = t(e, n) }, before: o, end() { a(), c = t(e, i) }, after: s, cleanup() { l(), c() } }) } function Le(e, t, n) { if (-1 === e.indexOf(t)) return n; const r = e[e.indexOf(t) + 1]; if (!r) return n; if ("scale" === t && isNaN(r)) return n; if ("duration" === t) { let e = r.match(/([0-9]+)ms/); if (e) return e[1] } return "origin" === t && ["top", "right", "left", "center", "bottom"].includes(e[e.indexOf(t) + 2]) ? [r, e[e.indexOf(t) + 2]].join(" ") : r } Y("transition", ((e, { value: t, modifiers: n, expression: r }, { evaluate: i }) => { "function" == typeof r && (r = i(r)), r ? function (e, t, n) { Be(e, Oe, ""), { enter: t => { e._x_transition.enter.during = t }, "enter-start": t => { e._x_transition.enter.start = t }, "enter-end": t => { e._x_transition.enter.end = t }, leave: t => { e._x_transition.leave.during = t }, "leave-start": t => { e._x_transition.leave.start = t }, "leave-end": t => { e._x_transition.leave.end = t } }[n](t) }(e, r, t) : function (e, t, n) { Be(e, Fe); let r = !t.includes("in") && !t.includes("out") && !n, i = r || t.includes("in") || ["enter"].includes(n), o = r || t.includes("out") || ["leave"].includes(n); t.includes("in") && !r && (t = t.filter(((e, n) => n < t.indexOf("out")))); t.includes("out") && !r && (t = t.filter(((e, n) => n > t.indexOf("out")))); let s = !t.includes("opacity") && !t.includes("scale"), a = s || t.includes("opacity"), l = s || t.includes("scale"), c = a ? 0 : 1, u = l ? Le(t, "scale", 95) / 100 : 1, d = Le(t, "delay", 0), h = Le(t, "origin", "center"), p = "opacity, transform", f = Le(t, "duration", 150) / 1e3, m = Le(t, "duration", 75) / 1e3, g = "cubic-bezier(0.4, 0.0, 0.2, 1)"; i && (e._x_transition.enter.during = { transformOrigin: h, transitionDelay: d, transitionProperty: p, transitionDuration: `${f}s`, transitionTimingFunction: g }, e._x_transition.enter.start = { opacity: c, transform: `scale(${u})` }, e._x_transition.enter.end = { opacity: 1, transform: "scale(1)" }); o && (e._x_transition.leave.during = { transformOrigin: h, transitionDelay: d, transitionProperty: p, transitionDuration: `${m}s`, transitionTimingFunction: g }, e._x_transition.leave.start = { opacity: 1, transform: "scale(1)" }, e._x_transition.leave.end = { opacity: c, transform: `scale(${u})` }) }(e, n, t) })), window.Element.prototype._x_toggleAndCascadeWithTransitions = function (e, t, n, r) { const i = "visible" === document.visibilityState ? requestAnimationFrame : setTimeout; let o = () => i(n); t ? e._x_transition && (e._x_transition.enter || e._x_transition.leave) ? e._x_transition.enter && (Object.entries(e._x_transition.enter.during).length || Object.entries(e._x_transition.enter.start).length || Object.entries(e._x_transition.enter.end).length) ? e._x_transition.in(n) : o() : e._x_transition ? e._x_transition.in(n) : o() : (e._x_hidePromise = e._x_transition ? new Promise(((t, n) => { e._x_transition.out((() => { }), (() => t(r))), e._x_transitioning.beforeCancel((() => n({ isFromCancelledTransition: !0 }))) })) : Promise.resolve(r), queueMicrotask((() => { let t = _e(e); t ? (t._x_hideChildren || (t._x_hideChildren = []), t._x_hideChildren.push(e)) : i((() => { let t = e => { let n = Promise.all([e._x_hidePromise, ...(e._x_hideChildren || []).map(t)]).then((([e]) => e())); return delete e._x_hidePromise, delete e._x_hideChildren, n }; t(e).catch((e => { if (!e.isFromCancelledTransition) throw e })) })) }))) }; var Pe = !1; function Ie(e, t = (() => { })) { return (...n) => Pe ? t(...n) : e(...n) } function $e(t, n, r, i = []) { switch (t._x_bindings || (t._x_bindings = e({})), t._x_bindings[n] = r, n = i.includes("camel") ? n.toLowerCase().replace(/-(\w)/g, ((e, t) => t.toUpperCase())) : n) { case "value": !function (e, t) { if ("radio" === e.type) void 0 === e.attributes.value && (e.value = t), window.fromModel && (e.checked = ze(e.value, t)); else if ("checkbox" === e.type) Number.isInteger(t) ? e.value = t : Number.isInteger(t) || Array.isArray(t) || "boolean" == typeof t || [null, void 0].includes(t) ? Array.isArray(t) ? e.checked = t.some((t => ze(t, e.value))) : e.checked = !!t : e.value = String(t); else if ("SELECT" === e.tagName) !function (e, t) { const n = [].concat(t).map((e => e + "")); Array.from(e.options).forEach((e => { e.selected = n.includes(e.value) })) }(e, t); else { if (e.value === t) return; e.value = t } }(t, r); break; case "style": !function (e, t) { e._x_undoAddedStyles && e._x_undoAddedStyles(); e._x_undoAddedStyles = Fe(e, t) }(t, r); break; case "class": !function (e, t) { e._x_undoAddedClasses && e._x_undoAddedClasses(); e._x_undoAddedClasses = Oe(e, t) }(t, r); break; default: !function (e, t, n) { [null, void 0, !1].includes(n) && function (e) { return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(e) }(t) ? e.removeAttribute(t) : (je(t) && (n = t), function (e, t, n) { e.getAttribute(t) != n && e.setAttribute(t, n) }(e, t, n)) }(t, n, r) } } function ze(e, t) { return e == t } function je(e) { return ["disabled", "checked", "required", "readonly", "hidden", "open", "selected", "autofocus", "itemscope", "multiple", "novalidate", "allowfullscreen", "allowpaymentrequest", "formnovalidate", "autoplay", "controls", "loop", "muted", "playsinline", "default", "ismap", "reversed", "async", "defer", "nomodule"].includes(e) } function He(e, t) { var n; return function () { var r = this, i = arguments, o = function () { n = null, e.apply(r, i) }; clearTimeout(n), n = setTimeout(o, t) } } function Ve(e, t) { let n; return function () { let r = this, i = arguments; n || (e.apply(r, i), n = !0, setTimeout((() => n = !1), t)) } } var We = {}, qe = !1; var Ke = {}; function Je(e, t, n) { let r = []; for (; r.length;)r.pop()(); let i = Object.entries(t).map((([e, t]) => ({ name: e, value: t }))), o = Q(i); i = i.map((e => o.find((t => t.name === e.name)) ? { name: `x-bind:${e.name}`, value: `"${e.value}"` } : e)), Z(e, i, n).map((e => { r.push(e.runCleanups), e() })) } var Ue = {}; var Ge = { get reactive() { return e }, get release() { return r }, get effect() { return t }, get raw() { return i }, version: "3.10.3", flushAndStopDeferringMutations: function () { A = !1, S(E), E = [] }, dontAutoEvaluateFunctions: function (e) { let t = j; j = !1, e(), j = t }, disableEffectScheduling: function (e) { d = !1, e(), d = !0 }, setReactivityEngine: function (n) { e = n.reactive, r = n.release, t = e => n.effect(e, { scheduler: e => { d ? l(e) : e() } }), i = n.raw }, closestDataStack: F, skipDuringClone: Ie, addRootSelector: ke, addInitSelector: Ae, addScopeToNode: O, deferMutations: function () { A = !0 }, mapAttributes: ae, evaluateLater: V, setEvaluator: function (e) { W = e }, mergeProxies: N, findClosest: Se, closestRoot: Ee, interceptor: _, transition: Re, setStyles: Fe, mutateDom: k, directive: Y, throttle: Ve, debounce: He, evaluate: H, initTree: Me, nextTick: ge, prefixed: G, prefix: function (e) { U = e }, plugin: function (e) { e(Ge) }, magic: P, store: function (t, n) { if (qe || (We = e(We), qe = !0), void 0 === n) return We[t]; We[t] = n, "object" == typeof n && null !== n && n.hasOwnProperty("init") && "function" == typeof n.init && We[t].init(), B(We[t]) }, start: function () { var e; document.body || be("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?"), pe(document, "alpine:init"), pe(document, "alpine:initializing"), w(), e = e => Me(e, ve), m.push(e), g((e => { ve(e, (e => y(e))) })), function (e) { p.push(e) }(((e, t) => { Z(e, t).forEach((e => e())) })), Array.from(document.querySelectorAll(Ce())).filter((e => !Ee(e.parentElement, !0))).forEach((e => { Me(e) })), pe(document, "alpine:initialized") }, clone: function (e, n) { n._x_dataStack || (n._x_dataStack = e._x_dataStack), Pe = !0, function (e) { let n = t; h(((e, t) => { let i = n(e); return r(i), () => { } })), e(), h(n) }((() => { !function (e) { let t = !1; Me(e, ((e, n) => { ve(e, ((e, r) => { if (t && function (e) { return xe().some((t => e.matches(t))) }(e)) return r(); t = !0, n(e, r) })) })) }(n) })), Pe = !1 }, bound: function (e, t, n) { if (e._x_bindings && void 0 !== e._x_bindings[t]) return e._x_bindings[t]; let r = e.getAttribute(t); return null === r ? "function" == typeof n ? n() : n : je(t) ? !![t, "true"].includes(r) : "" === r || r }, $data: M, data: function (e, t) { Ue[e] = t }, bind: function (e, t) { let n = "function" != typeof t ? () => t : t; e instanceof Element ? Je(e, n()) : Ke[e] = n } }; function Xe(e, t) { const n = Object.create(null), r = e.split(","); for (let e = 0; e < r.length; e++)n[r[e]] = !0; return t ? e => !!n[e.toLowerCase()] : e => !!n[e] } var Ye, Ze = Object.freeze({}), Qe = (Object.freeze([]), Object.assign), et = Object.prototype.hasOwnProperty, tt = (e, t) => et.call(e, t), nt = Array.isArray, rt = e => "[object Map]" === at(e), it = e => "symbol" == typeof e, ot = e => null !== e && "object" == typeof e, st = Object.prototype.toString, at = e => st.call(e), lt = e => at(e).slice(8, -1), ct = e => "string" == typeof e && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e, ut = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, dt = /-(\w)/g, ht = (ut((e => e.replace(dt, ((e, t) => t ? t.toUpperCase() : "")))), /\B([A-Z])/g), pt = (ut((e => e.replace(ht, "-$1").toLowerCase())), ut((e => e.charAt(0).toUpperCase() + e.slice(1)))), ft = (ut((e => e ? `on${pt(e)}` : "")), (e, t) => e !== t && (e == e || t == t)), mt = new WeakMap, gt = [], yt = Symbol("iterate"), vt = Symbol("Map key iterate"); var bt = 0; function wt(e) { const { deps: t } = e; if (t.length) { for (let n = 0; n < t.length; n++)t[n].delete(e); t.length = 0 } } var Dt = !0, xt = []; function Ct() { const e = xt.pop(); Dt = void 0 === e || e } function kt(e, t, n) { if (!Dt || void 0 === Ye) return; let r = mt.get(e); r || mt.set(e, r = new Map); let i = r.get(n); i || r.set(n, i = new Set), i.has(Ye) || (i.add(Ye), Ye.deps.push(i), Ye.options.onTrack && Ye.options.onTrack({ effect: Ye, target: e, type: t, key: n })) } function At(e, t, n, r, i, o) { const s = mt.get(e); if (!s) return; const a = new Set, l = e => { e && e.forEach((e => { (e !== Ye || e.allowRecurse) && a.add(e) })) }; if ("clear" === t) s.forEach(l); else if ("length" === n && nt(e)) s.forEach(((e, t) => { ("length" === t || t >= r) && l(e) })); else switch (void 0 !== n && l(s.get(n)), t) { case "add": nt(e) ? ct(n) && l(s.get("length")) : (l(s.get(yt)), rt(e) && l(s.get(vt))); break; case "delete": nt(e) || (l(s.get(yt)), rt(e) && l(s.get(vt))); break; case "set": rt(e) && l(s.get(yt)) }a.forEach((s => { s.options.onTrigger && s.options.onTrigger({ effect: s, target: e, key: n, type: t, newValue: r, oldValue: i, oldTarget: o }), s.options.scheduler ? s.options.scheduler(s) : s() })) } var Et = Xe("__proto__,__v_isRef,__isVue"), St = new Set(Object.getOwnPropertyNames(Symbol).map((e => Symbol[e])).filter(it)), Mt = Bt(), Ot = Bt(!1, !0), Tt = Bt(!0), Ft = Bt(!0, !0), Nt = {}; function Bt(e = !1, t = !1) { return function (n, r, i) { if ("__v_isReactive" === r) return !e; if ("__v_isReadonly" === r) return e; if ("__v_raw" === r && i === (e ? t ? cn : ln : t ? an : sn).get(n)) return n; const o = nt(n); if (!e && o && tt(Nt, r)) return Reflect.get(Nt, r, i); const s = Reflect.get(n, r, i); if (it(r) ? St.has(r) : Et(r)) return s; if (e || kt(n, "get", r), t) return s; if (fn(s)) { return !o || !ct(r) ? s.value : s } return ot(s) ? e ? dn(s) : un(s) : s } } function _t(e = !1) { return function (t, n, r, i) { let o = t[n]; if (!e && (r = pn(r), o = pn(o), !nt(t) && fn(o) && !fn(r))) return o.value = r, !0; const s = nt(t) && ct(n) ? Number(n) < t.length : tt(t, n), a = Reflect.set(t, n, r, i); return t === pn(i) && (s ? ft(r, o) && At(t, "set", n, r, o) : At(t, "add", n, r)), a } } ["includes", "indexOf", "lastIndexOf"].forEach((e => { const t = Array.prototype[e]; Nt[e] = function (...e) { const n = pn(this); for (let e = 0, t = this.length; e < t; e++)kt(n, "get", e + ""); const r = t.apply(n, e); return -1 === r || !1 === r ? t.apply(n, e.map(pn)) : r } })), ["push", "pop", "shift", "unshift", "splice"].forEach((e => { const t = Array.prototype[e]; Nt[e] = function (...e) { xt.push(Dt), Dt = !1; const n = t.apply(this, e); return Ct(), n } })); var Rt = { get: Mt, set: _t(), deleteProperty: function (e, t) { const n = tt(e, t), r = e[t], i = Reflect.deleteProperty(e, t); return i && n && At(e, "delete", t, void 0, r), i }, has: function (e, t) { const n = Reflect.has(e, t); return it(t) && St.has(t) || kt(e, "has", t), n }, ownKeys: function (e) { return kt(e, "iterate", nt(e) ? "length" : yt), Reflect.ownKeys(e) } }, Lt = { get: Tt, set: (e, t) => (console.warn(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0), deleteProperty: (e, t) => (console.warn(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0) }, Pt = (Qe({}, Rt, { get: Ot, set: _t(!0) }), Qe({}, Lt, { get: Ft }), e => ot(e) ? un(e) : e), It = e => ot(e) ? dn(e) : e, $t = e => e, zt = e => Reflect.getPrototypeOf(e); function jt(e, t, n = !1, r = !1) { const i = pn(e = e.__v_raw), o = pn(t); t !== o && !n && kt(i, "get", t), !n && kt(i, "get", o); const { has: s } = zt(i), a = r ? $t : n ? It : Pt; return s.call(i, t) ? a(e.get(t)) : s.call(i, o) ? a(e.get(o)) : void (e !== i && e.get(t)) } function Ht(e, t = !1) { const n = this.__v_raw, r = pn(n), i = pn(e); return e !== i && !t && kt(r, "has", e), !t && kt(r, "has", i), e === i ? n.has(e) : n.has(e) || n.has(i) } function Vt(e, t = !1) { return e = e.__v_raw, !t && kt(pn(e), "iterate", yt), Reflect.get(e, "size", e) } function Wt(e) { e = pn(e); const t = pn(this); return zt(t).has.call(t, e) || (t.add(e), At(t, "add", e, e)), this } function qt(e, t) { t = pn(t); const n = pn(this), { has: r, get: i } = zt(n); let o = r.call(n, e); o ? on(n, r, e) : (e = pn(e), o = r.call(n, e)); const s = i.call(n, e); return n.set(e, t), o ? ft(t, s) && At(n, "set", e, t, s) : At(n, "add", e, t), this } function Kt(e) { const t = pn(this), { has: n, get: r } = zt(t); let i = n.call(t, e); i ? on(t, n, e) : (e = pn(e), i = n.call(t, e)); const o = r ? r.call(t, e) : void 0, s = t.delete(e); return i && At(t, "delete", e, void 0, o), s } function Jt() { const e = pn(this), t = 0 !== e.size, n = rt(e) ? new Map(e) : new Set(e), r = e.clear(); return t && At(e, "clear", void 0, void 0, n), r } function Ut(e, t) { return function (n, r) { const i = this, o = i.__v_raw, s = pn(o), a = t ? $t : e ? It : Pt; return !e && kt(s, "iterate", yt), o.forEach(((e, t) => n.call(r, a(e), a(t), i))) } } function Gt(e, t, n) { return function (...r) { const i = this.__v_raw, o = pn(i), s = rt(o), a = "entries" === e || e === Symbol.iterator && s, l = "keys" === e && s, c = i[e](...r), u = n ? $t : t ? It : Pt; return !t && kt(o, "iterate", l ? vt : yt), { next() { const { value: e, done: t } = c.next(); return t ? { value: e, done: t } : { value: a ? [u(e[0]), u(e[1])] : u(e), done: t } }, [Symbol.iterator]() { return this } } } } function Xt(e) { return function (...t) { { const n = t[0] ? `on key "${t[0]}" ` : ""; console.warn(`${pt(e)} operation ${n}failed: target is readonly.`, pn(this)) } return "delete" !== e && this } } var Yt = { get(e) { return jt(this, e) }, get size() { return Vt(this) }, has: Ht, add: Wt, set: qt, delete: Kt, clear: Jt, forEach: Ut(!1, !1) }, Zt = { get(e) { return jt(this, e, !1, !0) }, get size() { return Vt(this) }, has: Ht, add: Wt, set: qt, delete: Kt, clear: Jt, forEach: Ut(!1, !0) }, Qt = { get(e) { return jt(this, e, !0) }, get size() { return Vt(this, !0) }, has(e) { return Ht.call(this, e, !0) }, add: Xt("add"), set: Xt("set"), delete: Xt("delete"), clear: Xt("clear"), forEach: Ut(!0, !1) }, en = { get(e) { return jt(this, e, !0, !0) }, get size() { return Vt(this, !0) }, has(e) { return Ht.call(this, e, !0) }, add: Xt("add"), set: Xt("set"), delete: Xt("delete"), clear: Xt("clear"), forEach: Ut(!0, !0) }; function tn(e, t) { const n = t ? e ? en : Zt : e ? Qt : Yt; return (t, r, i) => "__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(tt(n, r) && r in t ? n : t, r, i) } ["keys", "values", "entries", Symbol.iterator].forEach((e => { Yt[e] = Gt(e, !1, !1), Qt[e] = Gt(e, !0, !1), Zt[e] = Gt(e, !1, !0), en[e] = Gt(e, !0, !0) })); var nn = { get: tn(!1, !1) }, rn = (tn(!1, !0), { get: tn(!0, !1) }); tn(!0, !0); function on(e, t, n) { const r = pn(n); if (r !== n && t.call(e, r)) { const t = lt(e); console.warn(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map" === t ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`) } } var sn = new WeakMap, an = new WeakMap, ln = new WeakMap, cn = new WeakMap; function un(e) { return e && e.__v_isReadonly ? e : hn(e, !1, Rt, nn, sn) } function dn(e) { return hn(e, !0, Lt, rn, ln) } function hn(e, t, n, r, i) { if (!ot(e)) return console.warn(`value cannot be made reactive: ${String(e)}`), e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const o = i.get(e); if (o) return o; const s = (a = e).__v_skip || !Object.isExtensible(a) ? 0 : function (e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } }(lt(a)); var a; if (0 === s) return e; const l = new Proxy(e, 2 === s ? r : n); return i.set(e, l), l } function pn(e) { return e && pn(e.__v_raw) || e } function fn(e) { return Boolean(e && !0 === e.__v_isRef) } P("nextTick", (() => ge)), P("dispatch", (e => pe.bind(pe, e))), P("watch", ((e, { evaluateLater: t, effect: n }) => (r, i) => { let o, s = t(r), a = !0, l = n((() => s((e => { JSON.stringify(e), a ? o = e : queueMicrotask((() => { i(e, o), o = e })), a = !1 })))); e._x_effects.delete(l) })), P("store", (function () { return We })), P("data", (e => M(e))), P("root", (e => Ee(e))), P("refs", (e => (e._x_refs_proxy || (e._x_refs_proxy = N(function (e) { let t = [], n = e; for (; n;)n._x_refs && t.push(n._x_refs), n = n.parentNode; return t }(e))), e._x_refs_proxy))); var mn = {}; function gn(e) { return mn[e] || (mn[e] = 0), ++mn[e] } function yn(e, t, n) { P(t, (t => be(`You can't use [$${directiveName}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, t))) } P("id", (e => (t, n = null) => { let r = function (e, t) { return Se(e, (e => { if (e._x_ids && e._x_ids[t]) return !0 })) }(e, t), i = r ? r._x_ids[t] : gn(t); return n ? `${t}-${i}-${n}` : `${t}-${i}` })), P("el", (e => e)), yn("Focus", "focus", "focus"), yn("Persist", "persist", "persist"), Y("modelable", ((e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t), o = () => { let e; return i((t => e = t)), e }, s = r(`${t} = __placeholder`), a = e => s((() => { }), { scope: { __placeholder: e } }), l = o(); a(l), queueMicrotask((() => { if (!e._x_model) return; e._x_removeModelListeners.default(); let t = e._x_model.get, r = e._x_model.set; n((() => a(t()))), n((() => r(o()))) })) })), Y("teleport", ((e, { expression: t }, { cleanup: n }) => { "template" !== e.tagName.toLowerCase() && be("x-teleport can only be used on a <template> tag", e); let r = document.querySelector(t); r || be(`Cannot find x-teleport element for selector: "${t}"`); let i = e.content.cloneNode(!0).firstElementChild; e._x_teleport = i, i._x_teleportBack = e, e._x_forwardEvents && e._x_forwardEvents.forEach((t => { i.addEventListener(t, (t => { t.stopPropagation(), e.dispatchEvent(new t.constructor(t.type, t)) })) })), O(i, {}, e), k((() => { r.appendChild(i), Me(i), i._x_ignore = !0 })), n((() => i.remove())) })); var vn = () => { }; function bn(e, t, n, r) { let i = e, o = e => r(e), s = {}, a = (e, t) => n => t(e, n); if (n.includes("dot") && (t = t.replace(/-/g, ".")), n.includes("camel") && (t = function (e) { return e.toLowerCase().replace(/-(\w)/g, ((e, t) => t.toUpperCase())) }(t)), n.includes("passive") && (s.passive = !0), n.includes("capture") && (s.capture = !0), n.includes("window") && (i = window), n.includes("document") && (i = document), n.includes("prevent") && (o = a(o, ((e, t) => { t.preventDefault(), e(t) }))), n.includes("stop") && (o = a(o, ((e, t) => { t.stopPropagation(), e(t) }))), n.includes("self") && (o = a(o, ((t, n) => { n.target === e && t(n) }))), (n.includes("away") || n.includes("outside")) && (i = document, o = a(o, ((t, n) => { e.contains(n.target) || !1 !== n.target.isConnected && (e.offsetWidth < 1 && e.offsetHeight < 1 || !1 !== e._x_isShown && t(n)) }))), n.includes("once") && (o = a(o, ((e, n) => { e(n), i.removeEventListener(t, o, s) }))), o = a(o, ((e, r) => { (function (e) { return ["keydown", "keyup"].includes(e) })(t) && function (e, t) { let n = t.filter((e => !["window", "document", "prevent", "stop", "once"].includes(e))); if (n.includes("debounce")) { let e = n.indexOf("debounce"); n.splice(e, wn((n[e + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1) } if (0 === n.length) return !1; if (1 === n.length && Dn(e.key).includes(n[0])) return !1; const r = ["ctrl", "shift", "alt", "meta", "cmd", "super"].filter((e => n.includes(e))); if (n = n.filter((e => !r.includes(e))), r.length > 0) { if (r.filter((t => ("cmd" !== t && "super" !== t || (t = "meta"), e[`${t}Key`]))).length === r.length && Dn(e.key).includes(n[0])) return !1 } return !0 }(r, n) || e(r) })), n.includes("debounce")) { let e = n[n.indexOf("debounce") + 1] || "invalid-wait", t = wn(e.split("ms")[0]) ? Number(e.split("ms")[0]) : 250; o = He(o, t) } if (n.includes("throttle")) { let e = n[n.indexOf("throttle") + 1] || "invalid-wait", t = wn(e.split("ms")[0]) ? Number(e.split("ms")[0]) : 250; o = Ve(o, t) } return i.addEventListener(t, o, s), () => { i.removeEventListener(t, o, s) } } function wn(e) { return !Array.isArray(e) && !isNaN(e) } function Dn(e) { if (!e) return []; e = e.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase(); let t = { ctrl: "control", slash: "/", space: "-", spacebar: "-", cmd: "meta", esc: "escape", up: "arrow-up", down: "arrow-down", left: "arrow-left", right: "arrow-right", period: ".", equal: "=" }; return t[e] = e, Object.keys(t).map((n => { if (t[n] === e) return n })).filter((e => e)) } function xn(e) { let t = e ? parseFloat(e) : null; return n = t, Array.isArray(n) || isNaN(n) ? e : t; var n } function Cn(e, t, n, r) { let i = {}; if (/^\[.*\]$/.test(e.item) && Array.isArray(t)) { let n = e.item.replace("[", "").replace("]", "").split(",").map((e => e.trim())); n.forEach(((e, n) => { i[e] = t[n] })) } else if (/^\{.*\}$/.test(e.item) && !Array.isArray(t) && "object" == typeof t) { let n = e.item.replace("{", "").replace("}", "").split(",").map((e => e.trim())); n.forEach((e => { i[e] = t[e] })) } else i[e.item] = t; return e.index && (i[e.index] = n), e.collection && (i[e.collection] = r), i } function kn() { } function An(e, t, n) { Y(t, (r => be(`You can't use [x-${t}] without first installing the "${e}" plugin here: https://alpinejs.dev/plugins/${n}`, r))) } vn.inline = (e, { modifiers: t }, { cleanup: n }) => { t.includes("self") ? e._x_ignoreSelf = !0 : e._x_ignore = !0, n((() => { t.includes("self") ? delete e._x_ignoreSelf : delete e._x_ignore })) }, Y("ignore", vn), Y("effect", ((e, { expression: t }, { effect: n }) => n(V(e, t)))), Y("model", ((e, { modifiers: t, expression: n }, { effect: r, cleanup: i }) => { let o = V(e, n), s = V(e, `${n} = rightSideOfExpression($event, ${n})`); var a = "select" === e.tagName.toLowerCase() || ["checkbox", "radio"].includes(e.type) || t.includes("lazy") ? "change" : "input"; let l = function (e, t, n) { "radio" === e.type && k((() => { e.hasAttribute("name") || e.setAttribute("name", n) })); return (n, r) => k((() => { if (n instanceof CustomEvent && void 0 !== n.detail) return n.detail || n.target.value; if ("checkbox" === e.type) { if (Array.isArray(r)) { let e = t.includes("number") ? xn(n.target.value) : n.target.value; return n.target.checked ? r.concat([e]) : r.filter((t => !(t == e))) } return n.target.checked } if ("select" === e.tagName.toLowerCase() && e.multiple) return t.includes("number") ? Array.from(n.target.selectedOptions).map((e => xn(e.value || e.text))) : Array.from(n.target.selectedOptions).map((e => e.value || e.text)); { let e = n.target.value; return t.includes("number") ? xn(e) : t.includes("trim") ? e.trim() : e } })) }(e, t, n), c = bn(e, a, t, (e => { s((() => { }), { scope: { $event: e, rightSideOfExpression: l } }) })); e._x_removeModelListeners || (e._x_removeModelListeners = {}), e._x_removeModelListeners.default = c, i((() => e._x_removeModelListeners.default())); let u = V(e, `${n} = __placeholder`); e._x_model = { get() { let e; return o((t => e = t)), e }, set(e) { u((() => { }), { scope: { __placeholder: e } }) } }, e._x_forceModelUpdate = () => { o((t => { void 0 === t && n.match(/\./) && (t = ""), window.fromModel = !0, k((() => $e(e, "value", t))), delete window.fromModel })) }, r((() => { t.includes("unintrusive") && document.activeElement.isSameNode(e) || e._x_forceModelUpdate() })) })), Y("cloak", (e => queueMicrotask((() => k((() => e.removeAttribute(G("cloak")))))))), Ae((() => `[${G("init")}]`)), Y("init", Ie(((e, { expression: t }, { evaluate: n }) => "string" == typeof t ? !!t.trim() && n(t, {}, !1) : n(t, {}, !1)))), Y("text", ((e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t); n((() => { i((t => { k((() => { e.textContent = t })) })) })) })), Y("html", ((e, { expression: t }, { effect: n, evaluateLater: r }) => { let i = r(t); n((() => { i((t => { k((() => { e.innerHTML = t, e._x_ignoreSelf = !0, Me(e), delete e._x_ignoreSelf })) })) })) })), ae(ie(":", G("bind:"))), Y("bind", ((e, { value: t, modifiers: n, expression: r, original: i }, { effect: o }) => { if (!t) { let t = {}; return s = t, Object.entries(Ke).forEach((([e, t]) => { Object.defineProperty(s, e, { get: () => (...e) => t(...e) }) })), void V(e, r)((t => { Je(e, t, i) }), { scope: t }) } var s; if ("key" === t) return function (e, t) { e._x_keyExpression = t }(e, r); let a = V(e, r); o((() => a((i => { void 0 === i && r.match(/\./) && (i = ""), k((() => $e(e, t, i, n))) })))) })), ke((() => `[${G("data")}]`)), Y("data", Ie(((t, { expression: n }, { cleanup: r }) => { n = "" === n ? "{}" : n; let i = {}; I(i, t); let o = {}; var s, a; s = o, a = i, Object.entries(Ue).forEach((([e, t]) => { Object.defineProperty(s, e, { get: () => (...e) => t.bind(a)(...e), enumerable: !1 }) })); let l = H(t, n, { scope: o }); void 0 === l && (l = {}), I(l, t); let c = e(l); B(c); let u = O(t, c); c.init && H(t, c.init), r((() => { c.destroy && H(t, c.destroy), u() })) }))), Y("show", ((e, { modifiers: t, expression: n }, { effect: r }) => { let i = V(e, n); e._x_doHide || (e._x_doHide = () => { k((() => { e.style.setProperty("display", "none", t.includes("important") ? "important" : void 0) })) }), e._x_doShow || (e._x_doShow = () => { k((() => { 1 === e.style.length && "none" === e.style.display ? e.removeAttribute("style") : e.style.removeProperty("display") })) }); let o, s = () => { e._x_doHide(), e._x_isShown = !1 }, a = () => { e._x_doShow(), e._x_isShown = !0 }, l = () => setTimeout(a), c = Ne((e => e ? a() : s()), (t => { "function" == typeof e._x_toggleAndCascadeWithTransitions ? e._x_toggleAndCascadeWithTransitions(e, t, a, s) : t ? l() : s() })), u = !0; r((() => i((e => { (u || e !== o) && (t.includes("immediate") && (e ? l() : s()), c(e), o = e, u = !1) })))) })), Y("for", ((t, { expression: n }, { effect: r, cleanup: i }) => { let o = function (e) { let t = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, n = /^\s*\(|\)\s*$/g, r = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, i = e.match(r); if (!i) return; let o = {}; o.items = i[2].trim(); let s = i[1].replace(n, "").trim(), a = s.match(t); a ? (o.item = s.replace(t, "").trim(), o.index = a[1].trim(), a[2] && (o.collection = a[2].trim())) : o.item = s; return o }(n), s = V(t, o.items), a = V(t, t._x_keyExpression || "index"); t._x_prevKeys = [], t._x_lookup = {}, r((() => function (t, n, r, i) { let o = e => "object" == typeof e && !Array.isArray(e), s = t; r((r => { var a; a = r, !Array.isArray(a) && !isNaN(a) && r >= 0 && (r = Array.from(Array(r).keys(), (e => e + 1))), void 0 === r && (r = []); let l = t._x_lookup, u = t._x_prevKeys, d = [], h = []; if (o(r)) r = Object.entries(r).map((([e, t]) => { let o = Cn(n, t, e, r); i((e => h.push(e)), { scope: { index: e, ...o } }), d.push(o) })); else for (let e = 0; e < r.length; e++) { let t = Cn(n, r[e], e, r); i((e => h.push(e)), { scope: { index: e, ...t } }), d.push(t) } let p = [], f = [], m = [], g = []; for (let e = 0; e < u.length; e++) { let t = u[e]; -1 === h.indexOf(t) && m.push(t) } u = u.filter((e => !m.includes(e))); let y = "template"; for (let e = 0; e < h.length; e++) { let t = h[e], n = u.indexOf(t); if (-1 === n) u.splice(e, 0, t), p.push([y, e]); else if (n !== e) { let t = u.splice(e, 1)[0], r = u.splice(n - 1, 1)[0]; u.splice(e, 0, r), u.splice(n, 0, t), f.push([t, r]) } else g.push(t); y = t } for (let e = 0; e < m.length; e++) { let t = m[e]; l[t]._x_effects && l[t]._x_effects.forEach(c), l[t].remove(), l[t] = null, delete l[t] } for (let e = 0; e < f.length; e++) { let [t, n] = f[e], r = l[t], i = l[n], o = document.createElement("div"); k((() => { i.after(o), r.after(i), i._x_currentIfEl && i.after(i._x_currentIfEl), o.before(r), r._x_currentIfEl && r.after(r._x_currentIfEl), o.remove() })), T(i, d[h.indexOf(n)]) } for (let t = 0; t < p.length; t++) { let [n, r] = p[t], i = "template" === n ? s : l[n]; i._x_currentIfEl && (i = i._x_currentIfEl); let o = d[r], a = h[r], c = document.importNode(s.content, !0).firstElementChild; O(c, e(o), s), k((() => { i.after(c), Me(c) })), "object" == typeof a && be("x-for key cannot be an object, it must be a string or an integer", s), l[a] = c } for (let e = 0; e < g.length; e++)T(l[g[e]], d[h.indexOf(g[e])]); s._x_prevKeys = h })) }(t, o, s, a))), i((() => { Object.values(t._x_lookup).forEach((e => e.remove())), delete t._x_prevKeys, delete t._x_lookup })) })), kn.inline = (e, { expression: t }, { cleanup: n }) => { let r = Ee(e); r._x_refs || (r._x_refs = {}), r._x_refs[t] = e, n((() => delete r._x_refs[t])) }, Y("ref", kn), Y("if", ((e, { expression: t }, { effect: n, cleanup: r }) => { let i = V(e, t); n((() => i((t => { t ? (() => { if (e._x_currentIfEl) return e._x_currentIfEl; let t = e.content.cloneNode(!0).firstElementChild; O(t, {}, e), k((() => { e.after(t), Me(t) })), e._x_currentIfEl = t, e._x_undoIf = () => { ve(t, (e => { e._x_effects && e._x_effects.forEach(c) })), t.remove(), delete e._x_currentIfEl } })() : e._x_undoIf && (e._x_undoIf(), delete e._x_undoIf) })))), r((() => e._x_undoIf && e._x_undoIf())) })), Y("id", ((e, { expression: t }, { evaluate: n }) => { n(t).forEach((t => function (e, t) { e._x_ids || (e._x_ids = {}), e._x_ids[t] || (e._x_ids[t] = gn(t)) }(e, t))) })), ae(ie("@", G("on:"))), Y("on", Ie(((e, { value: t, modifiers: n, expression: r }, { cleanup: i }) => { let o = r ? V(e, r) : () => { }; "template" === e.tagName.toLowerCase() && (e._x_forwardEvents || (e._x_forwardEvents = []), e._x_forwardEvents.includes(t) || e._x_forwardEvents.push(t)); let s = bn(e, t, n, (e => { o((() => { }), { scope: { $event: e }, params: [e] }) })); i((() => s())) }))), An("Collapse", "collapse", "collapse"), An("Intersect", "intersect", "intersect"), An("Focus", "trap", "focus"), An("Mask", "mask", "mask"), Ge.setEvaluator(q), Ge.setReactivityEngine({ reactive: un, effect: function (e, t = Ze) { (function (e) { return e && !0 === e._isEffect })(e) && (e = e.raw); const n = function (e, t) { const n = function () { if (!n.active) return e(); if (!gt.includes(n)) { wt(n); try { return xt.push(Dt), Dt = !0, gt.push(n), Ye = n, e() } finally { gt.pop(), Ct(), Ye = gt[gt.length - 1] } } }; return n.id = bt++, n.allowRecurse = !!t.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n }(e, t); return t.lazy || n(), n }, release: function (e) { e.active && (wt(e), e.options.onStop && e.options.onStop(), e.active = !1) }, raw: pn }); var En = Ge; function Sn(e, t) { let n = t, r = "", i = { 9: /[0-9]/, a: /[a-zA-Z]/, "*": /[a-zA-Z0-9]/ }, o = ""; for (let t = 0; t < e.length; t++)if (["9", "a", "*"].includes(e[t])) o += e[t]; else for (let r = 0; r < n.length; r++)if (n[r] === e[t]) { n = n.slice(0, r) + n.slice(r + 1); break } for (let e = 0; e < o.length; e++) { let t = !1; for (let s = 0; s < n.length; s++)if (i[o[e]].test(n[s])) { r += n[s], n = n.slice(0, s) + n.slice(s + 1), t = !0; break } if (!t) break } return r } function Mn(e, t) { let n = Array.from(t), r = ""; for (let t = 0; t < e.length; t++)if (["9", "a", "*"].includes(e[t])) { if (0 === n.length) break; r += n.shift() } else r += e[t]; return r } function On(e, t = ".", n) { n = "," === t && void 0 === n ? "." : ","; let r = e.replaceAll(new RegExp(`[^0-9\\${t}]`, "g"), ""), i = Array.from({ length: r.split(t)[0].length }).fill("9").join(""); return i = ((e, t) => { let n = "", r = 0; for (let i = e.length - 1; i >= 0; i--)e[i] !== t && (3 === r ? (n = e[i] + t + n, r = 0) : n = e[i] + n, r++); return n })(i, n), e.includes(t) && (i += `${t}99`), queueMicrotask((() => { this.el.value.endsWith(t) || this.el.value[this.el.selectionStart - 1] === t && this.el.setSelectionRange(this.el.selectionStart - 1, this.el.selectionStart - 1) })), i } var Tn = function (e) { e.directive("mask", ((t, { value: n, expression: r }, { effect: i, evaluateLater: o }) => { let s = () => r, a = ""; if (["function", "dynamic"].includes(n)) { let n = o(r); i((() => { s = r => { let i; return e.dontAutoEvaluateFunctions((() => { n((e => { i = "function" == typeof e ? e(r) : e }), { scope: { $input: r, $money: On.bind({ el: t }) } }) })), i }, l(t) })) } else l(t); function l(e, t = !0) { let n = e.value, r = s(n); if (!r || "false" === r) return !1; if (a.length - e.value.length == 1) return a = e.value; let i = () => { a = e.value = function (e, t) { if ("" === e) return ""; let n = Sn(t, e); return Mn(t, n) }(n, r) }; t ? function (e, t, n) { let r = e.selectionStart, i = e.value; n(); let o = i.slice(0, r), s = Mn(t, Sn(t, o)).length; e.setSelectionRange(s, s) }(e, r, (() => { i() })) : i() } t.addEventListener("input", (() => l(t))), t.addEventListener("blur", (() => l(t, !1))) })) }; function Fn(e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function Nn(e) { return e instanceof Fn(e).Element || e instanceof Element } function Bn(e) { return e instanceof Fn(e).HTMLElement || e instanceof HTMLElement } function _n(e) { return "undefined" != typeof ShadowRoot && (e instanceof Fn(e).ShadowRoot || e instanceof ShadowRoot) } var Rn = Math.max, Ln = Math.min, Pn = Math.round; function In() { var e = navigator.userAgentData; return null != e && e.brands ? e.brands.map((function (e) { return e.brand + "/" + e.version })).join(" ") : navigator.userAgent } function $n() { return !/^((?!chrome|android).)*safari/i.test(In()) } function zn(e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !1); var r = e.getBoundingClientRect(), i = 1, o = 1; t && Bn(e) && (i = e.offsetWidth > 0 && Pn(r.width) / e.offsetWidth || 1, o = e.offsetHeight > 0 && Pn(r.height) / e.offsetHeight || 1); var s = (Nn(e) ? Fn(e) : window).visualViewport, a = !$n() && n, l = (r.left + (a && s ? s.offsetLeft : 0)) / i, c = (r.top + (a && s ? s.offsetTop : 0)) / o, u = r.width / i, d = r.height / o; return { width: u, height: d, top: c, right: l + u, bottom: c + d, left: l, x: l, y: c } } function jn(e) { var t = Fn(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function Hn(e) { return e ? (e.nodeName || "").toLowerCase() : null } function Vn(e) { return ((Nn(e) ? e.ownerDocument : e.document) || window.document).documentElement } function Wn(e) { return zn(Vn(e)).left + jn(e).scrollLeft } function qn(e) { return Fn(e).getComputedStyle(e) } function Kn(e) { var t = qn(e), n = t.overflow, r = t.overflowX, i = t.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + r) } function Jn(e, t, n) { void 0 === n && (n = !1); var r, i, o = Bn(t), s = Bn(t) && function (e) { var t = e.getBoundingClientRect(), n = Pn(t.width) / e.offsetWidth || 1, r = Pn(t.height) / e.offsetHeight || 1; return 1 !== n || 1 !== r }(t), a = Vn(t), l = zn(e, s, n), c = { scrollLeft: 0, scrollTop: 0 }, u = { x: 0, y: 0 }; return (o || !o && !n) && (("body" !== Hn(t) || Kn(a)) && (c = (r = t) !== Fn(r) && Bn(r) ? { scrollLeft: (i = r).scrollLeft, scrollTop: i.scrollTop } : jn(r)), Bn(t) ? ((u = zn(t, !0)).x += t.clientLeft, u.y += t.clientTop) : a && (u.x = Wn(a))), { x: l.left + c.scrollLeft - u.x, y: l.top + c.scrollTop - u.y, width: l.width, height: l.height } } function Un(e) { var t = zn(e), n = e.offsetWidth, r = e.offsetHeight; return Math.abs(t.width - n) <= 1 && (n = t.width), Math.abs(t.height - r) <= 1 && (r = t.height), { x: e.offsetLeft, y: e.offsetTop, width: n, height: r } } function Gn(e) { return "html" === Hn(e) ? e : e.assignedSlot || e.parentNode || (_n(e) ? e.host : null) || Vn(e) } function Xn(e) { return ["html", "body", "#document"].indexOf(Hn(e)) >= 0 ? e.ownerDocument.body : Bn(e) && Kn(e) ? e : Xn(Gn(e)) } function Yn(e, t) { var n; void 0 === t && (t = []); var r = Xn(e), i = r === (null == (n = e.ownerDocument) ? void 0 : n.body), o = Fn(r), s = i ? [o].concat(o.visualViewport || [], Kn(r) ? r : []) : r, a = t.concat(s); return i ? a : a.concat(Yn(Gn(s))) } function Zn(e) { return ["table", "td", "th"].indexOf(Hn(e)) >= 0 } function Qn(e) { return Bn(e) && "fixed" !== qn(e).position ? e.offsetParent : null } function er(e) { for (var t = Fn(e), n = Qn(e); n && Zn(n) && "static" === qn(n).position;)n = Qn(n); return n && ("html" === Hn(n) || "body" === Hn(n) && "static" === qn(n).position) ? t : n || function (e) { var t = /firefox/i.test(In()); if (/Trident/i.test(In()) && Bn(e) && "fixed" === qn(e).position) return null; var n = Gn(e); for (_n(n) && (n = n.host); Bn(n) && ["html", "body"].indexOf(Hn(n)) < 0;) { var r = qn(n); if ("none" !== r.transform || "none" !== r.perspective || "paint" === r.contain || -1 !== ["transform", "perspective"].indexOf(r.willChange) || t && "filter" === r.willChange || t && r.filter && "none" !== r.filter) return n; n = n.parentNode } return null }(e) || t } var tr = "top", nr = "bottom", rr = "right", ir = "left", or = "auto", sr = [tr, nr, rr, ir], ar = "start", lr = "end", cr = "viewport", ur = "popper", dr = sr.reduce((function (e, t) { return e.concat([t + "-" + ar, t + "-" + lr]) }), []), hr = [].concat(sr, [or]).reduce((function (e, t) { return e.concat([t, t + "-" + ar, t + "-" + lr]) }), []), pr = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function fr(e) { var t = new Map, n = new Set, r = []; function i(e) { n.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function (e) { if (!n.has(e)) { var r = t.get(e); r && i(r) } })), r.push(e) } return e.forEach((function (e) { t.set(e.name, e) })), e.forEach((function (e) { n.has(e.name) || i(e) })), r } var mr = { placement: "bottom", modifiers: [], strategy: "absolute" }; function gr() { for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n]; return !t.some((function (e) { return !(e && "function" == typeof e.getBoundingClientRect) })) } function yr(e) { void 0 === e && (e = {}); var t = e, n = t.defaultModifiers, r = void 0 === n ? [] : n, i = t.defaultOptions, o = void 0 === i ? mr : i; return function (e, t, n) { void 0 === n && (n = o); var i, s, a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, mr, o), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, l = [], c = !1, u = { state: a, setOptions: function (n) { var i = "function" == typeof n ? n(a.options) : n; d(), a.options = Object.assign({}, o, a.options, i), a.scrollParents = { reference: Nn(e) ? Yn(e) : e.contextElement ? Yn(e.contextElement) : [], popper: Yn(t) }; var s = function (e) { var t = fr(e); return pr.reduce((function (e, n) { return e.concat(t.filter((function (e) { return e.phase === n }))) }), []) }(function (e) { var t = e.reduce((function (e, t) { var n = e[t.name]; return e[t.name] = n ? Object.assign({}, n, t, { options: Object.assign({}, n.options, t.options), data: Object.assign({}, n.data, t.data) }) : t, e }), {}); return Object.keys(t).map((function (e) { return t[e] })) }([].concat(r, a.options.modifiers))); return a.orderedModifiers = s.filter((function (e) { return e.enabled })), a.orderedModifiers.forEach((function (e) { var t = e.name, n = e.options, r = void 0 === n ? {} : n, i = e.effect; if ("function" == typeof i) { var o = i({ state: a, name: t, instance: u, options: r }), s = function () { }; l.push(o || s) } })), u.update() }, forceUpdate: function () { if (!c) { var e = a.elements, t = e.reference, n = e.popper; if (gr(t, n)) { a.rects = { reference: Jn(t, er(n), "fixed" === a.options.strategy), popper: Un(n) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) })); for (var r = 0; r < a.orderedModifiers.length; r++)if (!0 !== a.reset) { var i = a.orderedModifiers[r], o = i.fn, s = i.options, l = void 0 === s ? {} : s, d = i.name; "function" == typeof o && (a = o({ state: a, options: l, name: d, instance: u }) || a) } else a.reset = !1, r = -1 } } }, update: (i = function () { return new Promise((function (e) { u.forceUpdate(), e(a) })) }, function () { return s || (s = new Promise((function (e) { Promise.resolve().then((function () { s = void 0, e(i()) })) }))), s }), destroy: function () { d(), c = !0 } }; if (!gr(e, t)) return u; function d() { l.forEach((function (e) { return e() })), l = [] } return u.setOptions(n).then((function (e) { !c && n.onFirstUpdate && n.onFirstUpdate(e) })), u } } var vr = { passive: !0 }; const br = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, n = e.instance, r = e.options, i = r.scroll, o = void 0 === i || i, s = r.resize, a = void 0 === s || s, l = Fn(t.elements.popper), c = [].concat(t.scrollParents.reference, t.scrollParents.popper); return o && c.forEach((function (e) { e.addEventListener("scroll", n.update, vr) })), a && l.addEventListener("resize", n.update, vr), function () { o && c.forEach((function (e) { e.removeEventListener("scroll", n.update, vr) })), a && l.removeEventListener("resize", n.update, vr) } }, data: {} }; function wr(e) { return e.split("-")[0] } function Dr(e) { return e.split("-")[1] } function xr(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function Cr(e) { var t, n = e.reference, r = e.element, i = e.placement, o = i ? wr(i) : null, s = i ? Dr(i) : null, a = n.x + n.width / 2 - r.width / 2, l = n.y + n.height / 2 - r.height / 2; switch (o) { case tr: t = { x: a, y: n.y - r.height }; break; case nr: t = { x: a, y: n.y + n.height }; break; case rr: t = { x: n.x + n.width, y: l }; break; case ir: t = { x: n.x - r.width, y: l }; break; default: t = { x: n.x, y: n.y } }var c = o ? xr(o) : null; if (null != c) { var u = "y" === c ? "height" : "width"; switch (s) { case ar: t[c] = t[c] - (n[u] / 2 - r[u] / 2); break; case lr: t[c] = t[c] + (n[u] / 2 - r[u] / 2) } } return t } var kr = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function Ar(e) { var t, n = e.popper, r = e.popperRect, i = e.placement, o = e.variation, s = e.offsets, a = e.position, l = e.gpuAcceleration, c = e.adaptive, u = e.roundOffsets, d = e.isFixed, h = s.x, p = void 0 === h ? 0 : h, f = s.y, m = void 0 === f ? 0 : f, g = "function" == typeof u ? u({ x: p, y: m }) : { x: p, y: m }; p = g.x, m = g.y; var y = s.hasOwnProperty("x"), v = s.hasOwnProperty("y"), b = ir, w = tr, D = window; if (c) { var x = er(n), C = "clientHeight", k = "clientWidth"; if (x === Fn(n) && "static" !== qn(x = Vn(n)).position && "absolute" === a && (C = "scrollHeight", k = "scrollWidth"), x = x, i === tr || (i === ir || i === rr) && o === lr) w = nr, m -= (d && x === D && D.visualViewport ? D.visualViewport.height : x[C]) - r.height, m *= l ? 1 : -1; if (i === ir || (i === tr || i === nr) && o === lr) b = rr, p -= (d && x === D && D.visualViewport ? D.visualViewport.width : x[k]) - r.width, p *= l ? 1 : -1 } var A, E = Object.assign({ position: a }, c && kr), S = !0 === u ? function (e) { var t = e.x, n = e.y, r = window.devicePixelRatio || 1; return { x: Pn(t * r) / r || 0, y: Pn(n * r) / r || 0 } }({ x: p, y: m }) : { x: p, y: m }; return p = S.x, m = S.y, l ? Object.assign({}, E, ((A = {})[w] = v ? "0" : "", A[b] = y ? "0" : "", A.transform = (D.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", A)) : Object.assign({}, E, ((t = {})[w] = v ? m + "px" : "", t[b] = y ? p + "px" : "", t.transform = "", t)) } const Er = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, n = e.options, r = n.gpuAcceleration, i = void 0 === r || r, o = n.adaptive, s = void 0 === o || o, a = n.roundOffsets, l = void 0 === a || a, c = { placement: wr(t.placement), variation: Dr(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: i, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, Ar(Object.assign({}, c, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: s, roundOffsets: l })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ar(Object.assign({}, c, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }; const Sr = { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var t = e.state; Object.keys(t.elements).forEach((function (e) { var n = t.styles[e] || {}, r = t.attributes[e] || {}, i = t.elements[e]; Bn(i) && Hn(i) && (Object.assign(i.style, n), Object.keys(r).forEach((function (e) { var t = r[e]; !1 === t ? i.removeAttribute(e) : i.setAttribute(e, !0 === t ? "" : t) }))) })) }, effect: function (e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow), function () { Object.keys(t.elements).forEach((function (e) { var r = t.elements[e], i = t.attributes[e] || {}, o = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : n[e]).reduce((function (e, t) { return e[t] = "", e }), {}); Bn(r) && Hn(r) && (Object.assign(r.style, o), Object.keys(i).forEach((function (e) { r.removeAttribute(e) }))) })) } }, requires: ["computeStyles"] }; const Mr = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, n = e.options, r = e.name, i = n.offset, o = void 0 === i ? [0, 0] : i, s = hr.reduce((function (e, n) { return e[n] = function (e, t, n) { var r = wr(e), i = [ir, tr].indexOf(r) >= 0 ? -1 : 1, o = "function" == typeof n ? n(Object.assign({}, t, { placement: e })) : n, s = o[0], a = o[1]; return s = s || 0, a = (a || 0) * i, [ir, rr].indexOf(r) >= 0 ? { x: a, y: s } : { x: s, y: a } }(n, t.rects, o), e }), {}), a = s[t.placement], l = a.x, c = a.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[r] = s } }; var Or = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Tr(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return Or[e] })) } var Fr = { start: "end", end: "start" }; function Nr(e) { return e.replace(/start|end/g, (function (e) { return Fr[e] })) } function Br(e, t) { var n = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (n && _n(n)) { var r = t; do { if (r && e.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function _r(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Rr(e, t, n) { return t === cr ? _r(function (e, t) { var n = Fn(e), r = Vn(e), i = n.visualViewport, o = r.clientWidth, s = r.clientHeight, a = 0, l = 0; if (i) { o = i.width, s = i.height; var c = $n(); (c || !c && "fixed" === t) && (a = i.offsetLeft, l = i.offsetTop) } return { width: o, height: s, x: a + Wn(e), y: l } }(e, n)) : Nn(t) ? function (e, t) { var n = zn(e, !1, "fixed" === t); return n.top = n.top + e.clientTop, n.left = n.left + e.clientLeft, n.bottom = n.top + e.clientHeight, n.right = n.left + e.clientWidth, n.width = e.clientWidth, n.height = e.clientHeight, n.x = n.left, n.y = n.top, n }(t, n) : _r(function (e) { var t, n = Vn(e), r = jn(e), i = null == (t = e.ownerDocument) ? void 0 : t.body, o = Rn(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), s = Rn(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), a = -r.scrollLeft + Wn(e), l = -r.scrollTop; return "rtl" === qn(i || n).direction && (a += Rn(n.clientWidth, i ? i.clientWidth : 0) - o), { width: o, height: s, x: a, y: l } }(Vn(e))) } function Lr(e, t, n, r) { var i = "clippingParents" === t ? function (e) { var t = Yn(Gn(e)), n = ["absolute", "fixed"].indexOf(qn(e).position) >= 0 && Bn(e) ? er(e) : e; return Nn(n) ? t.filter((function (e) { return Nn(e) && Br(e, n) && "body" !== Hn(e) })) : [] }(e) : [].concat(t), o = [].concat(i, [n]), s = o[0], a = o.reduce((function (t, n) { var i = Rr(e, n, r); return t.top = Rn(i.top, t.top), t.right = Ln(i.right, t.right), t.bottom = Ln(i.bottom, t.bottom), t.left = Rn(i.left, t.left), t }), Rr(e, s, r)); return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a } function Pr(e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function Ir(e, t) { return t.reduce((function (t, n) { return t[n] = e, t }), {}) } function $r(e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, i = void 0 === r ? e.placement : r, o = n.strategy, s = void 0 === o ? e.strategy : o, a = n.boundary, l = void 0 === a ? "clippingParents" : a, c = n.rootBoundary, u = void 0 === c ? cr : c, d = n.elementContext, h = void 0 === d ? ur : d, p = n.altBoundary, f = void 0 !== p && p, m = n.padding, g = void 0 === m ? 0 : m, y = Pr("number" != typeof g ? g : Ir(g, sr)), v = h === ur ? "reference" : ur, b = e.rects.popper, w = e.elements[f ? v : h], D = Lr(Nn(w) ? w : w.contextElement || Vn(e.elements.popper), l, u, s), x = zn(e.elements.reference), C = Cr({ reference: x, element: b, strategy: "absolute", placement: i }), k = _r(Object.assign({}, b, C)), A = h === ur ? k : x, E = { top: D.top - A.top + y.top, bottom: A.bottom - D.bottom + y.bottom, left: D.left - A.left + y.left, right: A.right - D.right + y.right }, S = e.modifiersData.offset; if (h === ur && S) { var M = S[i]; Object.keys(E).forEach((function (e) { var t = [rr, nr].indexOf(e) >= 0 ? 1 : -1, n = [tr, nr].indexOf(e) >= 0 ? "y" : "x"; E[e] += M[n] * t })) } return E } const zr = { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name; if (!t.modifiersData[r]._skip) { for (var i = n.mainAxis, o = void 0 === i || i, s = n.altAxis, a = void 0 === s || s, l = n.fallbackPlacements, c = n.padding, u = n.boundary, d = n.rootBoundary, h = n.altBoundary, p = n.flipVariations, f = void 0 === p || p, m = n.allowedAutoPlacements, g = t.options.placement, y = wr(g), v = l || (y === g || !f ? [Tr(g)] : function (e) { if (wr(e) === or) return []; var t = Tr(e); return [Nr(e), t, Nr(t)] }(g)), b = [g].concat(v).reduce((function (e, n) { return e.concat(wr(n) === or ? function (e, t) { void 0 === t && (t = {}); var n = t, r = n.placement, i = n.boundary, o = n.rootBoundary, s = n.padding, a = n.flipVariations, l = n.allowedAutoPlacements, c = void 0 === l ? hr : l, u = Dr(r), d = u ? a ? dr : dr.filter((function (e) { return Dr(e) === u })) : sr, h = d.filter((function (e) { return c.indexOf(e) >= 0 })); 0 === h.length && (h = d); var p = h.reduce((function (t, n) { return t[n] = $r(e, { placement: n, boundary: i, rootBoundary: o, padding: s })[wr(n)], t }), {}); return Object.keys(p).sort((function (e, t) { return p[e] - p[t] })) }(t, { placement: n, boundary: u, rootBoundary: d, padding: c, flipVariations: f, allowedAutoPlacements: m }) : n) }), []), w = t.rects.reference, D = t.rects.popper, x = new Map, C = !0, k = b[0], A = 0; A < b.length; A++) { var E = b[A], S = wr(E), M = Dr(E) === ar, O = [tr, nr].indexOf(S) >= 0, T = O ? "width" : "height", F = $r(t, { placement: E, boundary: u, rootBoundary: d, altBoundary: h, padding: c }), N = O ? M ? rr : ir : M ? nr : tr; w[T] > D[T] && (N = Tr(N)); var B = Tr(N), _ = []; if (o && _.push(F[S] <= 0), a && _.push(F[N] <= 0, F[B] <= 0), _.every((function (e) { return e }))) { k = E, C = !1; break } x.set(E, _) } if (C) for (var R = function (e) { var t = b.find((function (t) { var n = x.get(t); if (n) return n.slice(0, e).every((function (e) { return e })) })); if (t) return k = t, "break" }, L = f ? 3 : 1; L > 0; L--) { if ("break" === R(L)) break } t.placement !== k && (t.modifiersData[r]._skip = !0, t.placement = k, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function jr(e, t, n) { return Rn(e, Ln(t, n)) } const Hr = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, n = e.options, r = e.name, i = n.mainAxis, o = void 0 === i || i, s = n.altAxis, a = void 0 !== s && s, l = n.boundary, c = n.rootBoundary, u = n.altBoundary, d = n.padding, h = n.tether, p = void 0 === h || h, f = n.tetherOffset, m = void 0 === f ? 0 : f, g = $r(t, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }), y = wr(t.placement), v = Dr(t.placement), b = !v, w = xr(y), D = "x" === w ? "y" : "x", x = t.modifiersData.popperOffsets, C = t.rects.reference, k = t.rects.popper, A = "function" == typeof m ? m(Object.assign({}, t.rects, { placement: t.placement })) : m, E = "number" == typeof A ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, M = { x: 0, y: 0 }; if (x) { if (o) { var O, T = "y" === w ? tr : ir, F = "y" === w ? nr : rr, N = "y" === w ? "height" : "width", B = x[w], _ = B + g[T], R = B - g[F], L = p ? -k[N] / 2 : 0, P = v === ar ? C[N] : k[N], I = v === ar ? -k[N] : -C[N], $ = t.elements.arrow, z = p && $ ? Un($) : { width: 0, height: 0 }, j = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, H = j[T], V = j[F], W = jr(0, C[N], z[N]), q = b ? C[N] / 2 - L - W - H - E.mainAxis : P - W - H - E.mainAxis, K = b ? -C[N] / 2 + L + W + V + E.mainAxis : I + W + V + E.mainAxis, J = t.elements.arrow && er(t.elements.arrow), U = J ? "y" === w ? J.clientTop || 0 : J.clientLeft || 0 : 0, G = null != (O = null == S ? void 0 : S[w]) ? O : 0, X = B + K - G, Y = jr(p ? Ln(_, B + q - G - U) : _, B, p ? Rn(R, X) : R); x[w] = Y, M[w] = Y - B } if (a) { var Z, Q = "x" === w ? tr : ir, ee = "x" === w ? nr : rr, te = x[D], ne = "y" === D ? "height" : "width", re = te + g[Q], ie = te - g[ee], oe = -1 !== [tr, ir].indexOf(y), se = null != (Z = null == S ? void 0 : S[D]) ? Z : 0, ae = oe ? re : te - C[ne] - k[ne] - se + E.altAxis, le = oe ? te + C[ne] + k[ne] - se - E.altAxis : ie, ce = p && oe ? function (e, t, n) { var r = jr(e, t, n); return r > n ? n : r }(ae, te, le) : jr(p ? ae : re, te, p ? le : ie); x[D] = ce, M[D] = ce - te } t.modifiersData[r] = M } }, requiresIfExists: ["offset"] }; const Vr = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, n = e.state, r = e.name, i = e.options, o = n.elements.arrow, s = n.modifiersData.popperOffsets, a = wr(n.placement), l = xr(a), c = [ir, rr].indexOf(a) >= 0 ? "height" : "width"; if (o && s) { var u = function (e, t) { return Pr("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : Ir(e, sr)) }(i.padding, n), d = Un(o), h = "y" === l ? tr : ir, p = "y" === l ? nr : rr, f = n.rects.reference[c] + n.rects.reference[l] - s[l] - n.rects.popper[c], m = s[l] - n.rects.reference[l], g = er(o), y = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, v = f / 2 - m / 2, b = u[h], w = y - d[c] - u[p], D = y / 2 - d[c] / 2 + v, x = jr(b, D, w), C = l; n.modifiersData[r] = ((t = {})[C] = x, t.centerOffset = x - D, t) } }, effect: function (e) { var t = e.state, n = e.options.element, r = void 0 === n ? "[data-popper-arrow]" : n; null != r && ("string" != typeof r || (r = t.elements.popper.querySelector(r))) && Br(t.elements.popper, r) && (t.elements.arrow = r) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Wr(e, t, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: e.top - t.height - n.y, right: e.right - t.width + n.x, bottom: e.bottom - t.height + n.y, left: e.left - t.width - n.x } } function qr(e) { return [tr, rr, nr, ir].some((function (t) { return e[t] >= 0 })) } var Kr = yr({ defaultModifiers: [br, { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, n = e.name; t.modifiersData[n] = Cr({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, Er, Sr, Mr, zr, Hr, Vr, { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, n = e.name, r = t.rects.reference, i = t.rects.popper, o = t.modifiersData.preventOverflow, s = $r(t, { elementContext: "reference" }), a = $r(t, { altBoundary: !0 }), l = Wr(s, r), c = Wr(a, i, o), u = qr(l), d = qr(c); t.modifiersData[n] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: d }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } }] }), Jr = "tippy-content", Ur = "tippy-backdrop", Gr = "tippy-arrow", Xr = "tippy-svg-arrow", Yr = { passive: !0, capture: !0 }, Zr = function () { return document.body }; function Qr(e, t, n) { if (Array.isArray(e)) { var r = e[t]; return null == r ? Array.isArray(n) ? n[t] : n : r } return e } function ei(e, t) { var n = {}.toString.call(e); return 0 === n.indexOf("[object") && n.indexOf(t + "]") > -1 } function ti(e, t) { return "function" == typeof e ? e.apply(void 0, t) : e } function ni(e, t) { return 0 === t ? e : function (r) { clearTimeout(n), n = setTimeout((function () { e(r) }), t) }; var n } function ri(e) { return [].concat(e) } function ii(e, t) { -1 === e.indexOf(t) && e.push(t) } function oi(e) { return e.split("-")[0] } function si(e) { return [].slice.call(e) } function ai(e) { return Object.keys(e).reduce((function (t, n) { return void 0 !== e[n] && (t[n] = e[n]), t }), {}) } function li() { return document.createElement("div") } function ci(e) { return ["Element", "Fragment"].some((function (t) { return ei(e, t) })) } function ui(e) { return ei(e, "MouseEvent") } function di(e) { return !(!e || !e._tippy || e._tippy.reference !== e) } function hi(e) { return ci(e) ? [e] : function (e) { return ei(e, "NodeList") }(e) ? si(e) : Array.isArray(e) ? e : si(document.querySelectorAll(e)) } function pi(e, t) { e.forEach((function (e) { e && (e.style.transitionDuration = t + "ms") })) } function fi(e, t) { e.forEach((function (e) { e && e.setAttribute("data-state", t) })) } function mi(e) { var t, n = ri(e)[0]; return null != n && null != (t = n.ownerDocument) && t.body ? n.ownerDocument : document } function gi(e, t, n) { var r = t + "EventListener";["transitionend", "webkitTransitionEnd"].forEach((function (t) { e[r](t, n) })) } function yi(e, t) { for (var n = t; n;) { var r; if (e.contains(n)) return !0; n = null == n.getRootNode || null == (r = n.getRootNode()) ? void 0 : r.host } return !1 } var vi = { isTouch: !1 }, bi = 0; function wi() { vi.isTouch || (vi.isTouch = !0, window.performance && document.addEventListener("mousemove", Di)) } function Di() { var e = performance.now(); e - bi < 20 && (vi.isTouch = !1, document.removeEventListener("mousemove", Di)), bi = e } function xi() { var e = document.activeElement; if (di(e)) { var t = e._tippy; e.blur && !t.state.isVisible && e.blur() } } var Ci = !!("undefined" != typeof window && "undefined" != typeof document) && !!window.msCrypto; var ki = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 }, Ai = Object.assign({ appendTo: Zr, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: !0, ignoreAttributes: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function () { }, onBeforeUpdate: function () { }, onCreate: function () { }, onDestroy: function () { }, onHidden: function () { }, onHide: function () { }, onMount: function () { }, onShow: function () { }, onShown: function () { }, onTrigger: function () { }, onUntrigger: function () { }, onClickOutside: function () { }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: !1, touch: !0, trigger: "mouseenter focus", triggerTarget: null }, ki, { allowHTML: !1, animation: "fade", arrow: !0, content: "", inertia: !1, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }), Ei = Object.keys(Ai); function Si(e) { var t = (e.plugins || []).reduce((function (t, n) { var r, i = n.name, o = n.defaultValue; i && (t[i] = void 0 !== e[i] ? e[i] : null != (r = Ai[i]) ? r : o); return t }), {}); return Object.assign({}, e, t) } function Mi(e, t) { var n = Object.assign({}, t, { content: ti(t.content, [e]) }, t.ignoreAttributes ? {} : function (e, t) { var n = (t ? Object.keys(Si(Object.assign({}, Ai, { plugins: t }))) : Ei).reduce((function (t, n) { var r = (e.getAttribute("data-tippy-" + n) || "").trim(); if (!r) return t; if ("content" === n) t[n] = r; else try { t[n] = JSON.parse(r) } catch (e) { t[n] = r } return t }), {}); return n }(e, t.plugins)); return n.aria = Object.assign({}, Ai.aria, n.aria), n.aria = { expanded: "auto" === n.aria.expanded ? t.interactive : n.aria.expanded, content: "auto" === n.aria.content ? t.interactive ? null : "describedby" : n.aria.content }, n } function Oi(e, t) { e.innerHTML = t } function Ti(e) { var t = li(); return !0 === e ? t.className = Gr : (t.className = Xr, ci(e) ? t.appendChild(e) : Oi(t, e)), t } function Fi(e, t) { ci(t.content) ? (Oi(e, ""), e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? Oi(e, t.content) : e.textContent = t.content) } function Ni(e) { var t = e.firstElementChild, n = si(t.children); return { box: t, content: n.find((function (e) { return e.classList.contains(Jr) })), arrow: n.find((function (e) { return e.classList.contains(Gr) || e.classList.contains(Xr) })), backdrop: n.find((function (e) { return e.classList.contains(Ur) })) } } function Bi(e) { var t = li(), n = li(); n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1"); var r = li(); function i(n, r) { var i = Ni(t), o = i.box, s = i.content, a = i.arrow; r.theme ? o.setAttribute("data-theme", r.theme) : o.removeAttribute("data-theme"), "string" == typeof r.animation ? o.setAttribute("data-animation", r.animation) : o.removeAttribute("data-animation"), r.inertia ? o.setAttribute("data-inertia", "") : o.removeAttribute("data-inertia"), o.style.maxWidth = "number" == typeof r.maxWidth ? r.maxWidth + "px" : r.maxWidth, r.role ? o.setAttribute("role", r.role) : o.removeAttribute("role"), n.content === r.content && n.allowHTML === r.allowHTML || Fi(s, e.props), r.arrow ? a ? n.arrow !== r.arrow && (o.removeChild(a), o.appendChild(Ti(r.arrow))) : o.appendChild(Ti(r.arrow)) : a && o.removeChild(a) } return r.className = Jr, r.setAttribute("data-state", "hidden"), Fi(r, e.props), t.appendChild(n), n.appendChild(r), i(e.props, e.props), { popper: t, onUpdate: i } } Bi.$$tippy = !0; var _i = 1, Ri = [], Li = []; function Pi(e, t) { var n, r, i, o, s, a, l, c, u = Mi(e, Object.assign({}, Ai, Si(ai(t)))), d = !1, h = !1, p = !1, f = !1, m = [], g = ni(J, u.interactiveDebounce), y = _i++, v = (c = u.plugins).filter((function (e, t) { return c.indexOf(e) === t })), b = { id: y, reference: e, popper: li(), popperInstance: null, props: u, state: { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, plugins: v, clearDelayTimeouts: function () { clearTimeout(n), clearTimeout(r), cancelAnimationFrame(i) }, setProps: function (t) { 0; if (b.state.isDestroyed) return; B("onBeforeUpdate", [b, t]), q(); var n = b.props, r = Mi(e, Object.assign({}, n, ai(t), { ignoreAttributes: !0 })); b.props = r, W(), n.interactiveDebounce !== r.interactiveDebounce && (L(), g = ni(J, r.interactiveDebounce)); n.triggerTarget && !r.triggerTarget ? ri(n.triggerTarget).forEach((function (e) { e.removeAttribute("aria-expanded") })) : r.triggerTarget && e.removeAttribute("aria-expanded"); R(), N(), x && x(n, r); b.popperInstance && (Y(), Q().forEach((function (e) { requestAnimationFrame(e._tippy.popperInstance.forceUpdate) }))); B("onAfterUpdate", [b, t]) }, setContent: function (e) { b.setProps({ content: e }) }, show: function () { 0; var e = b.state.isVisible, t = b.state.isDestroyed, n = !b.state.isEnabled, r = vi.isTouch && !b.props.touch, i = Qr(b.props.duration, 0, Ai.duration); if (e || t || n || r) return; if (M().hasAttribute("disabled")) return; if (B("onShow", [b], !1), !1 === b.props.onShow(b)) return; b.state.isVisible = !0, S() && (D.style.visibility = "visible"); N(), z(), b.state.isMounted || (D.style.transition = "none"); if (S()) { var o = T(), s = o.box, l = o.content; pi([s, l], 0) } a = function () { var e; if (b.state.isVisible && !f) { if (f = !0, D.offsetHeight, D.style.transition = b.props.moveTransition, S() && b.props.animation) { var t = T(), n = t.box, r = t.content; pi([n, r], i), fi([n, r], "visible") } _(), R(), ii(Li, b), null == (e = b.popperInstance) || e.forceUpdate(), B("onMount", [b]), b.props.animation && S() && function (e, t) { H(e, t) }(i, (function () { b.state.isShown = !0, B("onShown", [b]) })) } }, function () { var e, t = b.props.appendTo, n = M(); e = b.props.interactive && t === Zr || "parent" === t ? n.parentNode : ti(t, [n]); e.contains(D) || e.appendChild(D); b.state.isMounted = !0, Y(), !1 }() }, hide: function () { 0; var e = !b.state.isVisible, t = b.state.isDestroyed, n = !b.state.isEnabled, r = Qr(b.props.duration, 1, Ai.duration); if (e || t || n) return; if (B("onHide", [b], !1), !1 === b.props.onHide(b)) return; b.state.isVisible = !1, b.state.isShown = !1, f = !1, d = !1, S() && (D.style.visibility = "hidden"); if (L(), j(), N(!0), S()) { var i = T(), o = i.box, s = i.content; b.props.animation && (pi([o, s], r), fi([o, s], "hidden")) } _(), R(), b.props.animation ? S() && function (e, t) { H(e, (function () { !b.state.isVisible && D.parentNode && D.parentNode.contains(D) && t() })) }(r, b.unmount) : b.unmount() }, hideWithInteractivity: function (e) { 0; O().addEventListener("mousemove", g), ii(Ri, g), g(e) }, enable: function () { b.state.isEnabled = !0 }, disable: function () { b.hide(), b.state.isEnabled = !1 }, unmount: function () { 0; b.state.isVisible && b.hide(); if (!b.state.isMounted) return; Z(), Q().forEach((function (e) { e._tippy.unmount() })), D.parentNode && D.parentNode.removeChild(D); Li = Li.filter((function (e) { return e !== b })), b.state.isMounted = !1, B("onHidden", [b]) }, destroy: function () { 0; if (b.state.isDestroyed) return; b.clearDelayTimeouts(), b.unmount(), q(), delete e._tippy, b.state.isDestroyed = !0, B("onDestroy", [b]) } }; if (!u.render) return b; var w = u.render(b), D = w.popper, x = w.onUpdate; D.setAttribute("data-tippy-root", ""), D.id = "tippy-" + b.id, b.popper = D, e._tippy = b, D._tippy = b; var C = v.map((function (e) { return e.fn(b) })), k = e.hasAttribute("aria-expanded"); return W(), R(), N(), B("onCreate", [b]), u.showOnCreate && ee(), D.addEventListener("mouseenter", (function () { b.props.interactive && b.state.isVisible && b.clearDelayTimeouts() })), D.addEventListener("mouseleave", (function () { b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && O().addEventListener("mousemove", g) })), b; function A() { var e = b.props.touch; return Array.isArray(e) ? e : [e, 0] } function E() { return "hold" === A()[0] } function S() { var e; return !(null == (e = b.props.render) || !e.$$tippy) } function M() { return l || e } function O() { var e = M().parentNode; return e ? mi(e) : document } function T() { return Ni(D) } function F(e) { return b.state.isMounted && !b.state.isVisible || vi.isTouch || o && "focus" === o.type ? 0 : Qr(b.props.delay, e ? 0 : 1, Ai.delay) } function N(e) { void 0 === e && (e = !1), D.style.pointerEvents = b.props.interactive && !e ? "" : "none", D.style.zIndex = "" + b.props.zIndex } function B(e, t, n) { var r; (void 0 === n && (n = !0), C.forEach((function (n) { n[e] && n[e].apply(n, t) })), n) && (r = b.props)[e].apply(r, t) } function _() { var t = b.props.aria; if (t.content) { var n = "aria-" + t.content, r = D.id; ri(b.props.triggerTarget || e).forEach((function (e) { var t = e.getAttribute(n); if (b.state.isVisible) e.setAttribute(n, t ? t + " " + r : r); else { var i = t && t.replace(r, "").trim(); i ? e.setAttribute(n, i) : e.removeAttribute(n) } })) } } function R() { !k && b.props.aria.expanded && ri(b.props.triggerTarget || e).forEach((function (e) { b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === M() ? "true" : "false") : e.removeAttribute("aria-expanded") })) } function L() { O().removeEventListener("mousemove", g), Ri = Ri.filter((function (e) { return e !== g })) } function P(t) { if (!vi.isTouch || !p && "mousedown" !== t.type) { var n = t.composedPath && t.composedPath()[0] || t.target; if (!b.props.interactive || !yi(D, n)) { if (ri(b.props.triggerTarget || e).some((function (e) { return yi(e, n) }))) { if (vi.isTouch) return; if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0) return } else B("onClickOutside", [b, t]); !0 === b.props.hideOnClick && (b.clearDelayTimeouts(), b.hide(), h = !0, setTimeout((function () { h = !1 })), b.state.isMounted || j()) } } } function I() { p = !0 } function $() { p = !1 } function z() { var e = O(); e.addEventListener("mousedown", P, !0), e.addEventListener("touchend", P, Yr), e.addEventListener("touchstart", $, Yr), e.addEventListener("touchmove", I, Yr) } function j() { var e = O(); e.removeEventListener("mousedown", P, !0), e.removeEventListener("touchend", P, Yr), e.removeEventListener("touchstart", $, Yr), e.removeEventListener("touchmove", I, Yr) } function H(e, t) { var n = T().box; function r(e) { e.target === n && (gi(n, "remove", r), t()) } if (0 === e) return t(); gi(n, "remove", s), gi(n, "add", r), s = r } function V(t, n, r) { void 0 === r && (r = !1), ri(b.props.triggerTarget || e).forEach((function (e) { e.addEventListener(t, n, r), m.push({ node: e, eventType: t, handler: n, options: r }) })) } function W() { var e; E() && (V("touchstart", K, { passive: !0 }), V("touchend", U, { passive: !0 })), (e = b.props.trigger, e.split(/\s+/).filter(Boolean)).forEach((function (e) { if ("manual" !== e) switch (V(e, K), e) { case "mouseenter": V("mouseleave", U); break; case "focus": V(Ci ? "focusout" : "blur", G); break; case "focusin": V("focusout", G) } })) } function q() { m.forEach((function (e) { var t = e.node, n = e.eventType, r = e.handler, i = e.options; t.removeEventListener(n, r, i) })), m = [] } function K(e) { var t, n = !1; if (b.state.isEnabled && !X(e) && !h) { var r = "focus" === (null == (t = o) ? void 0 : t.type); o = e, l = e.currentTarget, R(), !b.state.isVisible && ui(e) && Ri.forEach((function (t) { return t(e) })), "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || d) && !1 !== b.props.hideOnClick && b.state.isVisible ? n = !0 : ee(e), "click" === e.type && (d = !n), n && !r && te(e) } } function J(e) { var t = e.target, n = M().contains(t) || D.contains(t); if ("mousemove" !== e.type || !n) { var r = Q().concat(D).map((function (e) { var t, n = null == (t = e._tippy.popperInstance) ? void 0 : t.state; return n ? { popperRect: e.getBoundingClientRect(), popperState: n, props: u } : null })).filter(Boolean); (function (e, t) { var n = t.clientX, r = t.clientY; return e.every((function (e) { var t = e.popperRect, i = e.popperState, o = e.props.interactiveBorder, s = oi(i.placement), a = i.modifiersData.offset; if (!a) return !0; var l = "bottom" === s ? a.top.y : 0, c = "top" === s ? a.bottom.y : 0, u = "right" === s ? a.left.x : 0, d = "left" === s ? a.right.x : 0, h = t.top - r + l > o, p = r - t.bottom - c > o, f = t.left - n + u > o, m = n - t.right - d > o; return h || p || f || m })) })(r, e) && (L(), te(e)) } } function U(e) { X(e) || b.props.trigger.indexOf("click") >= 0 && d || (b.props.interactive ? b.hideWithInteractivity(e) : te(e)) } function G(e) { b.props.trigger.indexOf("focusin") < 0 && e.target !== M() || b.props.interactive && e.relatedTarget && D.contains(e.relatedTarget) || te(e) } function X(e) { return !!vi.isTouch && E() !== e.type.indexOf("touch") >= 0 } function Y() { Z(); var t = b.props, n = t.popperOptions, r = t.placement, i = t.offset, o = t.getReferenceClientRect, s = t.moveTransition, l = S() ? Ni(D).arrow : null, c = o ? { getBoundingClientRect: o, contextElement: o.contextElement || M() } : e, u = { name: "$$tippy", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: function (e) { var t = e.state; if (S()) { var n = T().box;["placement", "reference-hidden", "escaped"].forEach((function (e) { "placement" === e ? n.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? n.setAttribute("data-" + e, "") : n.removeAttribute("data-" + e) })), t.attributes.popper = {} } } }, d = [{ name: "offset", options: { offset: i } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !s } }, u]; S() && l && d.push({ name: "arrow", options: { element: l, padding: 3 } }), d.push.apply(d, (null == n ? void 0 : n.modifiers) || []), b.popperInstance = Kr(c, D, Object.assign({}, n, { placement: r, onFirstUpdate: a, modifiers: d })) } function Z() { b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null) } function Q() { return si(D.querySelectorAll("[data-tippy-root]")) } function ee(e) { b.clearDelayTimeouts(), e && B("onTrigger", [b, e]), z(); var t = F(!0), r = A(), i = r[0], o = r[1]; vi.isTouch && "hold" === i && o && (t = o), t ? n = setTimeout((function () { b.show() }), t) : b.show() } function te(e) { if (b.clearDelayTimeouts(), B("onUntrigger", [b, e]), b.state.isVisible) { if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && d)) { var t = F(!1); t ? r = setTimeout((function () { b.state.isVisible && b.hide() }), t) : i = requestAnimationFrame((function () { b.hide() })) } } else j() } } function Ii(e, t) { void 0 === t && (t = {}); var n = Ai.plugins.concat(t.plugins || []); document.addEventListener("touchstart", wi, Yr), window.addEventListener("blur", xi); var r = Object.assign({}, t, { plugins: n }), i = hi(e).reduce((function (e, t) { var n = t && Pi(t, r); return n && e.push(n), e }), []); return ci(e) ? i[0] : i } Ii.defaultProps = Ai, Ii.setDefaultProps = function (e) { Object.keys(e).forEach((function (t) { Ai[t] = e[t] })) }, Ii.currentInput = vi; Object.assign({}, Sr, { effect: function (e) { var t = e.state, n = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; Object.assign(t.elements.popper.style, n.popper), t.styles = n, t.elements.arrow && Object.assign(t.elements.arrow.style, n.arrow) } }); Ii.setDefaultProps({ render: Bi }); const $i = Ii; var zi = n(379), ji = n.n(zi), Hi = n(95), Vi = { insert: "head", singleton: !1 }; ji()(Hi.Z, Vi); Hi.Z.locals; function Wi(e) { this.content = e } Wi.prototype = { constructor: Wi, find: function (e) { for (var t = 0; t < this.content.length; t += 2)if (this.content[t] === e) return t; return -1 }, get: function (e) { var t = this.find(e); return -1 == t ? void 0 : this.content[t + 1] }, update: function (e, t, n) { var r = n && n != e ? this.remove(n) : this, i = r.find(e), o = r.content.slice(); return -1 == i ? o.push(n || e, t) : (o[i + 1] = t, n && (o[i] = n)), new Wi(o) }, remove: function (e) { var t = this.find(e); if (-1 == t) return this; var n = this.content.slice(); return n.splice(t, 2), new Wi(n) }, addToStart: function (e, t) { return new Wi([e, t].concat(this.remove(e).content)) }, addToEnd: function (e, t) { var n = this.remove(e).content.slice(); return n.push(e, t), new Wi(n) }, addBefore: function (e, t, n) { var r = this.remove(t), i = r.content.slice(), o = r.find(e); return i.splice(-1 == o ? i.length : o, 0, t, n), new Wi(i) }, forEach: function (e) { for (var t = 0; t < this.content.length; t += 2)e(this.content[t], this.content[t + 1]) }, prepend: function (e) { return (e = Wi.from(e)).size ? new Wi(e.content.concat(this.subtract(e).content)) : this }, append: function (e) { return (e = Wi.from(e)).size ? new Wi(this.subtract(e).content.concat(e.content)) : this }, subtract: function (e) { var t = this; e = Wi.from(e); for (var n = 0; n < e.content.length; n += 2)t = t.remove(e.content[n]); return t }, get size() { return this.content.length >> 1 } }, Wi.from = function (e) { if (e instanceof Wi) return e; var t = []; if (e) for (var n in e) t.push(n, e[n]); return new Wi(t) }; const qi = Wi; function Ki(e, t, n) { for (let r = 0; ; r++) { if (r == e.childCount || r == t.childCount) return e.childCount == t.childCount ? null : n; let i = e.child(r), o = t.child(r); if (i != o) { if (!i.sameMarkup(o)) return n; if (i.isText && i.text != o.text) { for (let e = 0; i.text[e] == o.text[e]; e++)n++; return n } if (i.content.size || o.content.size) { let e = Ki(i.content, o.content, n + 1); if (null != e) return e } n += i.nodeSize } else n += i.nodeSize } } function Ji(e, t, n, r) { for (let i = e.childCount, o = t.childCount; ;) { if (0 == i || 0 == o) return i == o ? null : { a: n, b: r }; let s = e.child(--i), a = t.child(--o), l = s.nodeSize; if (s != a) { if (!s.sameMarkup(a)) return { a: n, b: r }; if (s.isText && s.text != a.text) { let e = 0, t = Math.min(s.text.length, a.text.length); for (; e < t && s.text[s.text.length - e - 1] == a.text[a.text.length - e - 1];)e++, n--, r--; return { a: n, b: r } } if (s.content.size || a.content.size) { let e = Ji(s.content, a.content, n - 1, r - 1); if (e) return e } n -= l, r -= l } else n -= l, r -= l } } class Ui { constructor(e, t) { if (this.content = e, this.size = t || 0, null == t) for (let t = 0; t < e.length; t++)this.size += e[t].nodeSize } nodesBetween(e, t, n, r = 0, i) { for (let o = 0, s = 0; s < t; o++) { let a = this.content[o], l = s + a.nodeSize; if (l > e && !1 !== n(a, r + s, i || null, o) && a.content.size) { let i = s + 1; a.nodesBetween(Math.max(0, e - i), Math.min(a.content.size, t - i), n, r + i) } s = l } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, t, n, r) { let i = "", o = !0; return this.nodesBetween(e, t, ((s, a) => { s.isText ? (i += s.text.slice(Math.max(e, a) - a, t - a), o = !n) : s.isLeaf ? (r ? i += "function" == typeof r ? r(s) : r : s.type.spec.leafText && (i += s.type.spec.leafText(s)), o = !n) : !o && s.isBlock && (i += n, o = !0) }), 0), i } append(e) { if (!e.size) return this; if (!this.size) return e; let t = this.lastChild, n = e.firstChild, r = this.content.slice(), i = 0; for (t.isText && t.sameMarkup(n) && (r[r.length - 1] = t.withText(t.text + n.text), i = 1); i < e.content.length; i++)r.push(e.content[i]); return new Ui(r, this.size + e.size) } cut(e, t = this.size) { if (0 == e && t == this.size) return this; let n = [], r = 0; if (t > e) for (let i = 0, o = 0; o < t; i++) { let s = this.content[i], a = o + s.nodeSize; a > e && ((o < e || a > t) && (s = s.isText ? s.cut(Math.max(0, e - o), Math.min(s.text.length, t - o)) : s.cut(Math.max(0, e - o - 1), Math.min(s.content.size, t - o - 1))), n.push(s), r += s.nodeSize), o = a } return new Ui(n, r) } cutByIndex(e, t) { return e == t ? Ui.empty : 0 == e && t == this.content.length ? this : new Ui(this.content.slice(e, t)) } replaceChild(e, t) { let n = this.content[e]; if (n == t) return this; let r = this.content.slice(), i = this.size + t.nodeSize - n.nodeSize; return r[e] = t, new Ui(r, i) } addToStart(e) { return new Ui([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new Ui(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let t = 0; t < this.content.length; t++)if (!this.content[t].eq(e.content[t])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let t = this.content[e]; if (!t) throw new RangeError("Index " + e + " out of range for " + this); return t } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let t = 0, n = 0; t < this.content.length; t++) { let r = this.content[t]; e(r, n, t), n += r.nodeSize } } findDiffStart(e, t = 0) { return Ki(this, e, t) } findDiffEnd(e, t = this.size, n = e.size) { return Ji(this, e, t, n) } findIndex(e, t = -1) { if (0 == e) return Xi(0, e); if (e == this.size) return Xi(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let n = 0, r = 0; ; n++) { let i = r + this.child(n).nodeSize; if (i >= e) return i == e || t > 0 ? Xi(n + 1, i) : Xi(n, r); r = i } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map((e => e.toJSON())) : null } static fromJSON(e, t) { if (!t) return Ui.empty; if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new Ui(t.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return Ui.empty; let t, n = 0; for (let r = 0; r < e.length; r++) { let i = e[r]; n += i.nodeSize, r && i.isText && e[r - 1].sameMarkup(i) ? (t || (t = e.slice(0, r)), t[t.length - 1] = i.withText(t[t.length - 1].text + i.text)) : t && t.push(i) } return new Ui(t || e, n) } static from(e) { if (!e) return Ui.empty; if (e instanceof Ui) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new Ui([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } Ui.empty = new Ui([], 0); const Gi = { index: 0, offset: 0 }; function Xi(e, t) { return Gi.index = e, Gi.offset = t, Gi } function Yi(e, t) { if (e === t) return !0; if (!e || "object" != typeof e || !t || "object" != typeof t) return !1; let n = Array.isArray(e); if (Array.isArray(t) != n) return !1; if (n) { if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!Yi(e[n], t[n])) return !1 } else { for (let n in e) if (!(n in t) || !Yi(e[n], t[n])) return !1; for (let n in t) if (!(n in e)) return !1 } return !0 } class Zi { constructor(e, t) { this.type = e, this.attrs = t } addToSet(e) { let t, n = !1; for (let r = 0; r < e.length; r++) { let i = e[r]; if (this.eq(i)) return e; if (this.type.excludes(i.type)) t || (t = e.slice(0, r)); else { if (i.type.excludes(this.type)) return e; !n && i.type.rank > this.type.rank && (t || (t = e.slice(0, r)), t.push(this), n = !0), t && t.push(i) } } return t || (t = e.slice()), n || t.push(this), t } removeFromSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1)); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && Yi(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Mark.fromJSON"); let n = e.marks[t.type]; if (!n) throw new RangeError(`There is no mark type ${t.type} in this schema`); return n.create(t.attrs) } static sameSet(e, t) { if (e == t) return !0; if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!e[n].eq(t[n])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && 0 == e.length) return Zi.none; if (e instanceof Zi) return [e]; let t = e.slice(); return t.sort(((e, t) => e.type.rank - t.type.rank)), t } } Zi.none = []; class Qi extends Error { } class eo { constructor(e, t, n) { this.content = e, this.openStart = t, this.openEnd = n } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, t) { let n = no(this.content, e + this.openStart, t); return n && new eo(n, this.openStart, this.openEnd) } removeBetween(e, t) { return new eo(to(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, t) { if (!t) return eo.empty; let n = t.openStart || 0, r = t.openEnd || 0; if ("number" != typeof n || "number" != typeof r) throw new RangeError("Invalid input for Slice.fromJSON"); return new eo(Ui.fromJSON(e, t.content), n, r) } static maxOpen(e, t = !0) { let n = 0, r = 0; for (let r = e.firstChild; r && !r.isLeaf && (t || !r.type.spec.isolating); r = r.firstChild)n++; for (let n = e.lastChild; n && !n.isLeaf && (t || !n.type.spec.isolating); n = n.lastChild)r++; return new eo(e, n, r) } } function to(e, t, n) { let { index: r, offset: i } = e.findIndex(t), o = e.maybeChild(r), { index: s, offset: a } = e.findIndex(n); if (i == t || o.isText) { if (a != n && !e.child(s).isText) throw new RangeError("Removing non-flat range"); return e.cut(0, t).append(e.cut(n)) } if (r != s) throw new RangeError("Removing non-flat range"); return e.replaceChild(r, o.copy(to(o.content, t - i - 1, n - i - 1))) } function no(e, t, n, r) { let { index: i, offset: o } = e.findIndex(t), s = e.maybeChild(i); if (o == t || s.isText) return r && !r.canReplace(i, i, n) ? null : e.cut(0, t).append(n).append(e.cut(t)); let a = no(s.content, t - o - 1, n); return a && e.replaceChild(i, s.copy(a)) } function ro(e, t, n) { if (n.openStart > e.depth) throw new Qi("Inserted content deeper than insertion position"); if (e.depth - n.openStart != t.depth - n.openEnd) throw new Qi("Inconsistent open depths"); return io(e, t, n, 0) } function io(e, t, n, r) { let i = e.index(r), o = e.node(r); if (i == t.index(r) && r < e.depth - n.openStart) { let s = io(e, t, n, r + 1); return o.copy(o.content.replaceChild(i, s)) } if (n.content.size) { if (n.openStart || n.openEnd || e.depth != r || t.depth != r) { let { start: i, end: s } = function (e, t) { let n = t.depth - e.openStart, r = t.node(n).copy(e.content); for (let e = n - 1; e >= 0; e--)r = t.node(e).copy(Ui.from(r)); return { start: r.resolveNoCache(e.openStart + n), end: r.resolveNoCache(r.content.size - e.openEnd - n) } }(n, e); return co(o, uo(e, i, s, t, r)) } { let r = e.parent, i = r.content; return co(r, i.cut(0, e.parentOffset).append(n.content).append(i.cut(t.parentOffset))) } } return co(o, ho(e, t, r)) } function oo(e, t) { if (!t.type.compatibleContent(e.type)) throw new Qi("Cannot join " + t.type.name + " onto " + e.type.name) } function so(e, t, n) { let r = e.node(n); return oo(r, t.node(n)), r } function ao(e, t) { let n = t.length - 1; n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e) } function lo(e, t, n, r) { let i = (t || e).node(n), o = 0, s = t ? t.index(n) : i.childCount; e && (o = e.index(n), e.depth > n ? o++ : e.textOffset && (ao(e.nodeAfter, r), o++)); for (let e = o; e < s; e++)ao(i.child(e), r); t && t.depth == n && t.textOffset && ao(t.nodeBefore, r) } function co(e, t) { if (!e.type.validContent(t)) throw new Qi("Invalid content for node " + e.type.name); return e.copy(t) } function uo(e, t, n, r, i) { let o = e.depth > i && so(e, t, i + 1), s = r.depth > i && so(n, r, i + 1), a = []; return lo(null, e, i, a), o && s && t.index(i) == n.index(i) ? (oo(o, s), ao(co(o, uo(e, t, n, r, i + 1)), a)) : (o && ao(co(o, ho(e, t, i + 1)), a), lo(t, n, i, a), s && ao(co(s, ho(n, r, i + 1)), a)), lo(r, null, i, a), new Ui(a) } function ho(e, t, n) { let r = []; if (lo(null, e, n, r), e.depth > n) { ao(co(so(e, t, n + 1), ho(e, t, n + 1)), r) } return lo(t, null, n, r), new Ui(r) } eo.empty = new eo(Ui.empty, 0, 0); class po { constructor(e, t, n) { this.pos = e, this.path = t, this.parentOffset = n, this.depth = t.length / 3 - 1 } resolveDepth(e) { return null == e ? this.depth : e < 0 ? this.depth + e : e } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(e) { return this.path[3 * this.resolveDepth(e)] } index(e) { return this.path[3 * this.resolveDepth(e) + 1] } indexAfter(e) { return e = this.resolveDepth(e), this.index(e) + (e != this.depth || this.textOffset ? 1 : 0) } start(e) { return 0 == (e = this.resolveDepth(e)) ? 0 : this.path[3 * e - 1] + 1 } end(e) { return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size } before(e) { if (!(e = this.resolveDepth(e))) throw new RangeError("There is no position before the top-level node"); return e == this.depth + 1 ? this.pos : this.path[3 * e - 1] } after(e) { if (!(e = this.resolveDepth(e))) throw new RangeError("There is no position after the top-level node"); return e == this.depth + 1 ? this.pos : this.path[3 * e - 1] + this.path[3 * e].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let e = this.parent, t = this.index(this.depth); if (t == e.childCount) return null; let n = this.pos - this.path[this.path.length - 1], r = e.child(t); return n ? e.child(t).cut(n) : r } get nodeBefore() { let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1]; return t ? this.parent.child(e).cut(0, t) : 0 == e ? null : this.parent.child(e - 1) } posAtIndex(e, t) { t = this.resolveDepth(t); let n = this.path[3 * t], r = 0 == t ? 0 : this.path[3 * t - 1] + 1; for (let t = 0; t < e; t++)r += n.child(t).nodeSize; return r } marks() { let e = this.parent, t = this.index(); if (0 == e.content.size) return Zi.none; if (this.textOffset) return e.child(t).marks; let n = e.maybeChild(t - 1), r = e.maybeChild(t); if (!n) { let e = n; n = r, r = e } let i = n.marks; for (var o = 0; o < i.length; o++)!1 !== i[o].type.spec.inclusive || r && i[o].isInSet(r.marks) || (i = i[o--].removeFromSet(i)); return i } marksAcross(e) { let t = this.parent.maybeChild(this.index()); if (!t || !t.isInline) return null; let n = t.marks, r = e.parent.maybeChild(e.index()); for (var i = 0; i < n.length; i++)!1 !== n[i].type.spec.inclusive || r && n[i].isInSet(r.marks) || (n = n[i--].removeFromSet(n)); return n } sharedDepth(e) { for (let t = this.depth; t > 0; t--)if (this.start(t) <= e && this.end(t) >= e) return t; return 0 } blockRange(e = this, t) { if (e.pos < this.pos) return e.blockRange(this); for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)if (e.pos <= this.end(n) && (!t || t(this.node(n)))) return new yo(this, e, n); return null } sameParent(e) { return this.pos - this.parentOffset == e.pos - e.parentOffset } max(e) { return e.pos > this.pos ? e : this } min(e) { return e.pos < this.pos ? e : this } toString() { let e = ""; for (let t = 1; t <= this.depth; t++)e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1); return e + ":" + this.parentOffset } static resolve(e, t) { if (!(t >= 0 && t <= e.content.size)) throw new RangeError("Position " + t + " out of range"); let n = [], r = 0, i = t; for (let t = e; ;) { let { index: e, offset: o } = t.content.findIndex(i), s = i - o; if (n.push(t, e, r + o), !s) break; if (t = t.child(e), t.isText) break; i = s - 1, r += o + 1 } return new po(t, n, i) } static resolveCached(e, t) { for (let n = 0; n < fo.length; n++) { let r = fo[n]; if (r.pos == t && r.doc == e) return r } let n = fo[mo] = po.resolve(e, t); return mo = (mo + 1) % go, n } } let fo = [], mo = 0, go = 12; class yo { constructor(e, t, n) { this.$from = e, this.$to = t, this.depth = n } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const vo = Object.create(null); class bo { constructor(e, t, n, r = Zi.none) { this.type = e, this.attrs = t, this.marks = r, this.content = n || Ui.empty } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(e) { return this.content.child(e) } maybeChild(e) { return this.content.maybeChild(e) } forEach(e) { this.content.forEach(e) } nodesBetween(e, t, n, r = 0) { this.content.nodesBetween(e, t, n, r, this) } descendants(e) { this.nodesBetween(0, this.content.size, e) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(e, t, n, r) { return this.content.textBetween(e, t, n, r) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(e) { return this == e || this.sameMarkup(e) && this.content.eq(e.content) } sameMarkup(e) { return this.hasMarkup(e.type, e.attrs, e.marks) } hasMarkup(e, t, n) { return this.type == e && Yi(this.attrs, t || e.defaultAttrs || vo) && Zi.sameSet(this.marks, n || Zi.none) } copy(e = null) { return e == this.content ? this : new bo(this.type, this.attrs, e, this.marks) } mark(e) { return e == this.marks ? this : new bo(this.type, this.attrs, this.content, e) } cut(e, t = this.content.size) { return 0 == e && t == this.content.size ? this : this.copy(this.content.cut(e, t)) } slice(e, t = this.content.size, n = !1) { if (e == t) return eo.empty; let r = this.resolve(e), i = this.resolve(t), o = n ? 0 : r.sharedDepth(t), s = r.start(o), a = r.node(o).content.cut(r.pos - s, i.pos - s); return new eo(a, r.depth - o, i.depth - o) } replace(e, t, n) { return ro(this.resolve(e), this.resolve(t), n) } nodeAt(e) { for (let t = this; ;) { let { index: n, offset: r } = t.content.findIndex(e); if (t = t.maybeChild(n), !t) return null; if (r == e || t.isText) return t; e -= r + 1 } } childAfter(e) { let { index: t, offset: n } = this.content.findIndex(e); return { node: this.content.maybeChild(t), index: t, offset: n } } childBefore(e) { if (0 == e) return { node: null, index: 0, offset: 0 }; let { index: t, offset: n } = this.content.findIndex(e); if (n < e) return { node: this.content.child(t), index: t, offset: n }; let r = this.content.child(t - 1); return { node: r, index: t - 1, offset: n - r.nodeSize } } resolve(e) { return po.resolveCached(this, e) } resolveNoCache(e) { return po.resolve(this, e) } rangeHasMark(e, t, n) { let r = !1; return t > e && this.nodesBetween(e, t, (e => (n.isInSet(e.marks) && (r = !0), !r))), r } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let e = this.type.name; return this.content.size && (e += "(" + this.content.toStringInner() + ")"), Do(this.marks, e) } contentMatchAt(e) { let t = this.type.contentMatch.matchFragment(this.content, 0, e); if (!t) throw new Error("Called contentMatchAt on a node with invalid content"); return t } canReplace(e, t, n = Ui.empty, r = 0, i = n.childCount) { let o = this.contentMatchAt(e).matchFragment(n, r, i), s = o && o.matchFragment(this.content, t); if (!s || !s.validEnd) return !1; for (let e = r; e < i; e++)if (!this.type.allowsMarks(n.child(e).marks)) return !1; return !0 } canReplaceWith(e, t, n, r) { if (r && !this.type.allowsMarks(r)) return !1; let i = this.contentMatchAt(e).matchType(n), o = i && i.matchFragment(this.content, t); return !!o && o.validEnd } canAppend(e) { return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type) } check() { if (!this.type.validContent(this.content)) throw new RangeError(`Invalid content for node ${this.type.name}: ${this.content.toString().slice(0, 50)}`); let e = Zi.none; for (let t = 0; t < this.marks.length; t++)e = this.marks[t].addToSet(e); if (!Zi.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((e => e.type.name))}`); this.content.forEach((e => e.check())) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((e => e.toJSON()))), e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Node.fromJSON"); let n = null; if (t.marks) { if (!Array.isArray(t.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); n = t.marks.map(e.markFromJSON) } if ("text" == t.type) { if ("string" != typeof t.text) throw new RangeError("Invalid text node in JSON"); return e.text(t.text, n) } let r = Ui.fromJSON(e, t.content); return e.nodeType(t.type).create(t.attrs, r, n) } } bo.prototype.text = void 0; class wo extends bo { constructor(e, t, n, r) { if (super(e, t, null, r), !n) throw new RangeError("Empty text nodes are not allowed"); this.text = n } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : Do(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(e, t) { return this.text.slice(e, t) } get nodeSize() { return this.text.length } mark(e) { return e == this.marks ? this : new wo(this.type, this.attrs, this.text, e) } withText(e) { return e == this.text ? this : new wo(this.type, this.attrs, e, this.marks) } cut(e = 0, t = this.text.length) { return 0 == e && t == this.text.length ? this : this.withText(this.text.slice(e, t)) } eq(e) { return this.sameMarkup(e) && this.text == e.text } toJSON() { let e = super.toJSON(); return e.text = this.text, e } } function Do(e, t) { for (let n = e.length - 1; n >= 0; n--)t = e[n].type.name + "(" + t + ")"; return t } class xo { constructor(e) { this.validEnd = e, this.next = [], this.wrapCache = [] } static parse(e, t) { let n = new Co(e, t); if (null == n.next) return xo.empty; let r = ko(n); n.next && n.err("Unexpected trailing text"); let i = function (e) { let t = Object.create(null); return n(To(e, 0)); function n(r) { let i = []; r.forEach((t => { e[t].forEach((({ term: t, to: n }) => { if (!t) return; let r; for (let e = 0; e < i.length; e++)i[e][0] == t && (r = i[e][1]); To(e, n).forEach((e => { r || i.push([t, r = []]), -1 == r.indexOf(e) && r.push(e) })) })) })); let o = t[r.join(",")] = new xo(r.indexOf(e.length - 1) > -1); for (let e = 0; e < i.length; e++) { let r = i[e][1].sort(Oo); o.next.push({ type: i[e][0], next: t[r.join(",")] || n(r) }) } return o } }(function (e) { let t = [[]]; return i(o(e, 0), n()), t; function n() { return t.push([]) - 1 } function r(e, n, r) { let i = { term: r, to: n }; return t[e].push(i), i } function i(e, t) { e.forEach((e => e.to = t)) } function o(e, t) { if ("choice" == e.type) return e.exprs.reduce(((e, n) => e.concat(o(n, t))), []); if ("seq" != e.type) { if ("star" == e.type) { let s = n(); return r(t, s), i(o(e.expr, s), s), [r(s)] } if ("plus" == e.type) { let s = n(); return i(o(e.expr, t), s), i(o(e.expr, s), s), [r(s)] } if ("opt" == e.type) return [r(t)].concat(o(e.expr, t)); if ("range" == e.type) { let s = t; for (let t = 0; t < e.min; t++) { let t = n(); i(o(e.expr, s), t), s = t } if (-1 == e.max) i(o(e.expr, s), s); else for (let t = e.min; t < e.max; t++) { let t = n(); r(s, t), i(o(e.expr, s), t), s = t } return [r(s)] } if ("name" == e.type) return [r(t, void 0, e.value)]; throw new Error("Unknown expr type") } for (let r = 0; ; r++) { let s = o(e.exprs[r], t); if (r == e.exprs.length - 1) return s; i(s, t = n()) } } }(r)); return function (e, t) { for (let n = 0, r = [e]; n < r.length; n++) { let e = r[n], i = !e.validEnd, o = []; for (let t = 0; t < e.next.length; t++) { let { type: n, next: s } = e.next[t]; o.push(n.name), !i || n.isText || n.hasRequiredAttrs() || (i = !1), -1 == r.indexOf(s) && r.push(s) } i && t.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } }(i, n), i } matchType(e) { for (let t = 0; t < this.next.length; t++)if (this.next[t].type == e) return this.next[t].next; return null } matchFragment(e, t = 0, n = e.childCount) { let r = this; for (let i = t; r && i < n; i++)r = r.matchType(e.child(i).type); return r } get inlineContent() { return this.next.length && this.next[0].type.isInline } get defaultType() { for (let e = 0; e < this.next.length; e++) { let { type: t } = this.next[e]; if (!t.isText && !t.hasRequiredAttrs()) return t } return null } compatible(e) { for (let t = 0; t < this.next.length; t++)for (let n = 0; n < e.next.length; n++)if (this.next[t].type == e.next[n].type) return !0; return !1 } fillBefore(e, t = !1, n = 0) { let r = [this]; return function i(o, s) { let a = o.matchFragment(e, n); if (a && (!t || a.validEnd)) return Ui.from(s.map((e => e.createAndFill()))); for (let e = 0; e < o.next.length; e++) { let { type: t, next: n } = o.next[e]; if (!t.isText && !t.hasRequiredAttrs() && -1 == r.indexOf(n)) { r.push(n); let e = i(n, s.concat(t)); if (e) return e } } return null }(this, []) } findWrapping(e) { for (let t = 0; t < this.wrapCache.length; t += 2)if (this.wrapCache[t] == e) return this.wrapCache[t + 1]; let t = this.computeWrapping(e); return this.wrapCache.push(e, t), t } computeWrapping(e) { let t = Object.create(null), n = [{ match: this, type: null, via: null }]; for (; n.length;) { let r = n.shift(), i = r.match; if (i.matchType(e)) { let e = []; for (let t = r; t.type; t = t.via)e.push(t.type); return e.reverse() } for (let e = 0; e < i.next.length; e++) { let { type: o, next: s } = i.next[e]; o.isLeaf || o.hasRequiredAttrs() || o.name in t || r.type && !s.validEnd || (n.push({ match: o.contentMatch, type: o, via: r }), t[o.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(e) { if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`); return this.next[e] } toString() { let e = []; return function t(n) { e.push(n); for (let r = 0; r < n.next.length; r++)-1 == e.indexOf(n.next[r].next) && t(n.next[r].next) }(this), e.map(((t, n) => { let r = n + (t.validEnd ? "*" : " ") + " "; for (let n = 0; n < t.next.length; n++)r += (n ? ", " : "") + t.next[n].type.name + "->" + e.indexOf(t.next[n].next); return r })).join("\n") } } xo.empty = new xo(!0); class Co { constructor(e, t) { this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), "" == this.tokens[this.tokens.length - 1] && this.tokens.pop(), "" == this.tokens[0] && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(e) { return this.next == e && (this.pos++ || !0) } err(e) { throw new SyntaxError(e + " (in content expression '" + this.string + "')") } } function ko(e) { let t = []; do { t.push(Ao(e)) } while (e.eat("|")); return 1 == t.length ? t[0] : { type: "choice", exprs: t } } function Ao(e) { let t = []; do { t.push(Eo(e)) } while (e.next && ")" != e.next && "|" != e.next); return 1 == t.length ? t[0] : { type: "seq", exprs: t } } function Eo(e) { let t = function (e) { if (e.eat("(")) { let t = ko(e); return e.eat(")") || e.err("Missing closing paren"), t } if (!/\W/.test(e.next)) { let t = function (e, t) { let n = e.nodeTypes, r = n[t]; if (r) return [r]; let i = []; for (let e in n) { let r = n[e]; r.groups.indexOf(t) > -1 && i.push(r) } 0 == i.length && e.err("No node type or group '" + t + "' found"); return i }(e, e.next).map((t => (null == e.inline ? e.inline = t.isInline : e.inline != t.isInline && e.err("Mixing inline and block content"), { type: "name", value: t }))); return e.pos++, 1 == t.length ? t[0] : { type: "choice", exprs: t } } e.err("Unexpected token '" + e.next + "'") }(e); for (; ;)if (e.eat("+")) t = { type: "plus", expr: t }; else if (e.eat("*")) t = { type: "star", expr: t }; else if (e.eat("?")) t = { type: "opt", expr: t }; else { if (!e.eat("{")) break; t = Mo(e, t) } return t } function So(e) { /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'"); let t = Number(e.next); return e.pos++, t } function Mo(e, t) { let n = So(e), r = n; return e.eat(",") && (r = "}" != e.next ? So(e) : -1), e.eat("}") || e.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: t } } function Oo(e, t) { return t - e } function To(e, t) { let n = []; return function t(r) { let i = e[r]; if (1 == i.length && !i[0].term) return t(i[0].to); n.push(r); for (let e = 0; e < i.length; e++) { let { term: r, to: o } = i[e]; r || -1 != n.indexOf(o) || t(o) } }(t), n.sort(Oo) } function Fo(e) { let t = Object.create(null); for (let n in e) { let r = e[n]; if (!r.hasDefault) return null; t[n] = r.default } return t } function No(e, t) { let n = Object.create(null); for (let r in e) { let i = t && t[r]; if (void 0 === i) { let t = e[r]; if (!t.hasDefault) throw new RangeError("No value supplied for attribute " + r); i = t.default } n[r] = i } return n } function Bo(e) { let t = Object.create(null); if (e) for (let n in e) t[n] = new Ro(e[n]); return t } class _o { constructor(e, t, n) { this.name = e, this.schema = t, this.spec = n, this.markSet = null, this.groups = n.group ? n.group.split(" ") : [], this.attrs = Bo(n.attrs), this.defaultAttrs = Fo(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(n.inline || "text" == e), this.isText = "text" == e } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == xo.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let e in this.attrs) if (this.attrs[e].isRequired) return !0; return !1 } compatibleContent(e) { return this == e || this.contentMatch.compatible(e.contentMatch) } computeAttrs(e) { return !e && this.defaultAttrs ? this.defaultAttrs : No(this.attrs, e) } create(e = null, t, n) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new bo(this, this.computeAttrs(e), Ui.from(t), Zi.setFrom(n)) } createChecked(e = null, t, n) { if (t = Ui.from(t), !this.validContent(t)) throw new RangeError("Invalid content for node " + this.name); return new bo(this, this.computeAttrs(e), t, Zi.setFrom(n)) } createAndFill(e = null, t, n) { if (e = this.computeAttrs(e), (t = Ui.from(t)).size) { let e = this.contentMatch.fillBefore(t); if (!e) return null; t = e.append(t) } let r = this.contentMatch.matchFragment(t), i = r && r.fillBefore(Ui.empty, !0); return i ? new bo(this, e, t.append(i), Zi.setFrom(n)) : null } validContent(e) { let t = this.contentMatch.matchFragment(e); if (!t || !t.validEnd) return !1; for (let t = 0; t < e.childCount; t++)if (!this.allowsMarks(e.child(t).marks)) return !1; return !0 } allowsMarkType(e) { return null == this.markSet || this.markSet.indexOf(e) > -1 } allowsMarks(e) { if (null == this.markSet) return !0; for (let t = 0; t < e.length; t++)if (!this.allowsMarkType(e[t].type)) return !1; return !0 } allowedMarks(e) { if (null == this.markSet) return e; let t; for (let n = 0; n < e.length; n++)this.allowsMarkType(e[n].type) ? t && t.push(e[n]) : t || (t = e.slice(0, n)); return t ? t.length ? t : Zi.none : e } static compile(e, t) { let n = Object.create(null); e.forEach(((e, r) => n[e] = new _o(e, t, r))); let r = t.spec.topNode || "doc"; if (!n[r]) throw new RangeError("Schema is missing its top node type ('" + r + "')"); if (!n.text) throw new RangeError("Every schema needs a 'text' type"); for (let e in n.text.attrs) throw new RangeError("The text node type should not have attributes"); return n } } class Ro { constructor(e) { this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default } get isRequired() { return !this.hasDefault } } class Lo { constructor(e, t, n, r) { this.name = e, this.rank = t, this.schema = n, this.spec = r, this.attrs = Bo(r.attrs), this.excluded = null; let i = Fo(this.attrs); this.instance = i ? new Zi(this, i) : null } create(e = null) { return !e && this.instance ? this.instance : new Zi(this, No(this.attrs, e)) } static compile(e, t) { let n = Object.create(null), r = 0; return e.forEach(((e, i) => n[e] = new Lo(e, r++, t, i))), n } removeFromSet(e) { for (var t = 0; t < e.length; t++)e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (e[t].type == this) return e[t] } excludes(e) { return this.excluded.indexOf(e) > -1 } } class Po { constructor(e) { this.cached = Object.create(null), this.spec = { nodes: qi.from(e.nodes), marks: qi.from(e.marks || {}), topNode: e.topNode }, this.nodes = _o.compile(this.spec.nodes, this), this.marks = Lo.compile(this.spec.marks, this); let t = Object.create(null); for (let e in this.nodes) { if (e in this.marks) throw new RangeError(e + " can not be both a node and a mark"); let n = this.nodes[e], r = n.spec.content || "", i = n.spec.marks; n.contentMatch = t[r] || (t[r] = xo.parse(r, this.nodes)), n.inlineContent = n.contentMatch.inlineContent, n.markSet = "_" == i ? null : i ? Io(this, i.split(" ")) : "" != i && n.inlineContent ? null : [] } for (let e in this.marks) { let t = this.marks[e], n = t.spec.excludes; t.excluded = null == n ? [t] : "" == n ? [] : Io(this, n.split(" ")) } this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(e, t = null, n, r) { if ("string" == typeof e) e = this.nodeType(e); else { if (!(e instanceof _o)) throw new RangeError("Invalid node type: " + e); if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")") } return e.createChecked(t, n, r) } text(e, t) { let n = this.nodes.text; return new wo(n, n.defaultAttrs, e, Zi.setFrom(t)) } mark(e, t) { return "string" == typeof e && (e = this.marks[e]), e.create(t) } nodeFromJSON(e) { return bo.fromJSON(this, e) } markFromJSON(e) { return Zi.fromJSON(this, e) } nodeType(e) { let t = this.nodes[e]; if (!t) throw new RangeError("Unknown node type: " + e); return t } } function Io(e, t) { let n = []; for (let r = 0; r < t.length; r++) { let i = t[r], o = e.marks[i], s = o; if (o) n.push(o); else for (let t in e.marks) { let r = e.marks[t]; ("_" == i || r.spec.group && r.spec.group.split(" ").indexOf(i) > -1) && n.push(s = r) } if (!s) throw new SyntaxError("Unknown mark type: '" + t[r] + "'") } return n } class $o { constructor(e, t) { this.schema = e, this.rules = t, this.tags = [], this.styles = [], t.forEach((e => { e.tag ? this.tags.push(e) : e.style && this.styles.push(e) })), this.normalizeLists = !this.tags.some((t => { if (!/^(ul|ol)\b/.test(t.tag) || !t.node) return !1; let n = e.nodes[t.node]; return n.contentMatch.matchType(n) })) } parse(e, t = {}) { let n = new qo(this, t, !1); return n.addAll(e, t.from, t.to), n.finish() } parseSlice(e, t = {}) { let n = new qo(this, t, !0); return n.addAll(e, t.from, t.to), eo.maxOpen(n.finish()) } matchTag(e, t, n) { for (let r = n ? this.tags.indexOf(n) + 1 : 0; r < this.tags.length; r++) { let n = this.tags[r]; if (Ko(e, n.tag) && (void 0 === n.namespace || e.namespaceURI == n.namespace) && (!n.context || t.matchesContext(n.context))) { if (n.getAttrs) { let t = n.getAttrs(e); if (!1 === t) continue; n.attrs = t || void 0 } return n } } } matchStyle(e, t, n, r) { for (let i = r ? this.styles.indexOf(r) + 1 : 0; i < this.styles.length; i++) { let r = this.styles[i], o = r.style; if (!(0 != o.indexOf(e) || r.context && !n.matchesContext(r.context) || o.length > e.length && (61 != o.charCodeAt(e.length) || o.slice(e.length + 1) != t))) { if (r.getAttrs) { let e = r.getAttrs(t); if (!1 === e) continue; r.attrs = e || void 0 } return r } } } static schemaRules(e) { let t = []; function n(e) { let n = null == e.priority ? 50 : e.priority, r = 0; for (; r < t.length; r++) { let e = t[r]; if ((null == e.priority ? 50 : e.priority) < n) break } t.splice(r, 0, e) } for (let t in e.marks) { let r = e.marks[t].spec.parseDOM; r && r.forEach((e => { n(e = Jo(e)), e.mark = t })) } for (let t in e.nodes) { let r = e.nodes[t].spec.parseDOM; r && r.forEach((e => { n(e = Jo(e)), e.node = t })) } return t } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new $o(e, $o.schemaRules(e))) } } const zo = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, jo = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, Ho = { ol: !0, ul: !0 }; function Vo(e, t, n) { return null != t ? (t ? 1 : 0) | ("full" === t ? 2 : 0) : e && "pre" == e.whitespace ? 3 : -5 & n } class Wo { constructor(e, t, n, r, i, o, s) { this.type = e, this.attrs = t, this.marks = n, this.pendingMarks = r, this.solid = i, this.options = s, this.content = [], this.activeMarks = Zi.none, this.stashMarks = [], this.match = o || (4 & s ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let t = this.type.contentMatch.fillBefore(Ui.from(e)); if (!t) { let t, n = this.type.contentMatch; return (t = n.findWrapping(e.type)) ? (this.match = n, t) : null } this.match = this.type.contentMatch.matchFragment(t) } return this.match.findWrapping(e.type) } finish(e) { if (!(1 & this.options)) { let e, t = this.content[this.content.length - 1]; if (t && t.isText && (e = /[ \t\r\n\u000c]+$/.exec(t.text))) { let n = t; t.text.length == e[0].length ? this.content.pop() : this.content[this.content.length - 1] = n.withText(n.text.slice(0, n.text.length - e[0].length)) } } let t = Ui.from(this.content); return !e && this.match && (t = t.append(this.match.fillBefore(Ui.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t } popFromStashMark(e) { for (let t = this.stashMarks.length - 1; t >= 0; t--)if (e.eq(this.stashMarks[t])) return this.stashMarks.splice(t, 1)[0] } applyPending(e) { for (let t = 0, n = this.pendingMarks; t < n.length; t++) { let r = n[t]; (this.type ? this.type.allowsMarkType(r.type) : Uo(r.type, e)) && !r.isInSet(this.activeMarks) && (this.activeMarks = r.addToSet(this.activeMarks), this.pendingMarks = r.removeFromSet(this.pendingMarks)) } } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !zo.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } } class qo { constructor(e, t, n) { this.parser = e, this.options = t, this.isOpen = n, this.open = 0; let r, i = t.topNode, o = Vo(null, t.preserveWhitespace, 0) | (n ? 4 : 0); r = i ? new Wo(i.type, i.attrs, Zi.none, Zi.none, !0, t.topMatch || i.type.contentMatch, o) : new Wo(n ? null : e.schema.topNodeType, null, Zi.none, Zi.none, !0, null, o), this.nodes = [r], this.find = t.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e) { if (3 == e.nodeType) this.addTextNode(e); else if (1 == e.nodeType) { let t = e.getAttribute("style"), n = t ? this.readStyles(function (e) { let t, n = /\s*([\w-]+)\s*:\s*([^;]+)/g, r = []; for (; t = n.exec(e);)r.push(t[1], t[2].trim()); return r }(t)) : null, r = this.top; if (null != n) for (let e = 0; e < n.length; e++)this.addPendingMark(n[e]); if (this.addElement(e), null != n) for (let e = 0; e < n.length; e++)this.removePendingMark(n[e], r) } } addTextNode(e) { let t = e.nodeValue, n = this.top; if (2 & n.options || n.inlineContext(e) || /[^ \t\r\n\u000c]/.test(t)) { if (1 & n.options) t = 2 & n.options ? t.replace(/\r\n?/g, "\n") : t.replace(/\r?\n|\r/g, " "); else if (t = t.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(t) && this.open == this.nodes.length - 1) { let r = n.content[n.content.length - 1], i = e.previousSibling; (!r || i && "BR" == i.nodeName || r.isText && /[ \t\r\n\u000c]$/.test(r.text)) && (t = t.slice(1)) } t && this.insertNode(this.parser.schema.text(t)), this.findInText(e) } else this.findInside(e) } addElement(e, t) { let n, r = e.nodeName.toLowerCase(); Ho.hasOwnProperty(r) && this.parser.normalizeLists && function (e) { for (let t = e.firstChild, n = null; t; t = t.nextSibling) { let e = 1 == t.nodeType ? t.nodeName.toLowerCase() : null; e && Ho.hasOwnProperty(e) && n ? (n.appendChild(t), t = n) : "li" == e ? n = t : e && (n = null) } }(e); let i = this.options.ruleFromNode && this.options.ruleFromNode(e) || (n = this.parser.matchTag(e, this, t)); if (i ? i.ignore : jo.hasOwnProperty(r)) this.findInside(e), this.ignoreFallback(e); else if (!i || i.skip || i.closeParent) { i && i.closeParent ? this.open = Math.max(0, this.open - 1) : i && i.skip.nodeType && (e = i.skip); let t, n = this.top, o = this.needsBlock; if (zo.hasOwnProperty(r)) t = !0, n.type || (this.needsBlock = !0); else if (!e.firstChild) return void this.leafFallback(e); this.addAll(e), t && this.sync(n), this.needsBlock = o } else this.addElementByRule(e, i, !1 === i.consuming ? n : void 0) } leafFallback(e) { "BR" == e.nodeName && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode("\n")) } ignoreFallback(e) { "BR" != e.nodeName || this.top.type && this.top.type.inlineContent || this.findPlace(this.parser.schema.text("-")) } readStyles(e) { let t = Zi.none; e: for (let n = 0; n < e.length; n += 2)for (let r; ;) { let i = this.parser.matchStyle(e[n], e[n + 1], this, r); if (!i) continue e; if (i.ignore) return null; if (t = this.parser.schema.marks[i.mark].create(i.attrs).addToSet(t), !1 !== i.consuming) break; r = i } return t } addElementByRule(e, t, n) { let r, i, o; if (t.node) i = this.parser.schema.nodes[t.node], i.isLeaf ? this.insertNode(i.create(t.attrs)) || this.leafFallback(e) : r = this.enter(i, t.attrs || null, t.preserveWhitespace); else { o = this.parser.schema.marks[t.mark].create(t.attrs), this.addPendingMark(o) } let s = this.top; if (i && i.isLeaf) this.findInside(e); else if (n) this.addElement(e, n); else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach((e => this.insertNode(e))); else { let n = e; "string" == typeof t.contentElement ? n = e.querySelector(t.contentElement) : "function" == typeof t.contentElement ? n = t.contentElement(e) : t.contentElement && (n = t.contentElement), this.findAround(e, n, !0), this.addAll(n) } r && this.sync(s) && this.open--, o && this.removePendingMark(o, s) } addAll(e, t, n) { let r = t || 0; for (let i = t ? e.childNodes[t] : e.firstChild, o = null == n ? null : e.childNodes[n]; i != o; i = i.nextSibling, ++r)this.findAtPoint(e, r), this.addDOM(i); this.findAtPoint(e, r) } findPlace(e) { let t, n; for (let r = this.open; r >= 0; r--) { let i = this.nodes[r], o = i.findWrapping(e); if (o && (!t || t.length > o.length) && (t = o, n = i, !o.length)) break; if (i.solid) break } if (!t) return !1; this.sync(n); for (let e = 0; e < t.length; e++)this.enterInner(t[e], null, !1); return !0 } insertNode(e) { if (e.isInline && this.needsBlock && !this.top.type) { let e = this.textblockFromContext(); e && this.enterInner(e) } if (this.findPlace(e)) { this.closeExtra(); let t = this.top; t.applyPending(e.type), t.match && (t.match = t.match.matchType(e.type)); let n = t.activeMarks; for (let r = 0; r < e.marks.length; r++)t.type && !t.type.allowsMarkType(e.marks[r].type) || (n = e.marks[r].addToSet(n)); return t.content.push(e.mark(n)), !0 } return !1 } enter(e, t, n) { let r = this.findPlace(e.create(t)); return r && this.enterInner(e, t, !0, n), r } enterInner(e, t = null, n = !1, r) { this.closeExtra(); let i = this.top; i.applyPending(e), i.match = i.match && i.match.matchType(e); let o = Vo(e, r, i.options); 4 & i.options && 0 == i.content.length && (o |= 4), this.nodes.push(new Wo(e, t, i.activeMarks, i.pendingMarks, n, null, o)), this.open++ } closeExtra(e = !1) { let t = this.nodes.length - 1; if (t > this.open) { for (; t > this.open; t--)this.nodes[t - 1].content.push(this.nodes[t].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen) } sync(e) { for (let t = this.open; t >= 0; t--)if (this.nodes[t] == e) return this.open = t, !0; return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let t = this.open; t >= 0; t--) { let n = this.nodes[t].content; for (let t = n.length - 1; t >= 0; t--)e += n[t].nodeSize; t && e++ } return e } findAtPoint(e, t) { if (this.find) for (let n = 0; n < this.find.length; n++)this.find[n].node == e && this.find[n].offset == t && (this.find[n].pos = this.currentPos) } findInside(e) { if (this.find) for (let t = 0; t < this.find.length; t++)null == this.find[t].pos && 1 == e.nodeType && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos) } findAround(e, t, n) { if (e != t && this.find) for (let r = 0; r < this.find.length; r++)if (null == this.find[r].pos && 1 == e.nodeType && e.contains(this.find[r].node)) { t.compareDocumentPosition(this.find[r].node) & (n ? 2 : 4) && (this.find[r].pos = this.currentPos) } } findInText(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let t = e.split("/"), n = this.options.context, r = !(this.isOpen || n && n.parent.type != this.nodes[0].type), i = -(n ? n.depth + 1 : 0) + (r ? 0 : 1), o = (e, s) => { for (; e >= 0; e--) { let a = t[e]; if ("" == a) { if (e == t.length - 1 || 0 == e) continue; for (; s >= i; s--)if (o(e - 1, s)) return !0; return !1 } { let e = s > 0 || 0 == s && r ? this.nodes[s].type : n && s >= i ? n.node(s - i).type : null; if (!e || e.name != a && -1 == e.groups.indexOf(a)) return !1; s-- } } return !0 }; return o(t.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let t = e.depth; t >= 0; t--) { let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType; if (n && n.isTextblock && n.defaultAttrs) return n } for (let e in this.parser.schema.nodes) { let t = this.parser.schema.nodes[e]; if (t.isTextblock && t.defaultAttrs) return t } } addPendingMark(e) { let t = function (e, t) { for (let n = 0; n < t.length; n++)if (e.eq(t[n])) return t[n] }(e, this.top.pendingMarks); t && this.top.stashMarks.push(t), this.top.pendingMarks = e.addToSet(this.top.pendingMarks) } removePendingMark(e, t) { for (let n = this.open; n >= 0; n--) { let r = this.nodes[n]; if (r.pendingMarks.lastIndexOf(e) > -1) r.pendingMarks = e.removeFromSet(r.pendingMarks); else { r.activeMarks = e.removeFromSet(r.activeMarks); let t = r.popFromStashMark(e); t && r.type && r.type.allowsMarkType(t.type) && (r.activeMarks = t.addToSet(r.activeMarks)) } if (r == t) break } } } function Ko(e, t) { return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t) } function Jo(e) { let t = {}; for (let n in e) t[n] = e[n]; return t } function Uo(e, t) { let n = t.schema.nodes; for (let r in n) { let i = n[r]; if (!i.allowsMarkType(e)) continue; let o = [], s = e => { o.push(e); for (let n = 0; n < e.edgeCount; n++) { let { type: r, next: i } = e.edge(n); if (r == t) return !0; if (o.indexOf(i) < 0 && s(i)) return !0 } }; if (s(i.contentMatch)) return !0 } } class Go { constructor(e, t) { this.nodes = e, this.marks = t } serializeFragment(e, t = {}, n) { n || (n = Yo(t).createDocumentFragment()); let r = n, i = []; return e.forEach((e => { if (i.length || e.marks.length) { let n = 0, o = 0; for (; n < i.length && o < e.marks.length;) { let t = e.marks[o]; if (this.marks[t.type.name]) { if (!t.eq(i[n][0]) || !1 === t.type.spec.spanning) break; n++, o++ } else o++ } for (; n < i.length;)r = i.pop()[1]; for (; o < e.marks.length;) { let n = e.marks[o++], s = this.serializeMark(n, e.isInline, t); s && (i.push([n, r]), r.appendChild(s.dom), r = s.contentDOM || s.dom) } } r.appendChild(this.serializeNodeInner(e, t)) })), n } serializeNodeInner(e, t) { let { dom: n, contentDOM: r } = Go.renderSpec(Yo(t), this.nodes[e.type.name](e)); if (r) { if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(e.content, t, r) } return n } serializeNode(e, t = {}) { let n = this.serializeNodeInner(e, t); for (let r = e.marks.length - 1; r >= 0; r--) { let i = this.serializeMark(e.marks[r], e.isInline, t); i && ((i.contentDOM || i.dom).appendChild(n), n = i.dom) } return n } serializeMark(e, t, n = {}) { let r = this.marks[e.type.name]; return r && Go.renderSpec(Yo(n), r(e, t)) } static renderSpec(e, t, n = null) { if ("string" == typeof t) return { dom: e.createTextNode(t) }; if (null != t.nodeType) return { dom: t }; if (t.dom && null != t.dom.nodeType) return t; let r, i = t[0], o = i.indexOf(" "); o > 0 && (n = i.slice(0, o), i = i.slice(o + 1)); let s = n ? e.createElementNS(n, i) : e.createElement(i), a = t[1], l = 1; if (a && "object" == typeof a && null == a.nodeType && !Array.isArray(a)) { l = 2; for (let e in a) if (null != a[e]) { let t = e.indexOf(" "); t > 0 ? s.setAttributeNS(e.slice(0, t), e.slice(t + 1), a[e]) : s.setAttribute(e, a[e]) } } for (let i = l; i < t.length; i++) { let o = t[i]; if (0 === o) { if (i < t.length - 1 || i > l) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: s, contentDOM: s } } { let { dom: t, contentDOM: i } = Go.renderSpec(e, o, n); if (s.appendChild(t), i) { if (r) throw new RangeError("Multiple content holes"); r = i } } } return { dom: s, contentDOM: r } } static fromSchema(e) { return e.cached.domSerializer || (e.cached.domSerializer = new Go(this.nodesFromSchema(e), this.marksFromSchema(e))) } static nodesFromSchema(e) { let t = Xo(e.nodes); return t.text || (t.text = e => e.text), t } static marksFromSchema(e) { return Xo(e.marks) } } function Xo(e) { let t = {}; for (let n in e) { let r = e[n].spec.toDOM; r && (t[n] = r) } return t } function Yo(e) { return e.document || window.document } const Zo = Math.pow(2, 16); function Qo(e, t) { return e + t * Zo } function es(e) { return 65535 & e } class ts { constructor(e, t, n) { this.pos = e, this.delInfo = t, this.recover = n } get deleted() { return (8 & this.delInfo) > 0 } get deletedBefore() { return (5 & this.delInfo) > 0 } get deletedAfter() { return (6 & this.delInfo) > 0 } get deletedAcross() { return (4 & this.delInfo) > 0 } } class ns { constructor(e, t = !1) { if (this.ranges = e, this.inverted = t, !e.length && ns.empty) return ns.empty } recover(e) { let t = 0, n = es(e); if (!this.inverted) for (let e = 0; e < n; e++)t += this.ranges[3 * e + 2] - this.ranges[3 * e + 1]; return this.ranges[3 * n] + t + function (e) { return (e - (65535 & e)) / Zo }(e) } mapResult(e, t = 1) { return this._map(e, t, !1) } map(e, t = 1) { return this._map(e, t, !0) } _map(e, t, n) { let r = 0, i = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2; for (let s = 0; s < this.ranges.length; s += 3) { let a = this.ranges[s] - (this.inverted ? r : 0); if (a > e) break; let l = this.ranges[s + i], c = this.ranges[s + o], u = a + l; if (e <= u) { let i = a + r + ((l ? e == a ? -1 : e == u ? 1 : t : t) < 0 ? 0 : c); if (n) return i; let o = e == (t < 0 ? a : u) ? null : Qo(s / 3, e - a), d = e == a ? 2 : e == u ? 1 : 4; return (t < 0 ? e != a : e != u) && (d |= 8), new ts(i, d, o) } r += c - l } return n ? e + r : new ts(e + r, 0, null) } touches(e, t) { let n = 0, r = es(t), i = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2; for (let t = 0; t < this.ranges.length; t += 3) { let s = this.ranges[t] - (this.inverted ? n : 0); if (s > e) break; let a = this.ranges[t + i]; if (e <= s + a && t == 3 * r) return !0; n += this.ranges[t + o] - a } return !1 } forEach(e) { let t = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2; for (let r = 0, i = 0; r < this.ranges.length; r += 3) { let o = this.ranges[r], s = o - (this.inverted ? i : 0), a = o + (this.inverted ? 0 : i), l = this.ranges[r + t], c = this.ranges[r + n]; e(s, s + l, a, a + c), i += c - l } } invert() { return new ns(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(e) { return 0 == e ? ns.empty : new ns(e < 0 ? [0, -e, 0] : [0, 0, e]) } } ns.empty = new ns([]); class rs { constructor(e = [], t, n = 0, r = e.length) { this.maps = e, this.mirror = t, this.from = n, this.to = r } slice(e = 0, t = this.maps.length) { return new rs(this.maps, this.mirror, e, t) } copy() { return new rs(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to) } appendMap(e, t) { this.to = this.maps.push(e), null != t && this.setMirror(this.maps.length - 1, t) } appendMapping(e) { for (let t = 0, n = this.maps.length; t < e.maps.length; t++) { let r = e.getMirror(t); this.appendMap(e.maps[t], null != r && r < t ? n + r : void 0) } } getMirror(e) { if (this.mirror) for (let t = 0; t < this.mirror.length; t++)if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)] } setMirror(e, t) { this.mirror || (this.mirror = []), this.mirror.push(e, t) } appendMappingInverted(e) { for (let t = e.maps.length - 1, n = this.maps.length + e.maps.length; t >= 0; t--) { let r = e.getMirror(t); this.appendMap(e.maps[t].invert(), null != r && r > t ? n - r - 1 : void 0) } } invert() { let e = new rs; return e.appendMappingInverted(this), e } map(e, t = 1) { if (this.mirror) return this._map(e, t, !0); for (let n = this.from; n < this.to; n++)e = this.maps[n].map(e, t); return e } mapResult(e, t = 1) { return this._map(e, t, !1) } _map(e, t, n) { let r = 0; for (let n = this.from; n < this.to; n++) { let i = this.maps[n].mapResult(e, t); if (null != i.recover) { let t = this.getMirror(n); if (null != t && t > n && t < this.to) { n = t, e = this.maps[t].recover(i.recover); continue } } r |= i.delInfo, e = i.pos } return n ? e : new ts(e, r, null) } } const is = Object.create(null); class ss { getMap() { return ns.empty } merge(e) { return null } static fromJSON(e, t) { if (!t || !t.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let n = is[t.stepType]; if (!n) throw new RangeError(`No step type ${t.stepType} defined`); return n.fromJSON(e, t) } static jsonID(e, t) { if (e in is) throw new RangeError("Duplicate use of step JSON ID " + e); return is[e] = t, t.prototype.jsonID = e, t } } class as { constructor(e, t) { this.doc = e, this.failed = t } static ok(e) { return new as(e, null) } static fail(e) { return new as(null, e) } static fromReplace(e, t, n, r) { try { return as.ok(e.replace(t, n, r)) } catch (e) { if (e instanceof Qi) return as.fail(e.message); throw e } } } function ls(e, t, n) { let r = []; for (let i = 0; i < e.childCount; i++) { let o = e.child(i); o.content.size && (o = o.copy(ls(o.content, t, o))), o.isInline && (o = t(o, n, i)), r.push(o) } return Ui.fromArray(r) } class cs extends ss { constructor(e, t, n) { super(), this.from = e, this.to = t, this.mark = n } apply(e) { let t = e.slice(this.from, this.to), n = e.resolve(this.from), r = n.node(n.sharedDepth(this.to)), i = new eo(ls(t.content, ((e, t) => e.isAtom && t.type.allowsMarkType(this.mark.type) ? e.mark(this.mark.addToSet(e.marks)) : e), r), t.openStart, t.openEnd); return as.fromReplace(e, this.from, this.to, i) } invert() { return new us(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deleted && n.deleted || t.pos >= n.pos ? null : new cs(t.pos, n.pos, this.mark) } merge(e) { return e instanceof cs && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new cs(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to) throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new cs(t.from, t.to, e.markFromJSON(t.mark)) } } ss.jsonID("addMark", cs); class us extends ss { constructor(e, t, n) { super(), this.from = e, this.to = t, this.mark = n } apply(e) { let t = e.slice(this.from, this.to), n = new eo(ls(t.content, (e => e.mark(this.mark.removeFromSet(e.marks))), e), t.openStart, t.openEnd); return as.fromReplace(e, this.from, this.to, n) } invert() { return new cs(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deleted && n.deleted || t.pos >= n.pos ? null : new us(t.pos, n.pos, this.mark) } merge(e) { return e instanceof us && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new us(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to) throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new us(t.from, t.to, e.markFromJSON(t.mark)) } } ss.jsonID("removeMark", us); class ds extends ss { constructor(e, t, n, r = !1) { super(), this.from = e, this.to = t, this.slice = n, this.structure = r } apply(e) { return this.structure && ps(e, this.from, this.to) ? as.fail("Structure replace would overwrite content") : as.fromReplace(e, this.from, this.to, this.slice) } getMap() { return new ns([this.from, this.to - this.from, this.slice.size]) } invert(e) { return new ds(this.from, this.from + this.slice.size, e.slice(this.from, this.to)) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deletedAcross && n.deletedAcross ? null : new ds(t.pos, Math.max(t.pos, n.pos), this.slice) } merge(e) { if (!(e instanceof ds) || e.structure || this.structure) return null; if (this.from + this.slice.size != e.from || this.slice.openEnd || e.slice.openStart) { if (e.to != this.from || this.slice.openStart || e.slice.openEnd) return null; { let t = this.slice.size + e.slice.size == 0 ? eo.empty : new eo(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd); return new ds(e.from, this.to, t, this.structure) } } { let t = this.slice.size + e.slice.size == 0 ? eo.empty : new eo(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd); return new ds(this.from, this.to + (e.to - e.from), t, this.structure) } } toJSON() { let e = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to) throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new ds(t.from, t.to, eo.fromJSON(e, t.slice), !!t.structure) } } ss.jsonID("replace", ds); class hs extends ss { constructor(e, t, n, r, i, o, s = !1) { super(), this.from = e, this.to = t, this.gapFrom = n, this.gapTo = r, this.slice = i, this.insert = o, this.structure = s } apply(e) { if (this.structure && (ps(e, this.from, this.gapFrom) || ps(e, this.gapTo, this.to))) return as.fail("Structure gap-replace would overwrite content"); let t = e.slice(this.gapFrom, this.gapTo); if (t.openStart || t.openEnd) return as.fail("Gap is not a flat range"); let n = this.slice.insertAt(this.insert, t.content); return n ? as.fromReplace(e, this.from, this.to, n) : as.fail("Content does not fit in gap") } getMap() { return new ns([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(e) { let t = this.gapTo - this.gapFrom; return new hs(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1), r = e.map(this.gapFrom, -1), i = e.map(this.gapTo, 1); return t.deletedAcross && n.deletedAcross || r < t.pos || i > n.pos ? null : new hs(t.pos, n.pos, r, i, this.slice, this.insert, this.structure) } toJSON() { let e = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to || "number" != typeof t.gapFrom || "number" != typeof t.gapTo || "number" != typeof t.insert) throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new hs(t.from, t.to, t.gapFrom, t.gapTo, eo.fromJSON(e, t.slice), t.insert, !!t.structure) } } function ps(e, t, n) { let r = e.resolve(t), i = n - t, o = r.depth; for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount;)o--, i--; if (i > 0) { let e = r.node(o).maybeChild(r.indexAfter(o)); for (; i > 0;) { if (!e || e.isLeaf) return !0; e = e.firstChild, i-- } } return !1 } function fs(e, t, n) { return (0 == t || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n)) } function ms(e) { let t = e.parent.content.cutByIndex(e.startIndex, e.endIndex); for (let n = e.depth; ; --n) { let r = e.$from.node(n), i = e.$from.index(n), o = e.$to.indexAfter(n); if (n < e.depth && r.canReplace(i, o, t)) return n; if (0 == n || r.type.spec.isolating || !fs(r, i, o)) break } return null } function gs(e, t, n = null, r = e) { let i = function (e, t) { let { parent: n, startIndex: r, endIndex: i } = e, o = n.contentMatchAt(r).findWrapping(t); if (!o) return null; let s = o.length ? o[0] : t; return n.canReplaceWith(r, i, s) ? o : null }(e, t), o = i && function (e, t) { let { parent: n, startIndex: r, endIndex: i } = e, o = n.child(r), s = t.contentMatch.findWrapping(o.type); if (!s) return null; let a = (s.length ? s[s.length - 1] : t).contentMatch; for (let e = r; a && e < i; e++)a = a.matchType(n.child(e).type); return a && a.validEnd ? s : null }(r, t); return o ? i.map(ys).concat({ type: t, attrs: n }).concat(o.map(ys)) : null } function ys(e) { return { type: e, attrs: null } } function vs(e, t, n = 1, r) { let i = e.resolve(t), o = i.depth - n, s = r && r[r.length - 1] || i.parent; if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !s.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))) return !1; for (let e = i.depth - 1, t = n - 2; e > o; e--, t--) { let n = i.node(e), o = i.index(e); if (n.type.spec.isolating) return !1; let s = n.content.cutByIndex(o, n.childCount), a = r && r[t] || n; if (a != n && (s = s.replaceChild(0, a.type.create(a.attrs))), !n.canReplace(o + 1, n.childCount) || !a.type.validContent(s)) return !1 } let a = i.indexAfter(o), l = r && r[0]; return i.node(o).canReplaceWith(a, a, l ? l.type : i.node(o + 1).type) } function bs(e, t) { let n = e.resolve(t), r = n.index(); return ws(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1) } function ws(e, t) { return !(!e || !t || e.isLeaf || !e.canAppend(t)) } function Ds(e, t, n) { let r = e.resolve(t); if (!n.content.size) return t; let i = n.content; for (let e = 0; e < n.openStart; e++)i = i.firstChild.content; for (let e = 1; e <= (0 == n.openStart && n.size ? 2 : 1); e++)for (let t = r.depth; t >= 0; t--) { let n = t == r.depth ? 0 : r.pos <= (r.start(t + 1) + r.end(t + 1)) / 2 ? -1 : 1, o = r.index(t) + (n > 0 ? 1 : 0), s = r.node(t), a = !1; if (1 == e) a = s.canReplace(o, o, i); else { let e = s.contentMatchAt(o).findWrapping(i.firstChild.type); a = e && s.canReplaceWith(o, o, e[0]) } if (a) return 0 == n ? r.pos : n < 0 ? r.before(t + 1) : r.after(t + 1) } return null } function xs(e, t, n = t, r = eo.empty) { if (t == n && !r.size) return null; let i = e.resolve(t), o = e.resolve(n); return Cs(i, o, r) ? new ds(t, n, r) : new ks(i, o, r).fit() } function Cs(e, t, n) { return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content) } ss.jsonID("replaceAround", hs); class ks { constructor(e, t, n) { this.$from = e, this.$to = t, this.unplaced = n, this.frontier = [], this.placed = Ui.empty; for (let t = 0; t <= e.depth; t++) { let n = e.node(t); this.frontier.push({ type: n.type, match: n.contentMatchAt(e.indexAfter(t)) }) } for (let t = e.depth; t > 0; t--)this.placed = Ui.from(e.node(t).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let e = this.findFittable(); e ? this.placeNodes(e) : this.openMore() || this.dropNode() } let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, n = this.$from, r = this.close(e < 0 ? this.$to : n.doc.resolve(e)); if (!r) return null; let i = this.placed, o = n.depth, s = r.depth; for (; o && s && 1 == i.childCount;)i = i.firstChild.content, o--, s--; let a = new eo(i, o, s); return e > -1 ? new hs(n.pos, e, this.$to.pos, this.$to.end(), a, t) : a.size || n.pos != this.$to.pos ? new ds(n.pos, r.pos, a) : null } findFittable() { for (let e = 1; e <= 2; e++)for (let t = this.unplaced.openStart; t >= 0; t--) { let n, r = null; t ? (r = Ss(this.unplaced.content, t - 1).firstChild, n = r.content) : n = this.unplaced.content; let i = n.firstChild; for (let n = this.depth; n >= 0; n--) { let o, { type: s, match: a } = this.frontier[n], l = null; if (1 == e && (i ? a.matchType(i.type) || (l = a.fillBefore(Ui.from(i), !1)) : r && s.compatibleContent(r.type))) return { sliceDepth: t, frontierDepth: n, parent: r, inject: l }; if (2 == e && i && (o = a.findWrapping(i.type))) return { sliceDepth: t, frontierDepth: n, parent: r, wrap: o }; if (r && a.matchType(r.type)) break } } } openMore() { let { content: e, openStart: t, openEnd: n } = this.unplaced, r = Ss(e, t); return !(!r.childCount || r.firstChild.isLeaf) && (this.unplaced = new eo(e, t + 1, Math.max(n, r.size + t >= e.size - n ? t + 1 : 0)), !0) } dropNode() { let { content: e, openStart: t, openEnd: n } = this.unplaced, r = Ss(e, t); if (r.childCount <= 1 && t > 0) { let i = e.size - t <= t + r.size; this.unplaced = new eo(As(e, t - 1, 1), t - 1, i ? t - 1 : n) } else this.unplaced = new eo(As(e, t, 1), t, n) } placeNodes({ sliceDepth: e, frontierDepth: t, parent: n, inject: r, wrap: i }) { for (; this.depth > t;)this.closeFrontierNode(); if (i) for (let e = 0; e < i.length; e++)this.openFrontierNode(i[e]); let o = this.unplaced, s = n ? n.content : o.content, a = o.openStart - e, l = 0, c = [], { match: u, type: d } = this.frontier[t]; if (r) { for (let e = 0; e < r.childCount; e++)c.push(r.child(e)); u = u.matchFragment(r) } let h = s.size + e - (o.content.size - o.openEnd); for (; l < s.childCount;) { let e = s.child(l), t = u.matchType(e.type); if (!t) break; l++, (l > 1 || 0 == a || e.content.size) && (u = t, c.push(Ms(e.mark(d.allowedMarks(e.marks)), 1 == l ? a : 0, l == s.childCount ? h : -1))) } let p = l == s.childCount; p || (h = -1), this.placed = Es(this.placed, t, Ui.from(c)), this.frontier[t].match = u, p && h < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let e = 0, t = s; e < h; e++) { let e = t.lastChild; this.frontier.push({ type: e.type, match: e.contentMatchAt(e.childCount) }), t = e.content } this.unplaced = p ? 0 == e ? eo.empty : new eo(As(o.content, e - 1, 1), e - 1, h < 0 ? o.openEnd : e - 1) : new eo(As(o.content, e, l), o.openStart, o.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let e, t = this.frontier[this.depth]; if (!t.type.isTextblock || !Os(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (e = this.findCloseLevel(this.$to)) && e.depth == this.depth) return -1; let { depth: n } = this.$to, r = this.$to.after(n); for (; n > 1 && r == this.$to.end(--n);)++r; return r } findCloseLevel(e) { e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) { let { match: n, type: r } = this.frontier[t], i = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = Os(e, t, r, n, i); if (o) { for (let n = t - 1; n >= 0; n--) { let { match: t, type: r } = this.frontier[n], i = Os(e, n, r, t, !0); if (!i || i.childCount) continue e } return { depth: t, fit: o, move: i ? e.doc.resolve(e.after(t + 1)) : e } } } } close(e) { let t = this.findCloseLevel(e); if (!t) return null; for (; this.depth > t.depth;)this.closeFrontierNode(); t.fit.childCount && (this.placed = Es(this.placed, t.depth, t.fit)), e = t.move; for (let n = t.depth + 1; n <= e.depth; n++) { let t = e.node(n), r = t.type.contentMatch.fillBefore(t.content, !0, e.index(n)); this.openFrontierNode(t.type, t.attrs, r) } return e } openFrontierNode(e, t = null, n) { let r = this.frontier[this.depth]; r.match = r.match.matchType(e), this.placed = Es(this.placed, this.depth, Ui.from(e.create(t, n))), this.frontier.push({ type: e, match: e.contentMatch }) } closeFrontierNode() { let e = this.frontier.pop().match.fillBefore(Ui.empty, !0); e.childCount && (this.placed = Es(this.placed, this.frontier.length, e)) } } function As(e, t, n) { return 0 == t ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(As(e.firstChild.content, t - 1, n))) } function Es(e, t, n) { return 0 == t ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(Es(e.lastChild.content, t - 1, n))) } function Ss(e, t) { for (let n = 0; n < t; n++)e = e.firstChild.content; return e } function Ms(e, t, n) { if (t <= 0) return e; let r = e.content; return t > 1 && (r = r.replaceChild(0, Ms(r.firstChild, t - 1, 1 == r.childCount ? n - 1 : 0))), t > 0 && (r = e.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(e.type.contentMatch.matchFragment(r).fillBefore(Ui.empty, !0)))), e.copy(r) } function Os(e, t, n, r, i) { let o = e.node(t), s = i ? e.indexAfter(t) : e.index(t); if (s == o.childCount && !n.compatibleContent(o.type)) return null; let a = r.fillBefore(o.content, !0, s); return a && !function (e, t, n) { for (let r = n; r < t.childCount; r++)if (!e.allowsMarks(t.child(r).marks)) return !0; return !1 }(n, o.content, s) ? a : null } function Ts(e) { return e.spec.defining || e.spec.definingForContent } function Fs(e, t, n, r, i) { if (t < n) { let i = e.firstChild; e = e.replaceChild(0, i.copy(Fs(i.content, t + 1, n, r, i))) } if (t > r) { let t = i.contentMatchAt(0), n = t.fillBefore(e).append(e); e = n.append(t.matchFragment(n).fillBefore(Ui.empty, !0)) } return e } function Ns(e, t) { let n = []; for (let r = Math.min(e.depth, t.depth); r >= 0; r--) { let i = e.start(r); if (i < e.pos - (e.depth - r) || t.end(r) > t.pos + (t.depth - r) || e.node(r).type.spec.isolating || t.node(r).type.spec.isolating) break; (i == t.start(r) || r == e.depth && r == t.depth && e.parent.inlineContent && t.parent.inlineContent && r && t.start(r - 1) == i - 1) && n.push(r) } return n } let Bs = class extends Error { }; Bs = function e(t) { let n = Error.call(this, t); return n.__proto__ = e.prototype, n }, (Bs.prototype = Object.create(Error.prototype)).constructor = Bs, Bs.prototype.name = "TransformError"; class _s { constructor(e) { this.doc = e, this.steps = [], this.docs = [], this.mapping = new rs } get before() { return this.docs.length ? this.docs[0] : this.doc } step(e) { let t = this.maybeStep(e); if (t.failed) throw new Bs(t.failed); return this } maybeStep(e) { let t = e.apply(this.doc); return t.failed || this.addStep(e, t.doc), t } get docChanged() { return this.steps.length > 0 } addStep(e, t) { this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t } replace(e, t = e, n = eo.empty) { let r = xs(this.doc, e, t, n); return r && this.step(r), this } replaceWith(e, t, n) { return this.replace(e, t, new eo(Ui.from(n), 0, 0)) } delete(e, t) { return this.replace(e, t, eo.empty) } insert(e, t) { return this.replaceWith(e, e, t) } replaceRange(e, t, n) { return function (e, t, n, r) { if (!r.size) return e.deleteRange(t, n); let i = e.doc.resolve(t), o = e.doc.resolve(n); if (Cs(i, o, r)) return e.step(new ds(t, n, r)); let s = Ns(i, e.doc.resolve(n)); 0 == s[s.length - 1] && s.pop(); let a = -(i.depth + 1); s.unshift(a); for (let e = i.depth, t = i.pos - 1; e > 0; e--, t--) { let n = i.node(e).type.spec; if (n.defining || n.definingAsContext || n.isolating) break; s.indexOf(e) > -1 ? a = e : i.before(e) == t && s.splice(1, 0, -e) } let l = s.indexOf(a), c = [], u = r.openStart; for (let e = r.content, t = 0; ; t++) { let n = e.firstChild; if (c.push(n), t == r.openStart) break; e = n.content } for (let e = u - 1; e >= 0; e--) { let t = c[e].type, n = Ts(t); if (n && i.node(l).type != t) u = e; else if (n || !t.isTextblock) break } for (let t = r.openStart; t >= 0; t--) { let a = (t + u + 1) % (r.openStart + 1), d = c[a]; if (d) for (let t = 0; t < s.length; t++) { let c = s[(t + l) % s.length], u = !0; c < 0 && (u = !1, c = -c); let h = i.node(c - 1), p = i.index(c - 1); if (h.canReplaceWith(p, p, d.type, d.marks)) return e.replace(i.before(c), u ? o.after(c) : n, new eo(Fs(r.content, 0, r.openStart, a), a, r.openEnd)) } } let d = e.steps.length; for (let a = s.length - 1; a >= 0 && (e.replace(t, n, r), !(e.steps.length > d)); a--) { let e = s[a]; e < 0 || (t = i.before(e), n = o.after(e)) } }(this, e, t, n), this } replaceRangeWith(e, t, n) { return function (e, t, n, r) { if (!r.isInline && t == n && e.doc.resolve(t).parent.content.size) { let i = function (e, t, n) { let r = e.resolve(t); if (r.parent.canReplaceWith(r.index(), r.index(), n)) return t; if (0 == r.parentOffset) for (let e = r.depth - 1; e >= 0; e--) { let t = r.index(e); if (r.node(e).canReplaceWith(t, t, n)) return r.before(e + 1); if (t > 0) return null } if (r.parentOffset == r.parent.content.size) for (let e = r.depth - 1; e >= 0; e--) { let t = r.indexAfter(e); if (r.node(e).canReplaceWith(t, t, n)) return r.after(e + 1); if (t < r.node(e).childCount) return null } return null }(e.doc, t, r.type); null != i && (t = n = i) } e.replaceRange(t, n, new eo(Ui.from(r), 0, 0)) }(this, e, t, n), this } deleteRange(e, t) { return function (e, t, n) { let r = e.doc.resolve(t), i = e.doc.resolve(n), o = Ns(r, i); for (let t = 0; t < o.length; t++) { let n = o[t], s = t == o.length - 1; if (s && 0 == n || r.node(n).type.contentMatch.validEnd) return e.delete(r.start(n), i.end(n)); if (n > 0 && (s || r.node(n - 1).canReplace(r.index(n - 1), i.indexAfter(n - 1)))) return e.delete(r.before(n), i.after(n)) } for (let o = 1; o <= r.depth && o <= i.depth; o++)if (t - r.start(o) == r.depth - o && n > r.end(o) && i.end(o) - n != i.depth - o) return e.delete(r.before(o), n); e.delete(t, n) }(this, e, t), this } lift(e, t) { return function (e, t, n) { let { $from: r, $to: i, depth: o } = t, s = r.before(o + 1), a = i.after(o + 1), l = s, c = a, u = Ui.empty, d = 0; for (let e = o, t = !1; e > n; e--)t || r.index(e) > 0 ? (t = !0, u = Ui.from(r.node(e).copy(u)), d++) : l--; let h = Ui.empty, p = 0; for (let e = o, t = !1; e > n; e--)t || i.after(e + 1) < i.end(e) ? (t = !0, h = Ui.from(i.node(e).copy(h)), p++) : c++; e.step(new hs(l, c, s, a, new eo(u.append(h), d, p), u.size - d, !0)) }(this, e, t), this } join(e, t = 1) { return function (e, t, n) { let r = new ds(t - n, t + n, eo.empty, !0); e.step(r) }(this, e, t), this } wrap(e, t) { return function (e, t, n) { let r = Ui.empty; for (let e = n.length - 1; e >= 0; e--) { if (r.size) { let t = n[e].type.contentMatch.matchFragment(r); if (!t || !t.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } r = Ui.from(n[e].type.create(n[e].attrs, r)) } let i = t.start, o = t.end; e.step(new hs(i, o, i, o, new eo(r, 0, 0), n.length, !0)) }(this, e, t), this } setBlockType(e, t = e, n, r = null) { return function (e, t, n, r, i) { if (!r.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let o = e.steps.length; e.doc.nodesBetween(t, n, ((t, n) => { if (t.isTextblock && !t.hasMarkup(r, i) && function (e, t, n) { let r = e.resolve(t), i = r.index(); return r.parent.canReplaceWith(i, i + 1, n) }(e.doc, e.mapping.slice(o).map(n), r)) { e.clearIncompatible(e.mapping.slice(o).map(n, 1), r); let s = e.mapping.slice(o), a = s.map(n, 1), l = s.map(n + t.nodeSize, 1); return e.step(new hs(a, l, a + 1, l - 1, new eo(Ui.from(r.create(i, null, t.marks)), 0, 0), 1, !0)), !1 } })) }(this, e, t, n, r), this } setNodeMarkup(e, t, n = null, r = []) { return function (e, t, n, r, i) { let o = e.doc.nodeAt(t); if (!o) throw new RangeError("No node at given position"); n || (n = o.type); let s = n.create(r, null, i || o.marks); if (o.isLeaf) return e.replaceWith(t, t + o.nodeSize, s); if (!n.validContent(o.content)) throw new RangeError("Invalid content for node type " + n.name); e.step(new hs(t, t + o.nodeSize, t + 1, t + o.nodeSize - 1, new eo(Ui.from(s), 0, 0), 1, !0)) }(this, e, t, n, r), this } split(e, t = 1, n) { return function (e, t, n = 1, r) { let i = e.doc.resolve(t), o = Ui.empty, s = Ui.empty; for (let e = i.depth, t = i.depth - n, a = n - 1; e > t; e--, a--) { o = Ui.from(i.node(e).copy(o)); let t = r && r[a]; s = Ui.from(t ? t.type.create(t.attrs, s) : i.node(e).copy(s)) } e.step(new ds(t, t, new eo(o.append(s), n, n), !0)) }(this, e, t, n), this } addMark(e, t, n) { return function (e, t, n, r) { let i, o, s = [], a = []; e.doc.nodesBetween(t, n, ((e, l, c) => { if (!e.isInline) return; let u = e.marks; if (!r.isInSet(u) && c.type.allowsMarkType(r.type)) { let c = Math.max(l, t), d = Math.min(l + e.nodeSize, n), h = r.addToSet(u); for (let e = 0; e < u.length; e++)u[e].isInSet(h) || (i && i.to == c && i.mark.eq(u[e]) ? i.to = d : s.push(i = new us(c, d, u[e]))); o && o.to == c ? o.to = d : a.push(o = new cs(c, d, r)) } })), s.forEach((t => e.step(t))), a.forEach((t => e.step(t))) }(this, e, t, n), this } removeMark(e, t, n) { return function (e, t, n, r) { let i = [], o = 0; e.doc.nodesBetween(t, n, ((e, s) => { if (!e.isInline) return; o++; let a = null; if (r instanceof Lo) { let t, n = e.marks; for (; t = r.isInSet(n);)(a || (a = [])).push(t), n = t.removeFromSet(n) } else r ? r.isInSet(e.marks) && (a = [r]) : a = e.marks; if (a && a.length) { let r = Math.min(s + e.nodeSize, n); for (let e = 0; e < a.length; e++) { let n, l = a[e]; for (let e = 0; e < i.length; e++) { let t = i[e]; t.step == o - 1 && l.eq(i[e].style) && (n = t) } n ? (n.to = r, n.step = o) : i.push({ style: l, from: Math.max(s, t), to: r, step: o }) } } })), i.forEach((t => e.step(new us(t.from, t.to, t.style)))) }(this, e, t, n), this } clearIncompatible(e, t, n) { return function (e, t, n, r = n.contentMatch) { let i = e.doc.nodeAt(t), o = [], s = t + 1; for (let t = 0; t < i.childCount; t++) { let a = i.child(t), l = s + a.nodeSize, c = r.matchType(a.type); if (c) { r = c; for (let t = 0; t < a.marks.length; t++)n.allowsMarkType(a.marks[t].type) || e.step(new us(s, l, a.marks[t])) } else o.push(new ds(s, l, eo.empty)); s = l } if (!r.validEnd) { let t = r.fillBefore(Ui.empty, !0); e.replace(s, s, new eo(t, 0, 0)) } for (let t = o.length - 1; t >= 0; t--)e.step(o[t]) }(this, e, t, n), this } } const Rs = Object.create(null); class Ls { constructor(e, t, n) { this.$anchor = e, this.$head = t, this.ranges = n || [new Ps(e.min(t), e.max(t))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let e = this.ranges; for (let t = 0; t < e.length; t++)if (e[t].$from.pos != e[t].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(e, t = eo.empty) { let n = t.content.lastChild, r = null; for (let e = 0; e < t.openEnd; e++)r = n, n = n.lastChild; let i = e.steps.length, o = this.ranges; for (let s = 0; s < o.length; s++) { let { $from: a, $to: l } = o[s], c = e.mapping.slice(i); e.replaceRange(c.map(a.pos), c.map(l.pos), s ? eo.empty : t), 0 == s && Js(e, i, (n ? n.isInline : r && r.isTextblock) ? -1 : 1) } } replaceWith(e, t) { let n = e.steps.length, r = this.ranges; for (let i = 0; i < r.length; i++) { let { $from: o, $to: s } = r[i], a = e.mapping.slice(n), l = a.map(o.pos), c = a.map(s.pos); i ? e.deleteRange(l, c) : (e.replaceRangeWith(l, c, t), Js(e, n, t.isInline ? -1 : 1)) } } static findFrom(e, t, n = !1) { let r = e.parent.inlineContent ? new zs(e) : Ks(e.node(0), e.parent, e.pos, e.index(), t, n); if (r) return r; for (let r = e.depth - 1; r >= 0; r--) { let i = t < 0 ? Ks(e.node(0), e.node(r), e.before(r + 1), e.index(r), t, n) : Ks(e.node(0), e.node(r), e.after(r + 1), e.index(r) + 1, t, n); if (i) return i } return null } static near(e, t = 1) { return this.findFrom(e, t) || this.findFrom(e, -t) || new Ws(e.node(0)) } static atStart(e) { return Ks(e, e, 0, 0, 1) || new Ws(e) } static atEnd(e) { return Ks(e, e, e.content.size, e.childCount, -1) || new Ws(e) } static fromJSON(e, t) { if (!t || !t.type) throw new RangeError("Invalid input for Selection.fromJSON"); let n = Rs[t.type]; if (!n) throw new RangeError(`No selection type ${t.type} defined`); return n.fromJSON(e, t) } static jsonID(e, t) { if (e in Rs) throw new RangeError("Duplicate use of selection JSON ID " + e); return Rs[e] = t, t.prototype.jsonID = e, t } getBookmark() { return zs.between(this.$anchor, this.$head).getBookmark() } } Ls.prototype.visible = !0; class Ps { constructor(e, t) { this.$from = e, this.$to = t } } let Is = !1; function $s(e) { Is || e.parent.inlineContent || (Is = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")")) } class zs extends Ls { constructor(e, t = e) { $s(e), $s(t), super(e, t) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(e, t) { let n = e.resolve(t.map(this.head)); if (!n.parent.inlineContent) return Ls.near(n); let r = e.resolve(t.map(this.anchor)); return new zs(r.parent.inlineContent ? r : n, n) } replace(e, t = eo.empty) { if (super.replace(e, t), t == eo.empty) { let t = this.$from.marksAcross(this.$to); t && e.ensureMarks(t) } } eq(e) { return e instanceof zs && e.anchor == this.anchor && e.head == this.head } getBookmark() { return new js(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(e, t) { if ("number" != typeof t.anchor || "number" != typeof t.head) throw new RangeError("Invalid input for TextSelection.fromJSON"); return new zs(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, n = t) { let r = e.resolve(t); return new this(r, n == t ? r : e.resolve(n)) } static between(e, t, n) { let r = e.pos - t.pos; if (n && !r || (n = r >= 0 ? 1 : -1), !t.parent.inlineContent) { let e = Ls.findFrom(t, n, !0) || Ls.findFrom(t, -n, !0); if (!e) return Ls.near(t, n); t = e.$head } return e.parent.inlineContent || (0 == r || (e = (Ls.findFrom(e, -n, !0) || Ls.findFrom(e, n, !0)).$anchor).pos < t.pos != r < 0) && (e = t), new zs(e, t) } } Ls.jsonID("text", zs); class js { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new js(e.map(this.anchor), e.map(this.head)) } resolve(e) { return zs.between(e.resolve(this.anchor), e.resolve(this.head)) } } class Hs extends Ls { constructor(e) { let t = e.nodeAfter, n = e.node(0).resolve(e.pos + t.nodeSize); super(e, n), this.node = t } map(e, t) { let { deleted: n, pos: r } = t.mapResult(this.anchor), i = e.resolve(r); return n ? Ls.near(i) : new Hs(i) } content() { return new eo(Ui.from(this.node), 0, 0) } eq(e) { return e instanceof Hs && e.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new Vs(this.anchor) } static fromJSON(e, t) { if ("number" != typeof t.anchor) throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new Hs(e.resolve(t.anchor)) } static create(e, t) { return new Hs(e.resolve(t)) } static isSelectable(e) { return !e.isText && !1 !== e.type.spec.selectable } } Hs.prototype.visible = !1, Ls.jsonID("node", Hs); class Vs { constructor(e) { this.anchor = e } map(e) { let { deleted: t, pos: n } = e.mapResult(this.anchor); return t ? new js(n, n) : new Vs(n) } resolve(e) { let t = e.resolve(this.anchor), n = t.nodeAfter; return n && Hs.isSelectable(n) ? new Hs(t) : Ls.near(t) } } class Ws extends Ls { constructor(e) { super(e.resolve(0), e.resolve(e.content.size)) } replace(e, t = eo.empty) { if (t == eo.empty) { e.delete(0, e.doc.content.size); let t = Ls.atStart(e.doc); t.eq(e.selection) || e.setSelection(t) } else super.replace(e, t) } toJSON() { return { type: "all" } } static fromJSON(e) { return new Ws(e) } map(e) { return new Ws(e) } eq(e) { return e instanceof Ws } getBookmark() { return qs } } Ls.jsonID("all", Ws); const qs = { map() { return this }, resolve: e => new Ws(e) }; function Ks(e, t, n, r, i, o = !1) { if (t.inlineContent) return zs.create(e, n); for (let s = r - (i > 0 ? 0 : 1); i > 0 ? s < t.childCount : s >= 0; s += i) { let r = t.child(s); if (r.isAtom) { if (!o && Hs.isSelectable(r)) return Hs.create(e, n - (i < 0 ? r.nodeSize : 0)) } else { let t = Ks(e, r, n + i, i < 0 ? r.childCount : 0, i, o); if (t) return t } n += r.nodeSize * i } return null } function Js(e, t, n) { let r = e.steps.length - 1; if (r < t) return; let i, o = e.steps[r]; (o instanceof ds || o instanceof hs) && (e.mapping.maps[r].forEach(((e, t, n, r) => { null == i && (i = r) })), e.setSelection(Ls.near(e.doc.resolve(i), n))) } class Us extends _s { constructor(e) { super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(e) { if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = -3 & (1 | this.updated), this.storedMarks = null, this } get selectionSet() { return (1 & this.updated) > 0 } setStoredMarks(e) { return this.storedMarks = e, this.updated |= 2, this } ensureMarks(e) { return Zi.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this } addStoredMark(e) { return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(e) { return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (2 & this.updated) > 0 } addStep(e, t) { super.addStep(e, t), this.updated = -3 & this.updated, this.storedMarks = null } setTime(e) { return this.time = e, this } replaceSelection(e) { return this.selection.replace(this, e), this } replaceSelectionWith(e, t = !0) { let n = this.selection; return t && (e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || Zi.none))), n.replaceWith(this, e), this } deleteSelection() { return this.selection.replace(this), this } insertText(e, t, n) { let r = this.doc.type.schema; if (null == t) return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection(); { if (null == n && (n = t), n = null == n ? t : n, !e) return this.deleteRange(t, n); let i = this.storedMarks; if (!i) { let e = this.doc.resolve(t); i = n == t ? e.marks() : e.marksAcross(this.doc.resolve(n)) } return this.replaceRangeWith(t, n, r.text(e, i)), this.selection.empty || this.setSelection(Ls.near(this.selection.$to)), this } } setMeta(e, t) { return this.meta["string" == typeof e ? e : e.key] = t, this } getMeta(e) { return this.meta["string" == typeof e ? e : e.key] } get isGeneric() { for (let e in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= 4, this } get scrolledIntoView() { return (4 & this.updated) > 0 } } function Gs(e, t) { return t && e ? e.bind(t) : e } class Xs { constructor(e, t, n) { this.name = e, this.init = Gs(t.init, n), this.apply = Gs(t.apply, n) } } const Ys = [new Xs("doc", { init: e => e.doc || e.schema.topNodeType.createAndFill(), apply: e => e.doc }), new Xs("selection", { init: (e, t) => e.selection || Ls.atStart(t.doc), apply: e => e.selection }), new Xs("storedMarks", { init: e => e.storedMarks || null, apply: (e, t, n, r) => r.selection.$cursor ? e.storedMarks : null }), new Xs("scrollToSelection", { init: () => 0, apply: (e, t) => e.scrolledIntoView ? t + 1 : t })]; class Zs { constructor(e, t) { this.schema = e, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = Ys.slice(), t && t.forEach((e => { if (this.pluginsByKey[e.key]) throw new RangeError("Adding different instances of a keyed plugin (" + e.key + ")"); this.plugins.push(e), this.pluginsByKey[e.key] = e, e.spec.state && this.fields.push(new Xs(e.key, e.spec.state, e)) })) } } class Qs { constructor(e) { this.config = e } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(e) { return this.applyTransaction(e).state } filterTransaction(e, t = -1) { for (let n = 0; n < this.config.plugins.length; n++)if (n != t) { let t = this.config.plugins[n]; if (t.spec.filterTransaction && !t.spec.filterTransaction.call(t, e, this)) return !1 } return !0 } applyTransaction(e) { if (!this.filterTransaction(e)) return { state: this, transactions: [] }; let t = [e], n = this.applyInner(e), r = null; for (; ;) { let i = !1; for (let o = 0; o < this.config.plugins.length; o++) { let s = this.config.plugins[o]; if (s.spec.appendTransaction) { let a = r ? r[o].n : 0, l = r ? r[o].state : this, c = a < t.length && s.spec.appendTransaction.call(s, a ? t.slice(a) : t, l, n); if (c && n.filterTransaction(c, o)) { if (c.setMeta("appendedTransaction", e), !r) { r = []; for (let e = 0; e < this.config.plugins.length; e++)r.push(e < o ? { state: n, n: t.length } : { state: this, n: 0 }) } t.push(c), n = n.applyInner(c), i = !0 } r && (r[o] = { state: n, n: t.length }) } } if (!i) return { state: n, transactions: t } } } applyInner(e) { if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let t = new Qs(this.config), n = this.config.fields; for (let r = 0; r < n.length; r++) { let i = n[r]; t[i.name] = i.apply(e, this[i.name], this, t) } return t } get tr() { return new Us(this) } static create(e) { let t = new Zs(e.doc ? e.doc.type.schema : e.schema, e.plugins), n = new Qs(t); for (let r = 0; r < t.fields.length; r++)n[t.fields[r].name] = t.fields[r].init(e, n); return n } reconfigure(e) { let t = new Zs(this.schema, e.plugins), n = t.fields, r = new Qs(t); for (let t = 0; t < n.length; t++) { let i = n[t].name; r[i] = this.hasOwnProperty(i) ? this[i] : n[t].init(e, r) } return r } toJSON(e) { let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (t.storedMarks = this.storedMarks.map((e => e.toJSON()))), e && "object" == typeof e) for (let n in e) { if ("doc" == n || "selection" == n) throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let r = e[n], i = r.spec.state; i && i.toJSON && (t[n] = i.toJSON.call(r, this[r.key])) } return t } static fromJSON(e, t, n) { if (!t) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!e.schema) throw new RangeError("Required config field 'schema' missing"); let r = new Zs(e.schema, e.plugins), i = new Qs(r); return r.fields.forEach((r => { if ("doc" == r.name) i.doc = bo.fromJSON(e.schema, t.doc); else if ("selection" == r.name) i.selection = Ls.fromJSON(i.doc, t.selection); else if ("storedMarks" == r.name) t.storedMarks && (i.storedMarks = t.storedMarks.map(e.schema.markFromJSON)); else { if (n) for (let o in n) { let s = n[o], a = s.spec.state; if (s.key == r.name && a && a.fromJSON && Object.prototype.hasOwnProperty.call(t, o)) return void (i[r.name] = a.fromJSON.call(s, e, t[o], i)) } i[r.name] = r.init(e, i) } })), i } } function ea(e, t, n) { for (let r in e) { let i = e[r]; i instanceof Function ? i = i.bind(t) : "handleDOMEvents" == r && (i = ea(i, t, {})), n[r] = i } return n } class ta { constructor(e) { this.spec = e, this.props = {}, e.props && ea(e.props, this, this.props), this.key = e.key ? e.key.key : ra("plugin") } getState(e) { return e[this.key] } } const na = Object.create(null); function ra(e) { return e in na ? e + "$" + ++na[e] : (na[e] = 0, e + "$") } class ia { constructor(e = "key") { this.key = ra(e) } get(e) { return e.config.pluginsByKey[this.key] } getState(e) { return e[this.key] } } const oa = "undefined" != typeof navigator ? navigator : null, sa = "undefined" != typeof document ? document : null, aa = oa && oa.userAgent || "", la = /Edge\/(\d+)/.exec(aa), ca = /MSIE \d/.exec(aa), ua = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(aa), da = !!(ca || ua || la), ha = ca ? document.documentMode : ua ? +ua[1] : la ? +la[1] : 0, pa = !da && /gecko\/(\d+)/i.test(aa); pa && (/Firefox\/(\d+)/.exec(aa) || [0, 0])[1]; const fa = !da && /Chrome\/(\d+)/.exec(aa), ma = !!fa, ga = fa ? +fa[1] : 0, ya = !da && !!oa && /Apple Computer/.test(oa.vendor), va = ya && (/Mobile\/\w+/.test(aa) || !!oa && oa.maxTouchPoints > 2), ba = va || !!oa && /Mac/.test(oa.platform), wa = /Android \d/.test(aa), Da = !!sa && "webkitFontSmoothing" in sa.documentElement.style, xa = Da ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0, Ca = function (e) { for (var t = 0; ; t++)if (!(e = e.previousSibling)) return t }, ka = function (e) { let t = e.assignedSlot || e.parentNode; return t && 11 == t.nodeType ? t.host : t }; let Aa = null; const Ea = function (e, t, n) { let r = Aa || (Aa = document.createRange()); return r.setEnd(e, null == n ? e.nodeValue.length : n), r.setStart(e, t || 0), r }, Sa = function (e, t, n, r) { return n && (Oa(e, t, n, r, -1) || Oa(e, t, n, r, 1)) }, Ma = /^(img|br|input|textarea|hr)$/i; function Oa(e, t, n, r, i) { for (; ;) { if (e == n && t == r) return !0; if (t == (i < 0 ? 0 : Ta(e))) { let n = e.parentNode; if (!n || 1 != n.nodeType || Fa(e) || Ma.test(e.nodeName) || "false" == e.contentEditable) return !1; t = Ca(e) + (i < 0 ? 0 : 1), e = n } else { if (1 != e.nodeType) return !1; if ("false" == (e = e.childNodes[t + (i < 0 ? -1 : 0)]).contentEditable) return !1; t = i < 0 ? Ta(e) : 0 } } } function Ta(e) { return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length } function Fa(e) { let t; for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode); return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e) } const Na = function (e) { let t = e.isCollapsed; return t && ma && e.rangeCount && !e.getRangeAt(0).collapsed && (t = !1), t }; function Ba(e, t) { let n = document.createEvent("Event"); return n.initEvent("keydown", !0, !0), n.keyCode = e, n.key = n.code = t, n } function _a(e) { return { left: 0, right: e.documentElement.clientWidth, top: 0, bottom: e.documentElement.clientHeight } } function Ra(e, t) { return "number" == typeof e ? e : e[t] } function La(e) { let t = e.getBoundingClientRect(), n = t.width / e.offsetWidth || 1, r = t.height / e.offsetHeight || 1; return { left: t.left, right: t.left + e.clientWidth * n, top: t.top, bottom: t.top + e.clientHeight * r } } function Pa(e, t, n) { let r = e.someProp("scrollThreshold") || 0, i = e.someProp("scrollMargin") || 5, o = e.dom.ownerDocument; for (let s = n || e.dom; s; s = ka(s)) { if (1 != s.nodeType) continue; let e = s, n = e == o.body, a = n ? _a(o) : La(e), l = 0, c = 0; if (t.top < a.top + Ra(r, "top") ? c = -(a.top - t.top + Ra(i, "top")) : t.bottom > a.bottom - Ra(r, "bottom") && (c = t.bottom - a.bottom + Ra(i, "bottom")), t.left < a.left + Ra(r, "left") ? l = -(a.left - t.left + Ra(i, "left")) : t.right > a.right - Ra(r, "right") && (l = t.right - a.right + Ra(i, "right")), l || c) if (n) o.defaultView.scrollBy(l, c); else { let n = e.scrollLeft, r = e.scrollTop; c && (e.scrollTop += c), l && (e.scrollLeft += l); let i = e.scrollLeft - n, o = e.scrollTop - r; t = { left: t.left - i, top: t.top - o, right: t.right - i, bottom: t.bottom - o } } if (n) break } } function Ia(e) { let t = [], n = e.ownerDocument; for (let r = e; r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n); r = ka(r)); return t } function $a(e, t) { for (let n = 0; n < e.length; n++) { let { dom: r, top: i, left: o } = e[n]; r.scrollTop != i + t && (r.scrollTop = i + t), r.scrollLeft != o && (r.scrollLeft = o) } } let za = null; function ja(e, t) { let n, r, i = 2e8, o = 0, s = t.top, a = t.top; for (let l = e.firstChild, c = 0; l; l = l.nextSibling, c++) { let e; if (1 == l.nodeType) e = l.getClientRects(); else { if (3 != l.nodeType) continue; e = Ea(l).getClientRects() } for (let u = 0; u < e.length; u++) { let d = e[u]; if (d.top <= s && d.bottom >= a) { s = Math.max(d.bottom, s), a = Math.min(d.top, a); let e = d.left > t.left ? d.left - t.left : d.right < t.left ? t.left - d.right : 0; if (e < i) { n = l, i = e, r = e && 3 == n.nodeType ? { left: d.right < t.left ? d.right : d.left, top: t.top } : t, 1 == l.nodeType && e && (o = c + (t.left >= (d.left + d.right) / 2 ? 1 : 0)); continue } } !n && (t.left >= d.right && t.top >= d.top || t.left >= d.left && t.top >= d.bottom) && (o = c + 1) } } return n && 3 == n.nodeType ? function (e, t) { let n = e.nodeValue.length, r = document.createRange(); for (let i = 0; i < n; i++) { r.setEnd(e, i + 1), r.setStart(e, i); let n = qa(r, 1); if (n.top != n.bottom && Ha(t, n)) return { node: e, offset: i + (t.left >= (n.left + n.right) / 2 ? 1 : 0) } } return { node: e, offset: 0 } }(n, r) : !n || i && 1 == n.nodeType ? { node: e, offset: o } : ja(n, r) } function Ha(e, t) { return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1 } function Va(e, t, n) { let r = e.childNodes.length; if (r && n.top < n.bottom) for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), o = i; ;) { let n = e.childNodes[o]; if (1 == n.nodeType) { let e = n.getClientRects(); for (let r = 0; r < e.length; r++) { let i = e[r]; if (Ha(t, i)) return Va(n, t, i) } } if ((o = (o + 1) % r) == i) break } return e } function Wa(e, t) { let n, r = e.dom.ownerDocument, i = 0; if (r.caretPositionFromPoint) try { let e = r.caretPositionFromPoint(t.left, t.top); e && ({ offsetNode: n, offset: i } = e) } catch (e) { } if (!n && r.caretRangeFromPoint) { let e = r.caretRangeFromPoint(t.left, t.top); e && ({ startContainer: n, startOffset: i } = e) } let o, s = (e.root.elementFromPoint ? e.root : r).elementFromPoint(t.left, t.top + 1); if (!s || !e.dom.contains(1 != s.nodeType ? s.parentNode : s)) { let n = e.dom.getBoundingClientRect(); if (!Ha(t, n)) return null; if (s = Va(e.dom, t, n), !s) return null } if (ya) for (let e = s; n && e; e = ka(e))e.draggable && (n = void 0); if (s = function (e, t) { let n = e.parentNode; return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e }(s, t), n) { if (pa && 1 == n.nodeType && (i = Math.min(i, n.childNodes.length), i < n.childNodes.length)) { let e, r = n.childNodes[i]; "IMG" == r.nodeName && (e = r.getBoundingClientRect()).right <= t.left && e.bottom > t.top && i++ } n == e.dom && i == n.childNodes.length - 1 && 1 == n.lastChild.nodeType && t.top > n.lastChild.getBoundingClientRect().bottom ? o = e.state.doc.content.size : 0 != i && 1 == n.nodeType && "BR" == n.childNodes[i - 1].nodeName || (o = function (e, t, n, r) { let i = -1; for (let n = t; n != e.dom;) { let t = e.docView.nearestDesc(n, !0); if (!t) return null; if (t.node.isBlock && t.parent) { let e = t.dom.getBoundingClientRect(); if (e.left > r.left || e.top > r.top) i = t.posBefore; else { if (!(e.right < r.left || e.bottom < r.top)) break; i = t.posAfter } } n = t.dom.parentNode } return i > -1 ? i : e.docView.posFromDOM(t, n, 1) }(e, n, i, t)) } null == o && (o = function (e, t, n) { let { node: r, offset: i } = ja(t, n), o = -1; if (1 == r.nodeType && !r.firstChild) { let e = r.getBoundingClientRect(); o = e.left != e.right && n.left > (e.left + e.right) / 2 ? 1 : -1 } return e.docView.posFromDOM(r, i, o) }(e, s, t)); let a = e.docView.nearestDesc(s, !0); return { pos: o, inside: a ? a.posAtStart - a.border : -1 } } function qa(e, t) { let n = e.getClientRects(); return n.length ? n[t < 0 ? 0 : n.length - 1] : e.getBoundingClientRect() } const Ka = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function Ja(e, t, n) { let { node: r, offset: i } = e.docView.domFromPos(t, n < 0 ? -1 : 1), o = Da || pa; if (3 == r.nodeType) { if (!o || !Ka.test(r.nodeValue) && (n < 0 ? i : i != r.nodeValue.length)) { let e = i, t = i, o = n < 0 ? 1 : -1; return n < 0 && !i ? (t++, o = -1) : n >= 0 && i == r.nodeValue.length ? (e--, o = 1) : n < 0 ? e-- : t++, Ua(qa(Ea(r, e, t), o), o < 0) } { let e = qa(Ea(r, i, i), n); if (pa && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) { let t = qa(Ea(r, i - 1, i - 1), -1); if (t.top == e.top) { let n = qa(Ea(r, i, i + 1), -1); if (n.top != e.top) return Ua(n, n.left < t.left) } } return e } } if (!e.state.doc.resolve(t).parent.inlineContent) { if (i && (n < 0 || i == Ta(r))) { let e = r.childNodes[i - 1]; if (1 == e.nodeType) return Ga(e.getBoundingClientRect(), !1) } if (i < Ta(r)) { let e = r.childNodes[i]; if (1 == e.nodeType) return Ga(e.getBoundingClientRect(), !0) } return Ga(r.getBoundingClientRect(), n >= 0) } if (i && (n < 0 || i == Ta(r))) { let e = r.childNodes[i - 1], t = 3 == e.nodeType ? Ea(e, Ta(e) - (o ? 0 : 1)) : 1 != e.nodeType || "BR" == e.nodeName && e.nextSibling ? null : e; if (t) return Ua(qa(t, 1), !1) } if (i < Ta(r)) { let e = r.childNodes[i]; for (; e.pmViewDesc && e.pmViewDesc.ignoreForCoords;)e = e.nextSibling; let t = e ? 3 == e.nodeType ? Ea(e, 0, o ? 0 : 1) : 1 == e.nodeType ? e : null : null; if (t) return Ua(qa(t, -1), !0) } return Ua(qa(3 == r.nodeType ? Ea(r) : r, -n), n >= 0) } function Ua(e, t) { if (0 == e.width) return e; let n = t ? e.left : e.right; return { top: e.top, bottom: e.bottom, left: n, right: n } } function Ga(e, t) { if (0 == e.height) return e; let n = t ? e.top : e.bottom; return { top: n, bottom: n, left: e.left, right: e.right } } function Xa(e, t, n) { let r = e.state, i = e.root.activeElement; r != t && e.updateState(t), i != e.dom && e.focus(); try { return n() } finally { r != t && e.updateState(r), i != e.dom && i && i.focus() } } const Ya = /[\u0590-\u08ac]/; let Za = null, Qa = null, el = !1; function tl(e, t, n) { return Za == t && Qa == n ? el : (Za = t, Qa = n, el = "up" == n || "down" == n ? function (e, t, n) { let r = t.selection, i = "up" == n ? r.$from : r.$to; return Xa(e, t, (() => { let { node: t } = e.docView.domFromPos(i.pos, "up" == n ? -1 : 1); for (; ;) { let n = e.docView.nearestDesc(t, !0); if (!n) break; if (n.node.isBlock) { t = n.dom; break } t = n.dom.parentNode } let r = Ja(e, i.pos, 1); for (let e = t.firstChild; e; e = e.nextSibling) { let t; if (1 == e.nodeType) t = e.getClientRects(); else { if (3 != e.nodeType) continue; t = Ea(e, 0, e.nodeValue.length).getClientRects() } for (let e = 0; e < t.length; e++) { let i = t[e]; if (i.bottom > i.top + 1 && ("up" == n ? r.top - i.top > 2 * (i.bottom - r.top) : i.bottom - r.bottom > 2 * (r.bottom - i.top))) return !1 } } return !0 })) }(e, t, n) : function (e, t, n) { let { $head: r } = t.selection; if (!r.parent.isTextblock) return !1; let i = r.parentOffset, o = !i, s = i == r.parent.content.size, a = e.domSelection(); return Ya.test(r.parent.textContent) && a.modify ? Xa(e, t, (() => { let t = a.getRangeAt(0), i = a.focusNode, o = a.focusOffset, s = a.caretBidiLevel; a.modify("move", n, "character"); let l = !(r.depth ? e.docView.domAfterPos(r.before()) : e.dom).contains(1 == a.focusNode.nodeType ? a.focusNode : a.focusNode.parentNode) || i == a.focusNode && o == a.focusOffset; return a.removeAllRanges(), a.addRange(t), null != s && (a.caretBidiLevel = s), l })) : "left" == n || "backward" == n ? o : s }(e, t, n)) } class nl { constructor(e, t, n, r) { this.parent = e, this.children = t, this.dom = n, this.contentDOM = r, this.dirty = 0, n.pmViewDesc = this } matchesWidget(e) { return !1 } matchesMark(e) { return !1 } matchesNode(e, t, n) { return !1 } matchesHack(e) { return !1 } parseRule() { return null } stopEvent(e) { return !1 } get size() { let e = 0; for (let t = 0; t < this.children.length; t++)e += this.children[t].size; return e } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let e = 0; e < this.children.length; e++)this.children[e].destroy() } posBeforeChild(e) { for (let t = 0, n = this.posAtStart; ; t++) { let r = this.children[t]; if (r == e) return n; n += r.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(e, t, n) { if (this.contentDOM && this.contentDOM.contains(1 == e.nodeType ? e : e.parentNode)) { if (n < 0) { let n, r; if (e == this.contentDOM) n = e.childNodes[t - 1]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; n = e.previousSibling } for (; n && (!(r = n.pmViewDesc) || r.parent != this);)n = n.previousSibling; return n ? this.posBeforeChild(r) + r.size : this.posAtStart } { let n, r; if (e == this.contentDOM) n = e.childNodes[t]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; n = e.nextSibling } for (; n && (!(r = n.pmViewDesc) || r.parent != this);)n = n.nextSibling; return n ? this.posBeforeChild(r) : this.posAtEnd } } let r; if (e == this.dom && this.contentDOM) r = t > Ca(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) r = 2 & e.compareDocumentPosition(this.contentDOM); else if (this.dom.firstChild) { if (0 == t) for (let t = e; ; t = t.parentNode) { if (t == this.dom) { r = !1; break } if (t.previousSibling) break } if (null == r && t == e.childNodes.length) for (let t = e; ; t = t.parentNode) { if (t == this.dom) { r = !0; break } if (t.nextSibling) break } } return (null == r ? n > 0 : r) ? this.posAtEnd : this.posAtStart } nearestDesc(e, t = !1) { for (let n = !0, r = e; r; r = r.parentNode) { let i, o = this.getDesc(r); if (o && (!t || o.node)) { if (!n || !(i = o.nodeDOM) || (1 == i.nodeType ? i.contains(1 == e.nodeType ? e : e.parentNode) : i == e)) return o; n = !1 } } } getDesc(e) { let t = e.pmViewDesc; for (let e = t; e; e = e.parent)if (e == this) return t } posFromDOM(e, t, n) { for (let r = e; r; r = r.parentNode) { let i = this.getDesc(r); if (i) return i.localPosFromDOM(e, t, n) } return -1 } descAt(e) { for (let t = 0, n = 0; t < this.children.length; t++) { let r = this.children[t], i = n + r.size; if (n == e && i != n) { for (; !r.border && r.children.length;)r = r.children[0]; return r } if (e < i) return r.descAt(e - n - r.border); n = i } } domFromPos(e, t) { if (!this.contentDOM) return { node: this.dom, offset: 0 }; let n, r = 0, i = 0; for (let t = 0; r < this.children.length; r++) { let n = this.children[r], o = t + n.size; if (o > e || n instanceof cl) { i = e - t; break } t = o } if (i) return this.children[r].domFromPos(i - this.children[r].border, t); for (; r && !(n = this.children[r - 1]).size && n instanceof rl && n.side >= 0; r--); if (t <= 0) { let e, n = !0; for (; e = r ? this.children[r - 1] : null, e && e.dom.parentNode != this.contentDOM; r--, n = !1); return e && t && n && !e.border && !e.domAtom ? e.domFromPos(e.size, t) : { node: this.contentDOM, offset: e ? Ca(e.dom) + 1 : 0 } } { let e, n = !0; for (; e = r < this.children.length ? this.children[r] : null, e && e.dom.parentNode != this.contentDOM; r++, n = !1); return e && n && !e.border && !e.domAtom ? e.domFromPos(0, t) : { node: this.contentDOM, offset: e ? Ca(e.dom) : this.contentDOM.childNodes.length } } } parseRange(e, t, n = 0) { if (0 == this.children.length) return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let r = -1, i = -1; for (let o = n, s = 0; ; s++) { let n = this.children[s], a = o + n.size; if (-1 == r && e <= a) { let i = o + n.border; if (e >= i && t <= a - n.border && n.node && n.contentDOM && this.contentDOM.contains(n.contentDOM)) return n.parseRange(e, t, i); e = o; for (let t = s; t > 0; t--) { let n = this.children[t - 1]; if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(1)) { r = Ca(n.dom) + 1; break } e -= n.size } -1 == r && (r = 0) } if (r > -1 && (a > t || s == this.children.length - 1)) { t = a; for (let e = s + 1; e < this.children.length; e++) { let n = this.children[e]; if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(-1)) { i = Ca(n.dom); break } t += n.size } -1 == i && (i = this.contentDOM.childNodes.length); break } o = a } return { node: this.contentDOM, from: e, to: t, fromOffset: r, toOffset: i } } emptyChildAt(e) { if (this.border || !this.contentDOM || !this.children.length) return !1; let t = this.children[e < 0 ? 0 : this.children.length - 1]; return 0 == t.size || t.emptyChildAt(e) } domAfterPos(e) { let { node: t, offset: n } = this.domFromPos(e, 0); if (1 != t.nodeType || n == t.childNodes.length) throw new RangeError("No node after pos " + e); return t.childNodes[n] } setSelection(e, t, n, r = !1) { let i = Math.min(e, t), o = Math.max(e, t); for (let s = 0, a = 0; s < this.children.length; s++) { let l = this.children[s], c = a + l.size; if (i > a && o < c) return l.setSelection(e - a - l.border, t - a - l.border, n, r); a = c } let s = this.domFromPos(e, e ? -1 : 1), a = t == e ? s : this.domFromPos(t, t ? -1 : 1), l = n.getSelection(), c = !1; if ((pa || ya) && e == t) { let { node: e, offset: t } = s; if (3 == e.nodeType) { if (c = !(!t || "\n" != e.nodeValue[t - 1]), c && t == e.nodeValue.length) for (let t, n = e; n; n = n.parentNode) { if (t = n.nextSibling) { "BR" == t.nodeName && (s = a = { node: t.parentNode, offset: Ca(t) + 1 }); break } let e = n.pmViewDesc; if (e && e.node && e.node.isBlock) break } } else { let n = e.childNodes[t - 1]; c = n && ("BR" == n.nodeName || "false" == n.contentEditable) } } if (pa && l.focusNode && l.focusNode != a.node && 1 == l.focusNode.nodeType) { let e = l.focusNode.childNodes[l.focusOffset]; e && "false" == e.contentEditable && (r = !0) } if (!(r || c && ya) && Sa(s.node, s.offset, l.anchorNode, l.anchorOffset) && Sa(a.node, a.offset, l.focusNode, l.focusOffset)) return; let u = !1; if ((l.extend || e == t) && !c) { l.collapse(s.node, s.offset); try { e != t && l.extend(a.node, a.offset), u = !0 } catch (e) { if (!(e instanceof DOMException)) throw e } } if (!u) { if (e > t) { let e = s; s = a, a = e } let n = document.createRange(); n.setEnd(a.node, a.offset), n.setStart(s.node, s.offset), l.removeAllRanges(), l.addRange(n) } } ignoreMutation(e) { return !this.contentDOM && "selection" != e.type } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(e, t) { for (let n = 0, r = 0; r < this.children.length; r++) { let i = this.children[r], o = n + i.size; if (n == o ? e <= o && t >= n : e < o && t > n) { let r = n + i.border, s = o - i.border; if (e >= r && t <= s) return this.dirty = e == n || t == o ? 2 : 1, void (e != r || t != s || !i.contentLost && i.dom.parentNode == this.contentDOM ? i.markDirty(e - r, t - r) : i.dirty = 3); i.dirty = i.dom != i.contentDOM || i.dom.parentNode != this.contentDOM || i.children.length ? 3 : 2 } n = o } this.dirty = 2 } markParentsDirty() { let e = 1; for (let t = this.parent; t; t = t.parent, e++) { let n = 1 == e ? 2 : 1; t.dirty < n && (t.dirty = n) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } } class rl extends nl { constructor(e, t, n, r) { let i, o = t.type.toDOM; if ("function" == typeof o && (o = o(n, (() => i ? i.parent ? i.parent.posBeforeChild(i) : void 0 : r))), !t.type.spec.raw) { if (1 != o.nodeType) { let e = document.createElement("span"); e.appendChild(o), o = e } o.contentEditable = "false", o.classList.add("ProseMirror-widget") } super(e, [], o, null), this.widget = t, this.widget = t, i = this } matchesWidget(e) { return 0 == this.dirty && e.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(e) { let t = this.widget.spec.stopEvent; return !!t && t(e) } ignoreMutation(e) { return "selection" != e.type || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get side() { return this.widget.type.side } } class il extends nl { constructor(e, t, n, r) { super(e, [], t, null), this.textDOM = n, this.text = r } get size() { return this.text.length } localPosFromDOM(e, t) { return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t } domFromPos(e) { return { node: this.textDOM, offset: e } } ignoreMutation(e) { return "characterData" === e.type && e.target.nodeValue == e.oldValue } } class ol extends nl { constructor(e, t, n, r) { super(e, [], n, r), this.mark = t } static create(e, t, n, r) { let i = r.nodeViews[t.type.name], o = i && i(t, r, n); return o && o.dom || (o = Go.renderSpec(document, t.type.spec.toDOM(t, n))), new ol(e, t, o.dom, o.contentDOM || o.dom) } parseRule() { return 3 & this.dirty || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM || void 0 } } matchesMark(e) { return 3 != this.dirty && this.mark.eq(e) } markDirty(e, t) { if (super.markDirty(e, t), 0 != this.dirty) { let e = this.parent; for (; !e.node;)e = e.parent; e.dirty < this.dirty && (e.dirty = this.dirty), this.dirty = 0 } } slice(e, t, n) { let r = ol.create(this.parent, this.mark, !0, n), i = this.children, o = this.size; t < o && (i = xl(i, t, o, n)), e > 0 && (i = xl(i, 0, e, n)); for (let e = 0; e < i.length; e++)i[e].parent = r; return r.children = i, r } } class sl extends nl { constructor(e, t, n, r, i, o, s, a, l) { super(e, [], i, o), this.node = t, this.outerDeco = n, this.innerDeco = r, this.nodeDOM = s, o && this.updateChildren(a, l) } static create(e, t, n, r, i, o) { let s, a = i.nodeViews[t.type.name], l = a && a(t, i, (() => s ? s.parent ? s.parent.posBeforeChild(s) : void 0 : o), n, r), c = l && l.dom, u = l && l.contentDOM; if (t.isText) if (c) { if (3 != c.nodeType) throw new RangeError("Text must be rendered as a DOM text node") } else c = document.createTextNode(t.text); else c || ({ dom: c, contentDOM: u } = Go.renderSpec(document, t.type.spec.toDOM(t))); u || t.isText || "BR" == c.nodeName || (c.hasAttribute("contenteditable") || (c.contentEditable = "false"), t.type.spec.draggable && (c.draggable = !0)); let d = c; return c = yl(c, n, t), l ? s = new ul(e, t, n, r, c, u || null, d, l, i, o + 1) : t.isText ? new ll(e, t, n, r, c, d, i) : new sl(e, t, n, r, c, u || null, d, i, o + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let e = { node: this.node.type.name, attrs: this.node.attrs }; if ("pre" == this.node.type.whitespace && (e.preserveWhitespace = "full"), this.contentDOM) if (this.contentLost) { for (let t = this.children.length - 1; t >= 0; t--) { let n = this.children[t]; if (this.dom.contains(n.dom.parentNode)) { e.contentElement = n.dom.parentNode; break } } e.contentElement || (e.getContent = () => Ui.empty) } else e.contentElement = this.contentDOM; else e.getContent = () => this.node.content; return e } matchesNode(e, t, n) { return 0 == this.dirty && e.eq(this.node) && vl(t, this.outerDeco) && n.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(e, t) { let n = this.node.inlineContent, r = t, i = e.composing ? this.localCompositionInfo(e, t) : null, o = i && i.pos > -1 ? i : null, s = i && i.pos < 0, a = new wl(this, o && o.node); !function (e, t, n, r) { let i = t.locals(e), o = 0; if (0 == i.length) { for (let n = 0; n < e.childCount; n++) { let s = e.child(n); r(s, i, t.forChild(o, s), n), o += s.nodeSize } return } let s = 0, a = [], l = null; for (let c = 0; ;) { if (s < i.length && i[s].to == o) { let e, t = i[s++]; for (; s < i.length && i[s].to == o;)(e || (e = [t])).push(i[s++]); if (e) { e.sort(Dl); for (let t = 0; t < e.length; t++)n(e[t], c, !!l) } else n(t, c, !!l) } let u, d; if (l) d = -1, u = l, l = null; else { if (!(c < e.childCount)) break; d = c, u = e.child(c++) } for (let e = 0; e < a.length; e++)a[e].to <= o && a.splice(e--, 1); for (; s < i.length && i[s].from <= o && i[s].to > o;)a.push(i[s++]); let h = o + u.nodeSize; if (u.isText) { let e = h; s < i.length && i[s].from < e && (e = i[s].from); for (let t = 0; t < a.length; t++)a[t].to < e && (e = a[t].to); e < h && (l = u.cut(e - o), u = u.cut(0, e - o), h = e, d = -1) } r(u, u.isInline && !u.isLeaf ? a.filter((e => !e.inline)) : a.slice(), t.forChild(o, u), d), o = h } }(this.node, this.innerDeco, ((t, i, o) => { t.spec.marks ? a.syncToMarks(t.spec.marks, n, e) : t.type.side >= 0 && !o && a.syncToMarks(i == this.node.childCount ? Zi.none : this.node.child(i).marks, n, e), a.placeWidget(t, e, r) }), ((t, o, l, c) => { let u; a.syncToMarks(t.marks, n, e), a.findNodeMatch(t, o, l, c) || s && e.state.selection.from > r && e.state.selection.to < r + t.nodeSize && (u = a.findIndexWithChild(i.node)) > -1 && a.updateNodeAt(t, o, l, u, e) || a.updateNextNode(t, o, l, e, c) || a.addNode(t, o, l, e, r), r += t.nodeSize })), a.syncToMarks([], n, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || 2 == this.dirty) && (o && this.protectLocalComposition(e, o), dl(this.contentDOM, this.children, e), va && function (e) { if ("UL" == e.nodeName || "OL" == e.nodeName) { let t = e.style.cssText; e.style.cssText = t + "; list-style: square !important", window.getComputedStyle(e).listStyle, e.style.cssText = t } }(this.dom)) } localCompositionInfo(e, t) { let { from: n, to: r } = e.state.selection; if (!(e.state.selection instanceof zs) || n < t || r > t + this.node.content.size) return null; let i = e.domSelection(), o = function (e, t) { for (; ;) { if (3 == e.nodeType) return e; if (1 == e.nodeType && t > 0) { if (e.childNodes.length > t && 3 == e.childNodes[t].nodeType) return e.childNodes[t]; t = Ta(e = e.childNodes[t - 1]) } else { if (!(1 == e.nodeType && t < e.childNodes.length)) return null; e = e.childNodes[t], t = 0 } } }(i.focusNode, i.focusOffset); if (!o || !this.dom.contains(o.parentNode)) return null; if (this.node.inlineContent) { let e = o.nodeValue, i = function (e, t, n, r) { for (let i = 0, o = 0; i < e.childCount && o <= r;) { let s = e.child(i++), a = o; if (o += s.nodeSize, !s.isText) continue; let l = s.text; for (; i < e.childCount;) { let t = e.child(i++); if (o += t.nodeSize, !t.isText) break; l += t.text } if (o >= n) { let e = a < r ? l.lastIndexOf(t, r - a - 1) : -1; if (e >= 0 && e + t.length + a >= n) return a + e; if (n == r && l.length >= r + t.length - a && l.slice(r - a, r - a + t.length) == t) return r } } return -1 }(this.node.content, e, n - t, r - t); return i < 0 ? null : { node: o, pos: i, text: e } } return { node: o, pos: -1, text: "" } } protectLocalComposition(e, { node: t, pos: n, text: r }) { if (this.getDesc(t)) return; let i = t; for (; i.parentNode != this.contentDOM; i = i.parentNode) { for (; i.previousSibling;)i.parentNode.removeChild(i.previousSibling); for (; i.nextSibling;)i.parentNode.removeChild(i.nextSibling); i.pmViewDesc && (i.pmViewDesc = void 0) } let o = new il(this, i, t, r); e.input.compositionNodes.push(o), this.children = xl(this.children, n, n + r.length, e, o) } update(e, t, n, r) { return !(3 == this.dirty || !e.sameMarkup(this.node)) && (this.updateInner(e, t, n, r), !0) } updateInner(e, t, n, r) { this.updateOuterDeco(t), this.node = e, this.innerDeco = n, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = 0 } updateOuterDeco(e) { if (vl(e, this.outerDeco)) return; let t = 1 != this.nodeDOM.nodeType, n = this.dom; this.dom = ml(this.dom, this.nodeDOM, fl(this.outerDeco, this.node, t), fl(e, this.node, t)), this.dom != n && (n.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e } selectNode() { 1 == this.nodeDOM.nodeType && this.nodeDOM.classList.add("ProseMirror-selectednode"), !this.contentDOM && this.node.type.spec.draggable || (this.dom.draggable = !0) } deselectNode() { 1 == this.nodeDOM.nodeType && this.nodeDOM.classList.remove("ProseMirror-selectednode"), !this.contentDOM && this.node.type.spec.draggable || this.dom.removeAttribute("draggable") } get domAtom() { return this.node.isAtom } } function al(e, t, n, r, i) { return yl(r, t, e), new sl(void 0, e, t, n, r, r, r, i, 0) } class ll extends sl { constructor(e, t, n, r, i, o, s) { super(e, t, n, r, i, null, o, s, 0) } parseRule() { let e = this.nodeDOM.parentNode; for (; e && e != this.dom && !e.pmIsDeco;)e = e.parentNode; return { skip: e || !0 } } update(e, t, n, r) { return !(3 == this.dirty || 0 != this.dirty && !this.inParent() || !e.sameMarkup(this.node)) && (this.updateOuterDeco(t), 0 == this.dirty && e.text == this.node.text || e.text == this.nodeDOM.nodeValue || (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = 0, !0) } inParent() { let e = this.parent.contentDOM; for (let t = this.nodeDOM; t; t = t.parentNode)if (t == e) return !0; return !1 } domFromPos(e) { return { node: this.nodeDOM, offset: e } } localPosFromDOM(e, t, n) { return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, n) } ignoreMutation(e) { return "characterData" != e.type && "selection" != e.type } slice(e, t, n) { let r = this.node.cut(e, t), i = document.createTextNode(r.text); return new ll(this.parent, r, this.outerDeco, this.innerDeco, i, i, n) } markDirty(e, t) { super.markDirty(e, t), this.dom == this.nodeDOM || 0 != e && t != this.nodeDOM.nodeValue.length || (this.dirty = 3) } get domAtom() { return !1 } } class cl extends nl { parseRule() { return { ignore: !0 } } matchesHack(e) { return 0 == this.dirty && this.dom.nodeName == e } get domAtom() { return !0 } get ignoreForCoords() { return "IMG" == this.dom.nodeName } } class ul extends sl { constructor(e, t, n, r, i, o, s, a, l, c) { super(e, t, n, r, i, o, s, l, c), this.spec = a } update(e, t, n, r) { if (3 == this.dirty) return !1; if (this.spec.update) { let i = this.spec.update(e, t, n); return i && this.updateInner(e, t, n, r), i } return !(!this.contentDOM && !e.isLeaf) && super.update(e, t, n, r) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(e, t, n, r) { this.spec.setSelection ? this.spec.setSelection(e, t, n) : super.setSelection(e, t, n, r) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(e) { return !!this.spec.stopEvent && this.spec.stopEvent(e) } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } } function dl(e, t, n) { let r = e.firstChild, i = !1; for (let o = 0; o < t.length; o++) { let s = t[o], a = s.dom; if (a.parentNode == e) { for (; a != r;)r = bl(r), i = !0; r = r.nextSibling } else i = !0, e.insertBefore(a, r); if (s instanceof ol) { let t = r ? r.previousSibling : e.lastChild; dl(s.contentDOM, s.children, n), r = t ? t.nextSibling : e.firstChild } } for (; r;)r = bl(r), i = !0; i && n.trackWrites == e && (n.trackWrites = null) } const hl = function (e) { e && (this.nodeName = e) }; hl.prototype = Object.create(null); const pl = [new hl]; function fl(e, t, n) { if (0 == e.length) return pl; let r = n ? pl[0] : new hl, i = [r]; for (let o = 0; o < e.length; o++) { let s = e[o].type.attrs; if (s) { s.nodeName && i.push(r = new hl(s.nodeName)); for (let e in s) { let o = s[e]; null != o && (n && 1 == i.length && i.push(r = new hl(t.isInline ? "span" : "div")), "class" == e ? r.class = (r.class ? r.class + " " : "") + o : "style" == e ? r.style = (r.style ? r.style + ";" : "") + o : "nodeName" != e && (r[e] = o)) } } } return i } function ml(e, t, n, r) { if (n == pl && r == pl) return t; let i = t; for (let t = 0; t < r.length; t++) { let o = r[t], s = n[t]; if (t) { let t; s && s.nodeName == o.nodeName && i != e && (t = i.parentNode) && t.nodeName.toLowerCase() == o.nodeName || (t = document.createElement(o.nodeName), t.pmIsDeco = !0, t.appendChild(i), s = pl[0]), i = t } gl(i, s || pl[0], o) } return i } function gl(e, t, n) { for (let r in t) "class" == r || "style" == r || "nodeName" == r || r in n || e.removeAttribute(r); for (let r in n) "class" != r && "style" != r && "nodeName" != r && n[r] != t[r] && e.setAttribute(r, n[r]); if (t.class != n.class) { let r = t.class ? t.class.split(" ").filter(Boolean) : [], i = n.class ? n.class.split(" ").filter(Boolean) : []; for (let t = 0; t < r.length; t++)-1 == i.indexOf(r[t]) && e.classList.remove(r[t]); for (let t = 0; t < i.length; t++)-1 == r.indexOf(i[t]) && e.classList.add(i[t]); 0 == e.classList.length && e.removeAttribute("class") } if (t.style != n.style) { if (t.style) { let n, r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g; for (; n = r.exec(t.style);)e.style.removeProperty(n[1]) } n.style && (e.style.cssText += n.style) } } function yl(e, t, n) { return ml(e, e, pl, fl(t, n, 1 != e.nodeType)) } function vl(e, t) { if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!e[n].type.eq(t[n].type)) return !1; return !0 } function bl(e) { let t = e.nextSibling; return e.parentNode.removeChild(e), t } class wl { constructor(e, t) { this.lock = t, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = function (e, t) { let n = t, r = n.children.length, i = e.childCount, o = new Map, s = []; e: for (; i > 0;) { let a; for (; ;)if (r) { let e = n.children[r - 1]; if (!(e instanceof ol)) { a = e, r--; break } n = e, r = e.children.length } else { if (n == t) break e; r = n.parent.children.indexOf(n), n = n.parent } let l = a.node; if (l) { if (l != e.child(i - 1)) break; --i, o.set(a, i), s.push(a) } } return { index: i, matched: o, matches: s.reverse() } }(e.node.content, e) } destroyBetween(e, t) { if (e != t) { for (let n = e; n < t; n++)this.top.children[n].destroy(); this.top.children.splice(e, t - e), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(e, t, n) { let r = 0, i = this.stack.length >> 1, o = Math.min(i, e.length); for (; r < o && (r == i - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && !1 !== e[r].type.spec.spanning;)r++; for (; r < i;)this.destroyRest(), this.top.dirty = 0, this.index = this.stack.pop(), this.top = this.stack.pop(), i--; for (; i < e.length;) { this.stack.push(this.top, this.index + 1); let r = -1; for (let t = this.index; t < Math.min(this.index + 3, this.top.children.length); t++)if (this.top.children[t].matchesMark(e[i])) { r = t; break } if (r > -1) r > this.index && (this.changed = !0, this.destroyBetween(this.index, r)), this.top = this.top.children[this.index]; else { let r = ol.create(this.top, e[i], t, n); this.top.children.splice(this.index, 0, r), this.top = r, this.changed = !0 } this.index = 0, i++ } } findNodeMatch(e, t, n, r) { let i, o = -1; if (r >= this.preMatch.index && (i = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && i.matchesNode(e, t, n)) o = this.top.children.indexOf(i, this.index); else for (let r = this.index, i = Math.min(this.top.children.length, r + 5); r < i; r++) { let i = this.top.children[r]; if (i.matchesNode(e, t, n) && !this.preMatch.matched.has(i)) { o = r; break } } return !(o < 0) && (this.destroyBetween(this.index, o), this.index++, !0) } updateNodeAt(e, t, n, r, i) { let o = this.top.children[r]; return 3 == o.dirty && o.dom == o.contentDOM && (o.dirty = 2), !!o.update(e, t, n, i) && (this.destroyBetween(this.index, r), this.index = r + 1, !0) } findIndexWithChild(e) { for (; ;) { let t = e.parentNode; if (!t) return -1; if (t == this.top.contentDOM) { let t = e.pmViewDesc; if (t) for (let e = this.index; e < this.top.children.length; e++)if (this.top.children[e] == t) return e; return -1 } e = t } } updateNextNode(e, t, n, r, i) { for (let o = this.index; o < this.top.children.length; o++) { let s = this.top.children[o]; if (s instanceof sl) { let a = this.preMatch.matched.get(s); if (null != a && a != i) return !1; let l = s.dom; if (!(this.lock && (l == this.lock || 1 == l.nodeType && l.contains(this.lock.parentNode)) && !(e.isText && s.node && s.node.isText && s.nodeDOM.nodeValue == e.text && 3 != s.dirty && vl(t, s.outerDeco))) && s.update(e, t, n, r)) return this.destroyBetween(this.index, o), s.dom != l && (this.changed = !0), this.index++, !0; break } } return !1 } addNode(e, t, n, r, i) { this.top.children.splice(this.index++, 0, sl.create(this.top, e, t, n, r, i)), this.changed = !0 } placeWidget(e, t, n) { let r = this.index < this.top.children.length ? this.top.children[this.index] : null; if (!r || !r.matchesWidget(e) || e != r.widget && r.widget.type.toDOM.parentNode) { let r = new rl(this.top, e, t, n); this.top.children.splice(this.index++, 0, r), this.changed = !0 } else this.index++ } addTextblockHacks() { let e = this.top.children[this.index - 1], t = this.top; for (; e instanceof ol;)t = e, e = t.children[t.children.length - 1]; e && e instanceof ll && !/\n$/.test(e.node.text) || ((ya || ma) && e && "false" == e.dom.contentEditable && this.addHackNode("IMG", t), this.addHackNode("BR", this.top)) } addHackNode(e, t) { if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) this.index++; else { let n = document.createElement(e); "IMG" == e && (n.className = "ProseMirror-separator", n.alt = ""), "BR" == e && (n.className = "ProseMirror-trailingBreak"); let r = new cl(this.top, [], n, null); t != this.top ? t.children.push(r) : t.children.splice(this.index++, 0, r), this.changed = !0 } } } function Dl(e, t) { return e.type.side - t.type.side } function xl(e, t, n, r, i) { let o = []; for (let s = 0, a = 0; s < e.length; s++) { let l = e[s], c = a, u = a += l.size; c >= n || u <= t ? o.push(l) : (c < t && o.push(l.slice(0, t - c, r)), i && (o.push(i), i = void 0), u > n && o.push(l.slice(n - c, l.size, r))) } return o } function Cl(e, t = null) { let n = e.domSelection(), r = e.state.doc; if (!n.focusNode) return null; let i = e.docView.nearestDesc(n.focusNode), o = i && 0 == i.size, s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1); if (s < 0) return null; let a, l, c = r.resolve(s); if (Na(n)) { for (a = c; i && !i.node;)i = i.parent; let e = i.node; if (i && e.isAtom && Hs.isSelectable(e) && i.parent && (!e.isInline || !function (e, t, n) { for (let r = 0 == t, i = t == Ta(e); r || i;) { if (e == n) return !0; let t = Ca(e); if (!(e = e.parentNode)) return !1; r = r && 0 == t, i = i && t == Ta(e) } }(n.focusNode, n.focusOffset, i.dom))) { let e = i.posBefore; l = new Hs(s == e ? c : r.resolve(e)) } } else { let t = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1); if (t < 0) return null; a = r.resolve(t) } if (!l) { l = Nl(e, a, c, "pointer" == t || e.state.selection.head < c.pos && !o ? 1 : -1) } return l } function kl(e) { return e.editable ? e.hasFocus() : _l(e) && document.activeElement && document.activeElement.contains(e.dom) } function Al(e, t = !1) { let n = e.state.selection; if (Tl(e, n), kl(e)) { if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && ma) { let t = e.domSelection(), n = e.domObserver.currentSelection; if (t.anchorNode && n.anchorNode && Sa(t.anchorNode, t.anchorOffset, n.anchorNode, n.anchorOffset)) return e.input.mouseDown.delayedSelectionSync = !0, void e.domObserver.setCurSelection() } if (e.domObserver.disconnectSelection(), e.cursorWrapper) !function (e) { let t = e.domSelection(), n = document.createRange(), r = e.cursorWrapper.dom, i = "IMG" == r.nodeName; i ? n.setEnd(r.parentNode, Ca(r) + 1) : n.setEnd(r, 0); n.collapse(!1), t.removeAllRanges(), t.addRange(n), !i && !e.state.selection.visible && da && ha <= 11 && (r.disabled = !0, r.disabled = !1) }(e); else { let r, i, { anchor: o, head: s } = n; !El || n instanceof zs || (n.$from.parent.inlineContent || (r = Sl(e, n.from)), n.empty || n.$from.parent.inlineContent || (i = Sl(e, n.to))), e.docView.setSelection(o, s, e.root, t), El && (r && Ol(r), i && Ol(i)), n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && function (e) { let t = e.dom.ownerDocument; t.removeEventListener("selectionchange", e.input.hideSelectionGuard); let n = e.domSelection(), r = n.anchorNode, i = n.anchorOffset; t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => { n.anchorNode == r && n.anchorOffset == i || (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout((() => { kl(e) && !e.state.selection.visible || e.dom.classList.remove("ProseMirror-hideselection") }), 20)) }) }(e)) } e.domObserver.setCurSelection(), e.domObserver.connectSelection() } } const El = ya || ma && ga < 63; function Sl(e, t) { let { node: n, offset: r } = e.docView.domFromPos(t, 0), i = r < n.childNodes.length ? n.childNodes[r] : null, o = r ? n.childNodes[r - 1] : null; if (ya && i && "false" == i.contentEditable) return Ml(i); if (!(i && "false" != i.contentEditable || o && "false" != o.contentEditable)) { if (i) return Ml(i); if (o) return Ml(o) } } function Ml(e) { return e.contentEditable = "true", ya && e.draggable && (e.draggable = !1, e.wasDraggable = !0), e } function Ol(e) { e.contentEditable = "false", e.wasDraggable && (e.draggable = !0, e.wasDraggable = null) } function Tl(e, t) { if (t instanceof Hs) { let n = e.docView.descAt(t.from); n != e.lastSelectedViewDesc && (Fl(e), n && n.selectNode(), e.lastSelectedViewDesc = n) } else Fl(e) } function Fl(e) { e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0) } function Nl(e, t, n, r) { return e.someProp("createSelectionBetween", (r => r(e, t, n))) || zs.between(t, n, r) } function Bl(e) { return (!e.editable || e.root.activeElement == e.dom) && _l(e) } function _l(e) { let t = e.domSelection(); if (!t.anchorNode) return !1; try { return e.dom.contains(3 == t.anchorNode.nodeType ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(3 == t.focusNode.nodeType ? t.focusNode.parentNode : t.focusNode)) } catch (e) { return !1 } } function Rl(e, t) { let { $anchor: n, $head: r } = e.selection, i = t > 0 ? n.max(r) : n.min(r), o = i.parent.inlineContent ? i.depth ? e.doc.resolve(t > 0 ? i.after() : i.before()) : null : i; return o && Ls.findFrom(o, t) } function Ll(e, t) { return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0 } function Pl(e, t, n) { let r = e.state.selection; if (!(r instanceof zs)) { if (r instanceof Hs && r.node.isInline) return Ll(e, new zs(t > 0 ? r.$to : r.$from)); { let n = Rl(e.state, t); return !!n && Ll(e, n) } } if (!r.empty || n.indexOf("s") > -1) return !1; if (e.endOfTextblock(t > 0 ? "right" : "left")) { let n = Rl(e.state, t); return !!(n && n instanceof Hs) && Ll(e, n) } if (!(ba && n.indexOf("m") > -1)) { let n, i = r.$head, o = i.textOffset ? null : t < 0 ? i.nodeBefore : i.nodeAfter; if (!o || o.isText) return !1; let s = t < 0 ? i.pos - o.nodeSize : i.pos; return !!(o.isAtom || (n = e.docView.descAt(s)) && !n.contentDOM) && (Hs.isSelectable(o) ? Ll(e, new Hs(t < 0 ? e.state.doc.resolve(i.pos - o.nodeSize) : i)) : !!Da && Ll(e, new zs(e.state.doc.resolve(t < 0 ? s : s + o.nodeSize)))) } } function Il(e) { return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length } function $l(e) { let t = e.pmViewDesc; return t && 0 == t.size && (e.nextSibling || "BR" != e.nodeName) } function zl(e) { let t = e.domSelection(), n = t.focusNode, r = t.focusOffset; if (!n) return; let i, o, s = !1; for (pa && 1 == n.nodeType && r < Il(n) && $l(n.childNodes[r]) && (s = !0); ;)if (r > 0) { if (1 != n.nodeType) break; { let e = n.childNodes[r - 1]; if ($l(e)) i = n, o = --r; else { if (3 != e.nodeType) break; n = e, r = n.nodeValue.length } } } else { if (Hl(n)) break; { let t = n.previousSibling; for (; t && $l(t);)i = n.parentNode, o = Ca(t), t = t.previousSibling; if (t) n = t, r = Il(n); else { if (n = n.parentNode, n == e.dom) break; r = 0 } } } s ? Vl(e, t, n, r) : i && Vl(e, t, i, o) } function jl(e) { let t = e.domSelection(), n = t.focusNode, r = t.focusOffset; if (!n) return; let i, o, s = Il(n); for (; ;)if (r < s) { if (1 != n.nodeType) break; if (!$l(n.childNodes[r])) break; i = n, o = ++r } else { if (Hl(n)) break; { let t = n.nextSibling; for (; t && $l(t);)i = t.parentNode, o = Ca(t) + 1, t = t.nextSibling; if (t) n = t, r = 0, s = Il(n); else { if (n = n.parentNode, n == e.dom) break; r = s = 0 } } } i && Vl(e, t, i, o) } function Hl(e) { let t = e.pmViewDesc; return t && t.node && t.node.isBlock } function Vl(e, t, n, r) { if (Na(t)) { let e = document.createRange(); e.setEnd(n, r), e.setStart(n, r), t.removeAllRanges(), t.addRange(e) } else t.extend && t.extend(n, r); e.domObserver.setCurSelection(); let { state: i } = e; setTimeout((() => { e.state == i && Al(e) }), 50) } function Wl(e, t, n) { let r = e.state.selection; if (r instanceof zs && !r.empty || n.indexOf("s") > -1) return !1; if (ba && n.indexOf("m") > -1) return !1; let { $from: i, $to: o } = r; if (!i.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) { let n = Rl(e.state, t); if (n && n instanceof Hs) return Ll(e, n) } if (!i.parent.inlineContent) { let n = t < 0 ? i : o, s = r instanceof Ws ? Ls.near(n, t) : Ls.findFrom(n, t); return !!s && Ll(e, s) } return !1 } function ql(e, t) { if (!(e.state.selection instanceof zs)) return !0; let { $head: n, $anchor: r, empty: i } = e.state.selection; if (!n.sameParent(r)) return !0; if (!i) return !1; if (e.endOfTextblock(t > 0 ? "forward" : "backward")) return !0; let o = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter); if (o && !o.isText) { let r = e.state.tr; return t < 0 ? r.delete(n.pos - o.nodeSize, n.pos) : r.delete(n.pos, n.pos + o.nodeSize), e.dispatch(r), !0 } return !1 } function Kl(e, t, n) { e.domObserver.stop(), t.contentEditable = n, e.domObserver.start() } function Jl(e, t) { let n = t.keyCode, r = function (e) { let t = ""; return e.ctrlKey && (t += "c"), e.metaKey && (t += "m"), e.altKey && (t += "a"), e.shiftKey && (t += "s"), t }(t); return 8 == n || ba && 72 == n && "c" == r ? ql(e, -1) || zl(e) : 46 == n || ba && 68 == n && "c" == r ? ql(e, 1) || jl(e) : 13 == n || 27 == n || (37 == n || ba && 66 == n && "c" == r ? Pl(e, -1, r) || zl(e) : 39 == n || ba && 70 == n && "c" == r ? Pl(e, 1, r) || jl(e) : 38 == n || ba && 80 == n && "c" == r ? Wl(e, -1, r) || zl(e) : 40 == n || ba && 78 == n && "c" == r ? function (e) { if (!ya || e.state.selection.$head.parentOffset > 0) return !1; let { focusNode: t, focusOffset: n } = e.domSelection(); if (t && 1 == t.nodeType && 0 == n && t.firstChild && "false" == t.firstChild.contentEditable) { let n = t.firstChild; Kl(e, n, "true"), setTimeout((() => Kl(e, n, "false")), 20) } return !1 }(e) || Wl(e, 1, r) || jl(e) : r == (ba ? "m" : "c") && (66 == n || 73 == n || 89 == n || 90 == n)) } function Ul(e, t) { let n = [], { content: r, openStart: i, openEnd: o } = t; for (; i > 1 && o > 1 && 1 == r.childCount && 1 == r.firstChild.childCount;) { i--, o--; let e = r.firstChild; n.push(e.type.name, e.attrs != e.type.defaultAttrs ? e.attrs : null), r = e.content } let s = e.someProp("clipboardSerializer") || Go.fromSchema(e.state.schema), a = ic(), l = a.createElement("div"); l.appendChild(s.serializeFragment(r, { document: a })); let c, u = l.firstChild, d = 0; for (; u && 1 == u.nodeType && (c = nc[u.nodeName.toLowerCase()]);) { for (let e = c.length - 1; e >= 0; e--) { let t = a.createElement(c[e]); for (; l.firstChild;)t.appendChild(l.firstChild); l.appendChild(t), d++ } u = l.firstChild } return u && 1 == u.nodeType && u.setAttribute("data-pm-slice", `${i} ${o}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`), { dom: l, text: e.someProp("clipboardTextSerializer", (e => e(t))) || t.content.textBetween(0, t.content.size, "\n\n") } } function Gl(e, t, n, r, i) { let o, s, a = i.parent.type.spec.code; if (!n && !t) return null; let l = t && (r || a || !n); if (l) { if (e.someProp("transformPastedText", (e => { t = e(t, a || r) })), a) return t ? new eo(Ui.from(e.state.schema.text(t.replace(/\r\n?/g, "\n"))), 0, 0) : eo.empty; let n = e.someProp("clipboardTextParser", (e => e(t, i, r))); if (n) s = n; else { let n = i.marks(), { schema: r } = e.state, s = Go.fromSchema(r); o = document.createElement("div"), t.split(/(?:\r\n?|\n)+/).forEach((e => { let t = o.appendChild(document.createElement("p")); e && t.appendChild(s.serializeNode(r.text(e, n))) })) } } else e.someProp("transformPastedHTML", (e => { n = e(n) })), o = function (e) { let t = /^(\s*<meta [^>]*>)*/.exec(e); t && (e = e.slice(t[0].length)); let n, r = ic().createElement("div"), i = /<([a-z][^>\s]+)/i.exec(e); (n = i && nc[i[1].toLowerCase()]) && (e = n.map((e => "<" + e + ">")).join("") + e + n.map((e => "</" + e + ">")).reverse().join("")); if (r.innerHTML = e, n) for (let e = 0; e < n.length; e++)r = r.querySelector(n[e]) || r; return r }(n), Da && function (e) { let t = e.querySelectorAll(ma ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let n = 0; n < t.length; n++) { let r = t[n]; 1 == r.childNodes.length && "" == r.textContent && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r) } }(o); let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || ""); if (u && u[3]) for (let e = +u[3]; e > 0 && o.firstChild; e--)o = o.firstChild; if (!s) { let t = e.someProp("clipboardParser") || e.someProp("domParser") || $o.fromSchema(e.state.schema); s = t.parseSlice(o, { preserveWhitespace: !(!l && !u), context: i, ruleFromNode: e => "BR" != e.nodeName || e.nextSibling || !e.parentNode || Xl.test(e.parentNode.nodeName) ? null : { ignore: !0 } }) } if (u) s = function (e, t) { if (!e.size) return e; let n, r = e.content.firstChild.type.schema; try { n = JSON.parse(t) } catch (t) { return e } let { content: i, openStart: o, openEnd: s } = e; for (let e = n.length - 2; e >= 0; e -= 2) { let t = r.nodes[n[e]]; if (!t || t.hasRequiredAttrs()) break; i = Ui.from(t.create(n[e + 1], i)), o++, s++ } return new eo(i, o, s) }(tc(s, +u[1], +u[2]), u[4]); else if (s = eo.maxOpen(function (e, t) { if (e.childCount < 2) return e; for (let n = t.depth; n >= 0; n--) { let r, i = t.node(n).contentMatchAt(t.index(n)), o = []; if (e.forEach((e => { if (!o) return; let t, n = i.findWrapping(e.type); if (!n) return o = null; if (t = o.length && r.length && Zl(n, r, e, o[o.length - 1], 0)) o[o.length - 1] = t; else { o.length && (o[o.length - 1] = Ql(o[o.length - 1], r.length)); let t = Yl(e, n); o.push(t), i = i.matchType(t.type), r = n } })), o) return Ui.from(o) } return e }(s.content, i), !0), s.openStart || s.openEnd) { let e = 0, t = 0; for (let t = s.content.firstChild; e < s.openStart && !t.type.spec.isolating; e++, t = t.firstChild); for (let e = s.content.lastChild; t < s.openEnd && !e.type.spec.isolating; t++, e = e.lastChild); s = tc(s, e, t) } return e.someProp("transformPasted", (e => { s = e(s) })), s } const Xl = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function Yl(e, t, n = 0) { for (let r = t.length - 1; r >= n; r--)e = t[r].create(null, Ui.from(e)); return e } function Zl(e, t, n, r, i) { if (i < e.length && i < t.length && e[i] == t[i]) { let o = Zl(e, t, n, r.lastChild, i + 1); if (o) return r.copy(r.content.replaceChild(r.childCount - 1, o)); if (r.contentMatchAt(r.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1])) return r.copy(r.content.append(Ui.from(Yl(n, e, i + 1)))) } } function Ql(e, t) { if (0 == t) return e; let n = e.content.replaceChild(e.childCount - 1, Ql(e.lastChild, t - 1)), r = e.contentMatchAt(e.childCount).fillBefore(Ui.empty, !0); return e.copy(n.append(r)) } function ec(e, t, n, r, i, o) { let s = t < 0 ? e.firstChild : e.lastChild, a = s.content; return i < r - 1 && (a = ec(a, t, n, r, i + 1, o)), i >= n && (a = t < 0 ? s.contentMatchAt(0).fillBefore(a, e.childCount > 1 || o <= i).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(Ui.empty, !0))), e.replaceChild(t < 0 ? 0 : e.childCount - 1, s.copy(a)) } function tc(e, t, n) { return t < e.openStart && (e = new eo(ec(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)), n < e.openEnd && (e = new eo(ec(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)), e } const nc = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let rc = null; function ic() { return rc || (rc = document.implementation.createHTMLDocument("title")) } const oc = {}; let sc = {}; class ac { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function lc(e, t) { e.input.lastSelectionOrigin = t, e.input.lastSelectionTime = Date.now() } function cc(e) { e.someProp("handleDOMEvents", (t => { for (let n in t) e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = t => uc(e, t)) })) } function uc(e, t) { return e.someProp("handleDOMEvents", (n => { let r = n[t.type]; return !!r && (r(e, t) || t.defaultPrevented) })) } function dc(e, t) { if (!t.bubbles) return !0; if (t.defaultPrevented) return !1; for (let n = t.target; n != e.dom; n = n.parentNode)if (!n || 11 == n.nodeType || n.pmViewDesc && n.pmViewDesc.stopEvent(t)) return !1; return !0 } function hc(e) { return { left: e.clientX, top: e.clientY } } function pc(e, t, n, r, i) { if (-1 == r) return !1; let o = e.state.doc.resolve(r); for (let r = o.depth + 1; r > 0; r--)if (e.someProp(t, (t => r > o.depth ? t(e, n, o.nodeAfter, o.before(r), i, !0) : t(e, n, o.node(r), o.before(r), i, !1)))) return !0; return !1 } function fc(e, t, n) { e.focused || e.focus(); let r = e.state.tr.setSelection(t); "pointer" == n && r.setMeta("pointer", !0), e.dispatch(r) } function mc(e, t, n, r, i) { return pc(e, "handleClickOn", t, n, r) || e.someProp("handleClick", (n => n(e, t, r))) || (i ? function (e, t) { if (-1 == t) return !1; let n, r, i = e.state.selection; i instanceof Hs && (n = i.node); let o = e.state.doc.resolve(t); for (let e = o.depth + 1; e > 0; e--) { let t = e > o.depth ? o.nodeAfter : o.node(e); if (Hs.isSelectable(t)) { r = n && i.$from.depth > 0 && e >= i.$from.depth && o.before(i.$from.depth + 1) == i.$from.pos ? o.before(i.$from.depth) : o.before(e); break } } return null != r && (fc(e, Hs.create(e.state.doc, r), "pointer"), !0) }(e, n) : function (e, t) { if (-1 == t) return !1; let n = e.state.doc.resolve(t), r = n.nodeAfter; return !!(r && r.isAtom && Hs.isSelectable(r)) && (fc(e, new Hs(n), "pointer"), !0) }(e, n)) } function gc(e, t, n, r) { return pc(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", (n => n(e, t, r))) } function yc(e, t, n, r) { return pc(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", (n => n(e, t, r))) || function (e, t, n) { if (0 != n.button) return !1; let r = e.state.doc; if (-1 == t) return !!r.inlineContent && (fc(e, zs.create(r, 0, r.content.size), "pointer"), !0); let i = r.resolve(t); for (let t = i.depth + 1; t > 0; t--) { let n = t > i.depth ? i.nodeAfter : i.node(t), o = i.before(t); if (n.inlineContent) fc(e, zs.create(r, o + 1, o + 1 + n.content.size), "pointer"); else { if (!Hs.isSelectable(n)) continue; fc(e, Hs.create(r, o), "pointer") } return !0 } }(e, n, r) } function vc(e) { return Ac(e) } sc.keydown = (e, t) => { let n = t; if (e.input.shiftKey = 16 == n.keyCode || n.shiftKey, !Dc(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !wa || !ma || 13 != n.keyCode)) if (229 != n.keyCode && e.domObserver.forceFlush(), !va || 13 != n.keyCode || n.ctrlKey || n.altKey || n.metaKey) e.someProp("handleKeyDown", (t => t(e, n))) || Jl(e, n) ? n.preventDefault() : lc(e, "key"); else { let t = Date.now(); e.input.lastIOSEnter = t, e.input.lastIOSEnterFallbackTimeout = setTimeout((() => { e.input.lastIOSEnter == t && (e.someProp("handleKeyDown", (t => t(e, Ba(13, "Enter")))), e.input.lastIOSEnter = 0) }), 200) } }, sc.keyup = (e, t) => { 16 == t.keyCode && (e.input.shiftKey = !1) }, sc.keypress = (e, t) => { let n = t; if (Dc(e, n) || !n.charCode || n.ctrlKey && !n.altKey || ba && n.metaKey) return; if (e.someProp("handleKeyPress", (t => t(e, n)))) return void n.preventDefault(); let r = e.state.selection; if (!(r instanceof zs && r.$from.sameParent(r.$to))) { let t = String.fromCharCode(n.charCode); e.someProp("handleTextInput", (n => n(e, r.$from.pos, r.$to.pos, t))) || e.dispatch(e.state.tr.insertText(t).scrollIntoView()), n.preventDefault() } }; const bc = ba ? "metaKey" : "ctrlKey"; oc.mousedown = (e, t) => { let n = t; e.input.shiftKey = n.shiftKey; let r = vc(e), i = Date.now(), o = "singleClick"; i - e.input.lastClick.time < 500 && function (e, t) { let n = t.x - e.clientX, r = t.y - e.clientY; return n * n + r * r < 100 }(n, e.input.lastClick) && !n[bc] && ("singleClick" == e.input.lastClick.type ? o = "doubleClick" : "doubleClick" == e.input.lastClick.type && (o = "tripleClick")), e.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o }; let s = e.posAtCoords(hc(n)); s && ("singleClick" == o ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new wc(e, s, n, !!r)) : ("doubleClick" == o ? gc : yc)(e, s.pos, s.inside, n) ? n.preventDefault() : lc(e, "pointer")) }; class wc { constructor(e, t, n, r) { let i, o; if (this.view = e, this.pos = t, this.event = n, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!n[bc], this.allowDefault = n.shiftKey, t.inside > -1) i = e.state.doc.nodeAt(t.inside), o = t.inside; else { let n = e.state.doc.resolve(t.pos); i = n.parent, o = n.depth ? n.before() : 0 } const s = r ? null : n.target, a = s ? e.docView.nearestDesc(s, !0) : null; this.target = a ? a.dom : null; let { selection: l } = e.state; (0 == n.button && i.type.spec.draggable && !1 !== i.type.spec.selectable || l instanceof Hs && l.from <= o && l.to > o) && (this.mightDrag = { node: i, pos: o, addAttr: !(!this.target || this.target.draggable), setUneditable: !(!this.target || !pa || this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout((() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }), 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), lc(e, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout((() => Al(this.view))), this.view.input.mouseDown = null } up(e) { if (this.done(), !this.view.dom.contains(e.target)) return; let t = this.pos; this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(hc(e))), this.allowDefault || !t ? lc(this.view, "pointer") : mc(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : 0 == e.button && (this.flushed || ya && this.mightDrag && !this.mightDrag.node.isAtom || ma && !(this.view.state.selection instanceof zs) && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (fc(this.view, Ls.near(this.view.state.doc.resolve(t.pos)), "pointer"), e.preventDefault()) : lc(this.view, "pointer") } move(e) { !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0), lc(this.view, "pointer"), 0 == e.buttons && this.done() } } function Dc(e, t) { return !!e.composing || !!(ya && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500) && (e.input.compositionEndedAt = -2e8, !0) } oc.touchdown = e => { vc(e), lc(e, "pointer") }, oc.contextmenu = e => vc(e); const xc = wa ? 5e3 : -1; function Cc(e, t) { clearTimeout(e.input.composingTimeout), t > -1 && (e.input.composingTimeout = setTimeout((() => Ac(e)), t)) } function kc(e) { for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = function () { let e = document.createEvent("Event"); return e.initEvent("event", !0, !0), e.timeStamp }()); e.input.compositionNodes.length > 0;)e.input.compositionNodes.pop().markParentsDirty() } function Ac(e, t = !1) { if (!(wa && e.domObserver.flushingSoon >= 0)) { if (e.domObserver.forceFlush(), kc(e), t || e.docView && e.docView.dirty) { let t = Cl(e); return t && !t.eq(e.state.selection) ? e.dispatch(e.state.tr.setSelection(t)) : e.updateState(e.state), !0 } return !1 } } sc.compositionstart = sc.compositionupdate = e => { if (!e.composing) { e.domObserver.flush(); let { state: t } = e, n = t.selection.$from; if (t.selection.empty && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((e => !1 === e.type.spec.inclusive)))) e.markCursor = e.state.storedMarks || n.marks(), Ac(e, !0), e.markCursor = null; else if (Ac(e), pa && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) { let t = e.domSelection(); for (let e = t.focusNode, n = t.focusOffset; e && 1 == e.nodeType && 0 != n;) { let r = n < 0 ? e.lastChild : e.childNodes[n - 1]; if (!r) break; if (3 == r.nodeType) { t.collapse(r, r.nodeValue.length); break } e = r, n = -1 } } e.input.composing = !0 } Cc(e, xc) }, sc.compositionend = (e, t) => { e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, Cc(e, 20)) }; const Ec = da && ha < 15 || va && xa < 604; function Sc(e, t, n, r) { let i = Gl(e, t, n, e.input.shiftKey, e.state.selection.$from); if (e.someProp("handlePaste", (t => t(e, r, i || eo.empty)))) return !0; if (!i) return !1; let o = function (e) { return 0 == e.openStart && 0 == e.openEnd && 1 == e.content.childCount ? e.content.firstChild : null }(i), s = o ? e.state.tr.replaceSelectionWith(o, e.input.shiftKey) : e.state.tr.replaceSelection(i); return e.dispatch(s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } oc.copy = sc.cut = (e, t) => { let n = t, r = e.state.selection, i = "cut" == n.type; if (r.empty) return; let o = Ec ? null : n.clipboardData, s = r.content(), { dom: a, text: l } = Ul(e, s); o ? (n.preventDefault(), o.clearData(), o.setData("text/html", a.innerHTML), o.setData("text/plain", l)) : function (e, t) { if (!e.dom.parentNode) return; let n = e.dom.parentNode.appendChild(document.createElement("div")); n.appendChild(t), n.style.cssText = "position: fixed; left: -10000px; top: 10px"; let r = getSelection(), i = document.createRange(); i.selectNodeContents(t), e.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout((() => { n.parentNode && n.parentNode.removeChild(n), e.focus() }), 50) }(e, a), i && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }, sc.paste = (e, t) => { let n = t; if (e.composing && !wa) return; let r = Ec ? null : n.clipboardData; r && Sc(e, r.getData("text/plain"), r.getData("text/html"), n) ? n.preventDefault() : function (e, t) { if (!e.dom.parentNode) return; let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code, r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div")); n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(), setTimeout((() => { e.focus(), r.parentNode && r.parentNode.removeChild(r), n ? Sc(e, r.value, null, t) : Sc(e, r.textContent, r.innerHTML, t) }), 50) }(e, n) }; class Mc { constructor(e, t) { this.slice = e, this.move = t } } const Oc = ba ? "altKey" : "ctrlKey"; oc.dragstart = (e, t) => { let n = t, r = e.input.mouseDown; if (r && r.done(), !n.dataTransfer) return; let i = e.state.selection, o = i.empty ? null : e.posAtCoords(hc(n)); if (o && o.pos >= i.from && o.pos <= (i instanceof Hs ? i.to - 1 : i.to)); else if (r && r.mightDrag) e.dispatch(e.state.tr.setSelection(Hs.create(e.state.doc, r.mightDrag.pos))); else if (n.target && 1 == n.target.nodeType) { let t = e.docView.nearestDesc(n.target, !0); t && t.node.type.spec.draggable && t != e.docView && e.dispatch(e.state.tr.setSelection(Hs.create(e.state.doc, t.posBefore))) } let s = e.state.selection.content(), { dom: a, text: l } = Ul(e, s); n.dataTransfer.clearData(), n.dataTransfer.setData(Ec ? "Text" : "text/html", a.innerHTML), n.dataTransfer.effectAllowed = "copyMove", Ec || n.dataTransfer.setData("text/plain", l), e.dragging = new Mc(s, !n[Oc]) }, oc.dragend = e => { let t = e.dragging; window.setTimeout((() => { e.dragging == t && (e.dragging = null) }), 50) }, sc.dragover = sc.dragenter = (e, t) => t.preventDefault(), sc.drop = (e, t) => { let n = t, r = e.dragging; if (e.dragging = null, !n.dataTransfer) return; let i = e.posAtCoords(hc(n)); if (!i) return; let o = e.state.doc.resolve(i.pos); if (!o) return; let s = r && r.slice; s ? e.someProp("transformPasted", (e => { s = e(s) })) : s = Gl(e, n.dataTransfer.getData(Ec ? "Text" : "text/plain"), Ec ? null : n.dataTransfer.getData("text/html"), !1, o); let a = !(!r || n[Oc]); if (e.someProp("handleDrop", (t => t(e, n, s || eo.empty, a)))) return void n.preventDefault(); if (!s) return; n.preventDefault(); let l = s ? Ds(e.state.doc, o.pos, s) : o.pos; null == l && (l = o.pos); let c = e.state.tr; a && c.deleteSelection(); let u = c.mapping.map(l), d = 0 == s.openStart && 0 == s.openEnd && 1 == s.content.childCount, h = c.doc; if (d ? c.replaceRangeWith(u, u, s.content.firstChild) : c.replaceRange(u, u, s), c.doc.eq(h)) return; let p = c.doc.resolve(u); if (d && Hs.isSelectable(s.content.firstChild) && p.nodeAfter && p.nodeAfter.sameMarkup(s.content.firstChild)) c.setSelection(new Hs(p)); else { let t = c.mapping.map(l); c.mapping.maps[c.mapping.maps.length - 1].forEach(((e, n, r, i) => t = i)), c.setSelection(Nl(e, p, c.doc.resolve(t))) } e.focus(), e.dispatch(c.setMeta("uiEvent", "drop")) }, oc.focus = e => { e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout((() => { e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelection()) && Al(e) }), 20)) }, oc.blur = (e, t) => { let n = t; e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1) }, oc.beforeinput = (e, t) => { if (ma && wa && "deleteContentBackward" == t.inputType) { e.domObserver.flushSoon(); let { domChangeCount: t } = e.input; setTimeout((() => { if (e.input.domChangeCount != t) return; if (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", (t => t(e, Ba(8, "Backspace"))))) return; let { $cursor: n } = e.state.selection; n && n.pos > 0 && e.dispatch(e.state.tr.delete(n.pos - 1, n.pos).scrollIntoView()) }), 50) } }; for (let e in sc) oc[e] = sc[e]; function Tc(e, t) { if (e == t) return !0; for (let n in e) if (e[n] !== t[n]) return !1; for (let n in t) if (!(n in e)) return !1; return !0 } class Fc { constructor(e, t) { this.toDOM = e, this.spec = t || Lc, this.side = this.spec.side || 0 } map(e, t, n, r) { let { pos: i, deleted: o } = e.mapResult(t.from + r, this.side < 0 ? -1 : 1); return o ? null : new _c(i - n, i - n, this) } valid() { return !0 } eq(e) { return this == e || e instanceof Fc && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Tc(this.spec, e.spec)) } destroy(e) { this.spec.destroy && this.spec.destroy(e) } } class Nc { constructor(e, t) { this.attrs = e, this.spec = t || Lc } map(e, t, n, r) { let i = e.map(t.from + r, this.spec.inclusiveStart ? -1 : 1) - n, o = e.map(t.to + r, this.spec.inclusiveEnd ? 1 : -1) - n; return i >= o ? null : new _c(i, o, this) } valid(e, t) { return t.from < t.to } eq(e) { return this == e || e instanceof Nc && Tc(this.attrs, e.attrs) && Tc(this.spec, e.spec) } static is(e) { return e.type instanceof Nc } destroy() { } } class Bc { constructor(e, t) { this.attrs = e, this.spec = t || Lc } map(e, t, n, r) { let i = e.mapResult(t.from + r, 1); if (i.deleted) return null; let o = e.mapResult(t.to + r, -1); return o.deleted || o.pos <= i.pos ? null : new _c(i.pos - n, o.pos - n, this) } valid(e, t) { let n, { index: r, offset: i } = e.content.findIndex(t.from); return i == t.from && !(n = e.child(r)).isText && i + n.nodeSize == t.to } eq(e) { return this == e || e instanceof Bc && Tc(this.attrs, e.attrs) && Tc(this.spec, e.spec) } destroy() { } } class _c { constructor(e, t, n) { this.from = e, this.to = t, this.type = n } copy(e, t) { return new _c(e, t, this.type) } eq(e, t = 0) { return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to } map(e, t, n) { return this.type.map(e, this, t, n) } static widget(e, t, n) { return new _c(e, e, new Fc(t, n)) } static inline(e, t, n, r) { return new _c(e, t, new Nc(n, r)) } static node(e, t, n, r) { return new _c(e, t, new Bc(n, r)) } get spec() { return this.type.spec } get inline() { return this.type instanceof Nc } } const Rc = [], Lc = {}; class Pc { constructor(e, t) { this.local = e.length ? e : Rc, this.children = t.length ? t : Rc } static create(e, t) { return t.length ? Vc(t, e, 0, Lc) : Ic } find(e, t, n) { let r = []; return this.findInner(null == e ? 0 : e, null == t ? 1e9 : t, r, 0, n), r } findInner(e, t, n, r, i) { for (let o = 0; o < this.local.length; o++) { let s = this.local[o]; s.from <= t && s.to >= e && (!i || i(s.spec)) && n.push(s.copy(s.from + r, s.to + r)) } for (let o = 0; o < this.children.length; o += 3)if (this.children[o] < t && this.children[o + 1] > e) { let s = this.children[o] + 1; this.children[o + 2].findInner(e - s, t - s, n, r + s, i) } } map(e, t, n) { return this == Ic || 0 == e.maps.length ? this : this.mapInner(e, t, 0, 0, n || Lc) } mapInner(e, t, n, r, i) { let o; for (let s = 0; s < this.local.length; s++) { let a = this.local[s].map(e, n, r); a && a.type.valid(t, a) ? (o || (o = [])).push(a) : i.onRemove && i.onRemove(this.local[s].spec) } return this.children.length ? function (e, t, n, r, i, o, s) { let a = e.slice(), l = (e, t, n, r) => { for (let s = 0; s < a.length; s += 3) { let l, c = a[s + 1]; if (c < 0 || e > c + o) continue; let u = a[s] + o; t >= u ? a[s + 1] = e <= u ? -2 : -1 : n >= i && (l = r - n - (t - e)) && (a[s] += l, a[s + 1] += l) } }; for (let e = 0; e < n.maps.length; e++)n.maps[e].forEach(l); let c = !1; for (let t = 0; t < a.length; t += 3)if (a[t + 1] < 0) { if (-2 == a[t + 1]) { c = !0, a[t + 1] = -1; continue } let l = n.map(e[t] + o), u = l - i; if (u < 0 || u >= r.content.size) { c = !0; continue } let d = n.map(e[t + 1] + o, -1) - i, { index: h, offset: p } = r.content.findIndex(u), f = r.maybeChild(h); if (f && p == u && p + f.nodeSize == d) { let r = a[t + 2].mapInner(n, f, l + 1, e[t] + o + 1, s); r != Ic ? (a[t] = u, a[t + 1] = d, a[t + 2] = r) : (a[t + 1] = -2, c = !0) } else c = !0 } if (c) { let l = function (e, t, n, r, i, o, s) { function a(e, t) { for (let o = 0; o < e.local.length; o++) { let a = e.local[o].map(r, i, t); a ? n.push(a) : s.onRemove && s.onRemove(e.local[o].spec) } for (let n = 0; n < e.children.length; n += 3)a(e.children[n + 2], e.children[n] + t + 1) } for (let n = 0; n < e.length; n += 3)-1 == e[n + 1] && a(e[n + 2], t[n] + o + 1); return n }(a, e, t, n, i, o, s), c = Vc(l, r, 0, s); t = c.local; for (let e = 0; e < a.length; e += 3)a[e + 1] < 0 && (a.splice(e, 3), e -= 3); for (let e = 0, t = 0; e < c.children.length; e += 3) { let n = c.children[e]; for (; t < a.length && a[t] < n;)t += 3; a.splice(t, 0, c.children[e], c.children[e + 1], c.children[e + 2]) } } return new Pc(t.sort(Wc), a) }(this.children, o || [], e, t, n, r, i) : o ? new Pc(o.sort(Wc), Rc) : Ic } add(e, t) { return t.length ? this == Ic ? Pc.create(e, t) : this.addInner(e, t, 0) : this } addInner(e, t, n) { let r, i = 0; e.forEach(((e, o) => { let s, a = o + n; if (s = jc(t, e, a)) { for (r || (r = this.children.slice()); i < r.length && r[i] < o;)i += 3; r[i] == o ? r[i + 2] = r[i + 2].addInner(e, s, a + 1) : r.splice(i, 0, o, o + e.nodeSize, Vc(s, e, a + 1, Lc)), i += 3 } })); let o = zc(i ? Hc(t) : t, -n); for (let t = 0; t < o.length; t++)o[t].type.valid(e, o[t]) || o.splice(t--, 1); return new Pc(o.length ? this.local.concat(o).sort(Wc) : this.local, r || this.children) } remove(e) { return 0 == e.length || this == Ic ? this : this.removeInner(e, 0) } removeInner(e, t) { let n = this.children, r = this.local; for (let r = 0; r < n.length; r += 3) { let i, o = n[r] + t, s = n[r + 1] + t; for (let t, n = 0; n < e.length; n++)(t = e[n]) && t.from > o && t.to < s && (e[n] = null, (i || (i = [])).push(t)); if (!i) continue; n == this.children && (n = this.children.slice()); let a = n[r + 2].removeInner(i, o + 1); a != Ic ? n[r + 2] = a : (n.splice(r, 3), r -= 3) } if (r.length) for (let n, i = 0; i < e.length; i++)if (n = e[i]) for (let e = 0; e < r.length; e++)r[e].eq(n, t) && (r == this.local && (r = this.local.slice()), r.splice(e--, 1)); return n == this.children && r == this.local ? this : r.length || n.length ? new Pc(r, n) : Ic } forChild(e, t) { if (this == Ic) return this; if (t.isLeaf) return Pc.empty; let n, r; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] >= e) { this.children[t] == e && (n = this.children[t + 2]); break } let i = e + 1, o = i + t.content.size; for (let e = 0; e < this.local.length; e++) { let t = this.local[e]; if (t.from < o && t.to > i && t.type instanceof Nc) { let e = Math.max(i, t.from) - i, n = Math.min(o, t.to) - i; e < n && (r || (r = [])).push(t.copy(e, n)) } } if (r) { let e = new Pc(r.sort(Wc), Rc); return n ? new $c([e, n]) : e } return n || Ic } eq(e) { if (this == e) return !0; if (!(e instanceof Pc) || this.local.length != e.local.length || this.children.length != e.children.length) return !1; for (let t = 0; t < this.local.length; t++)if (!this.local[t].eq(e.local[t])) return !1; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) return !1; return !0 } locals(e) { return qc(this.localsInner(e)) } localsInner(e) { if (this == Ic) return Rc; if (e.inlineContent || !this.local.some(Nc.is)) return this.local; let t = []; for (let e = 0; e < this.local.length; e++)this.local[e].type instanceof Nc || t.push(this.local[e]); return t } } Pc.empty = new Pc([], []), Pc.removeOverlap = qc; const Ic = Pc.empty; class $c { constructor(e) { this.members = e } map(e, t) { const n = this.members.map((n => n.map(e, t, Lc))); return $c.from(n) } forChild(e, t) { if (t.isLeaf) return Pc.empty; let n = []; for (let r = 0; r < this.members.length; r++) { let i = this.members[r].forChild(e, t); i != Ic && (i instanceof $c ? n = n.concat(i.members) : n.push(i)) } return $c.from(n) } eq(e) { if (!(e instanceof $c) || e.members.length != this.members.length) return !1; for (let t = 0; t < this.members.length; t++)if (!this.members[t].eq(e.members[t])) return !1; return !0 } locals(e) { let t, n = !0; for (let r = 0; r < this.members.length; r++) { let i = this.members[r].localsInner(e); if (i.length) if (t) { n && (t = t.slice(), n = !1); for (let e = 0; e < i.length; e++)t.push(i[e]) } else t = i } return t ? qc(n ? t : t.sort(Wc)) : Rc } static from(e) { switch (e.length) { case 0: return Ic; case 1: return e[0]; default: return new $c(e) } } } function zc(e, t) { if (!t || !e.length) return e; let n = []; for (let r = 0; r < e.length; r++) { let i = e[r]; n.push(new _c(i.from + t, i.to + t, i.type)) } return n } function jc(e, t, n) { if (t.isLeaf) return null; let r = n + t.nodeSize, i = null; for (let t, o = 0; o < e.length; o++)(t = e[o]) && t.from > n && t.to < r && ((i || (i = [])).push(t), e[o] = null); return i } function Hc(e) { let t = []; for (let n = 0; n < e.length; n++)null != e[n] && t.push(e[n]); return t } function Vc(e, t, n, r) { let i = [], o = !1; t.forEach(((t, s) => { let a = jc(e, t, s + n); if (a) { o = !0; let e = Vc(a, t, n + s + 1, r); e != Ic && i.push(s, s + t.nodeSize, e) } })); let s = zc(o ? Hc(e) : e, -n).sort(Wc); for (let e = 0; e < s.length; e++)s[e].type.valid(t, s[e]) || (r.onRemove && r.onRemove(s[e].spec), s.splice(e--, 1)); return s.length || i.length ? new Pc(s, i) : Ic } function Wc(e, t) { return e.from - t.from || e.to - t.to } function qc(e) { let t = e; for (let n = 0; n < t.length - 1; n++) { let r = t[n]; if (r.from != r.to) for (let i = n + 1; i < t.length; i++) { let o = t[i]; if (o.from != r.from) { o.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, o.from), Kc(t, i, r.copy(o.from, r.to))); break } o.to != r.to && (t == e && (t = e.slice()), t[i] = o.copy(o.from, r.to), Kc(t, i + 1, o.copy(r.to, o.to))) } } return t } function Kc(e, t, n) { for (; t < e.length && Wc(n, e[t]) > 0;)t++; e.splice(t, 0, n) } function Jc(e) { let t = []; return e.someProp("decorations", (n => { let r = n(e.state); r && r != Ic && t.push(r) })), e.cursorWrapper && t.push(Pc.create(e.state.doc, [e.cursorWrapper.deco])), $c.from(t) } const Uc = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, Gc = da && ha <= 11; class Xc { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(e) { this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(e) { return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset } } class Yc { constructor(e, t) { this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Xc, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((e => { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); da && ha <= 11 && e.some((e => "childList" == e.type && e.removedNodes.length || "characterData" == e.type && e.oldValue.length > e.target.nodeValue.length)) ? this.flushSoon() : this.flush() })), Gc && (this.onCharData = e => { this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout((() => { this.flushingSoon = -1, this.flush() }), 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && this.observer.observe(this.view.dom, Uc), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let e = this.observer.takeRecords(); if (e.length) { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); window.setTimeout((() => this.flush()), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout((() => this.suppressingSelectionUpdates = !1), 50) } onSelectionChange() { if (Bl(this.view)) { if (this.suppressingSelectionUpdates) return Al(this.view); if (da && ha <= 11 && !this.view.state.selection.empty) { let e = this.view.domSelection(); if (e.focusNode && Sa(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelection()) } ignoreSelectionChange(e) { if (0 == e.rangeCount) return !0; let t = e.getRangeAt(0).commonAncestorContainer, n = this.view.docView.nearestDesc(t); return n && n.ignoreMutation({ type: "selection", target: 3 == t.nodeType ? t.parentNode : t }) ? (this.setCurSelection(), !0) : void 0 } flush() { if (!this.view.docView || this.flushingSoon > -1) return; let e = this.observer ? this.observer.takeRecords() : []; this.queue.length && (e = this.queue.concat(e), this.queue.length = 0); let t = this.view.domSelection(), n = !this.suppressingSelectionUpdates && !this.currentSelection.eq(t) && Bl(this.view) && !this.ignoreSelectionChange(t), r = -1, i = -1, o = !1, s = []; if (this.view.editable) for (let t = 0; t < e.length; t++) { let n = this.registerMutation(e[t], s); n && (r = r < 0 ? n.from : Math.min(n.from, r), i = i < 0 ? n.to : Math.max(n.to, i), n.typeOver && (o = !0)) } if (pa && s.length > 1) { let e = s.filter((e => "BR" == e.nodeName)); if (2 == e.length) { let t = e[0], n = e[1]; t.parentNode && t.parentNode.parentNode == n.parentNode ? n.remove() : t.remove() } } (r > -1 || n) && (r > -1 && (this.view.docView.markDirty(r, i), function (e) { if (Zc) return; Zc = !0, "normal" == getComputedStyle(e.dom).whiteSpace && console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.") }(this.view)), this.handleDOMChange(r, i, o, s), this.view.docView && this.view.docView.dirty ? this.view.updateState(this.view.state) : this.currentSelection.eq(t) || Al(this.view), this.currentSelection.set(t)) } registerMutation(e, t) { if (t.indexOf(e.target) > -1) return null; let n = this.view.docView.nearestDesc(e.target); if ("attributes" == e.type && (n == this.view.docView || "contenteditable" == e.attributeName || "style" == e.attributeName && !e.oldValue && !e.target.getAttribute("style"))) return null; if (!n || n.ignoreMutation(e)) return null; if ("childList" == e.type) { for (let n = 0; n < e.addedNodes.length; n++)t.push(e.addedNodes[n]); if (n.contentDOM && n.contentDOM != n.dom && !n.contentDOM.contains(e.target)) return { from: n.posBefore, to: n.posAfter }; let r = e.previousSibling, i = e.nextSibling; if (da && ha <= 11 && e.addedNodes.length) for (let t = 0; t < e.addedNodes.length; t++) { let { previousSibling: n, nextSibling: o } = e.addedNodes[t]; (!n || Array.prototype.indexOf.call(e.addedNodes, n) < 0) && (r = n), (!o || Array.prototype.indexOf.call(e.addedNodes, o) < 0) && (i = o) } let o = r && r.parentNode == e.target ? Ca(r) + 1 : 0, s = n.localPosFromDOM(e.target, o, -1), a = i && i.parentNode == e.target ? Ca(i) : e.target.childNodes.length; return { from: s, to: n.localPosFromDOM(e.target, a, 1) } } return "attributes" == e.type ? { from: n.posAtStart - n.border, to: n.posAtEnd + n.border } : { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } } } let Zc = !1; function Qc(e) { let t = e.pmViewDesc; if (t) return t.parseRule(); if ("BR" == e.nodeName && e.parentNode) { if (ya && /^(ul|ol)$/i.test(e.parentNode.nodeName)) { let e = document.createElement("div"); return e.appendChild(document.createElement("li")), { skip: e } } if (e.parentNode.lastChild == e || ya && /^(tr|table)$/i.test(e.parentNode.nodeName)) return { ignore: !0 } } else if ("IMG" == e.nodeName && e.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } function eu(e, t, n, r, i) { if (t < 0) { let t = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null, n = Cl(e, t); if (n && !e.state.selection.eq(n)) { let r = e.state.tr.setSelection(n); "pointer" == t ? r.setMeta("pointer", !0) : "key" == t && r.scrollIntoView(), e.dispatch(r) } return } let o = e.state.doc.resolve(t), s = o.sharedDepth(n); t = o.before(s + 1), n = e.state.doc.resolve(n).after(s + 1); let a = e.state.selection, l = function (e, t, n) { let r, { node: i, fromOffset: o, toOffset: s, from: a, to: l } = e.docView.parseRange(t, n), c = e.domSelection(), u = c.anchorNode; if (u && e.dom.contains(1 == u.nodeType ? u : u.parentNode) && (r = [{ node: u, offset: c.anchorOffset }], Na(c) || r.push({ node: c.focusNode, offset: c.focusOffset })), ma && 8 === e.input.lastKeyCode) for (let e = s; e > o; e--) { let t = i.childNodes[e - 1], n = t.pmViewDesc; if ("BR" == t.nodeName && !n) { s = e; break } if (!n || n.size) break } let d = e.state.doc, h = e.someProp("domParser") || $o.fromSchema(e.state.schema), p = d.resolve(a), f = null, m = h.parse(i, { topNode: p.parent, topMatch: p.parent.contentMatchAt(p.index()), topOpen: !0, from: o, to: s, preserveWhitespace: "pre" != p.parent.type.whitespace || "full", findPositions: r, ruleFromNode: Qc, context: p }); if (r && null != r[0].pos) { let e = r[0].pos, t = r[1] && r[1].pos; null == t && (t = e), f = { anchor: e + a, head: t + a } } return { doc: m, sel: f, from: a, to: l } }(e, t, n); if (ma && e.cursorWrapper && l.sel && l.sel.anchor == e.cursorWrapper.deco.from) { let t = e.cursorWrapper.deco.type.toDOM.nextSibling, n = t && t.nodeValue ? t.nodeValue.length : 1; l.sel = { anchor: l.sel.anchor + n, head: l.sel.anchor + n } } let c, u, d = e.state.doc, h = d.slice(l.from, l.to); 8 === e.input.lastKeyCode && Date.now() - 100 < e.input.lastKeyCodeTime ? (c = e.state.selection.to, u = "end") : (c = e.state.selection.from, u = "start"), e.input.lastKeyCode = null; let p = function (e, t, n, r, i) { let o = e.findDiffStart(t, n); if (null == o) return null; let { a: s, b: a } = e.findDiffEnd(t, n + e.size, n + t.size); if ("end" == i) { r -= s + Math.max(0, o - Math.min(s, a)) - o } if (s < o && e.size < t.size) { o -= r <= o && r >= s ? o - r : 0, a = o + (a - s), s = o } else if (a < o) { o -= r <= o && r >= a ? o - r : 0, s = o + (s - a), a = o } return { start: o, endA: s, endB: a } }(h.content, l.doc.content, l.from, c, u); if ((va && e.input.lastIOSEnter > Date.now() - 225 || wa) && i.some((e => "DIV" == e.nodeName || "P" == e.nodeName)) && (!p || p.endA >= p.endB) && e.someProp("handleKeyDown", (t => t(e, Ba(13, "Enter"))))) return void (e.input.lastIOSEnter = 0); if (!p) { if (!(r && a instanceof zs && !a.empty && a.$head.sameParent(a.$anchor)) || e.composing || l.sel && l.sel.anchor != l.sel.head) { if (l.sel) { let t = tu(e, e.state.doc, l.sel); t && !t.eq(e.state.selection) && e.dispatch(e.state.tr.setSelection(t)) } return } p = { start: a.from, endA: a.to, endB: a.to } } e.input.domChangeCount++, e.state.selection.from < e.state.selection.to && p.start == p.endB && e.state.selection instanceof zs && (p.start > e.state.selection.from && p.start <= e.state.selection.from + 2 && e.state.selection.from >= l.from ? p.start = e.state.selection.from : p.endA < e.state.selection.to && p.endA >= e.state.selection.to - 2 && e.state.selection.to <= l.to && (p.endB += e.state.selection.to - p.endA, p.endA = e.state.selection.to)), da && ha <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > l.from && " " == l.doc.textBetween(p.start - l.from - 1, p.start - l.from + 1) && (p.start--, p.endA--, p.endB--); let f, m = l.doc.resolveNoCache(p.start - l.from), g = l.doc.resolveNoCache(p.endB - l.from), y = d.resolve(p.start), v = m.sameParent(g) && m.parent.inlineContent && y.end() >= p.endA; if ((va && e.input.lastIOSEnter > Date.now() - 225 && (!v || i.some((e => "DIV" == e.nodeName || "P" == e.nodeName))) || !v && m.pos < l.doc.content.size && (f = Ls.findFrom(l.doc.resolve(m.pos + 1), 1, !0)) && f.head == g.pos) && e.someProp("handleKeyDown", (t => t(e, Ba(13, "Enter"))))) return void (e.input.lastIOSEnter = 0); if (e.state.selection.anchor > p.start && function (e, t, n, r, i) { if (!r.parent.isTextblock || n - t <= i.pos - r.pos || nu(r, !0, !1) < i.pos) return !1; let o = e.resolve(t); if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock) return !1; let s = e.resolve(nu(o, !0, !0)); return !(!s.parent.isTextblock || s.pos > n || nu(s, !0, !1) < n) && r.parent.content.cut(r.parentOffset).eq(s.parent.content) }(d, p.start, p.endA, m, g) && e.someProp("handleKeyDown", (t => t(e, Ba(8, "Backspace"))))) return void (wa && ma && e.domObserver.suppressSelectionUpdates()); ma && wa && p.endB == p.start && (e.input.lastAndroidDelete = Date.now()), wa && !v && m.start() != g.start() && 0 == g.parentOffset && m.depth == g.depth && l.sel && l.sel.anchor == l.sel.head && l.sel.head == p.endA && (p.endB -= 2, g = l.doc.resolveNoCache(p.endB - l.from), setTimeout((() => { e.someProp("handleKeyDown", (function (t) { return t(e, Ba(13, "Enter")) })) }), 20)); let b, w, D, x = p.start, C = p.endA; if (v) if (m.pos == g.pos) da && ha <= 11 && 0 == m.parentOffset && (e.domObserver.suppressSelectionUpdates(), setTimeout((() => Al(e)), 20)), b = e.state.tr.delete(x, C), w = d.resolve(p.start).marksAcross(d.resolve(p.endA)); else if (p.endA == p.endB && (D = function (e, t) { let n, r, i, o = e.firstChild.marks, s = t.firstChild.marks, a = o, l = s; for (let e = 0; e < s.length; e++)a = s[e].removeFromSet(a); for (let e = 0; e < o.length; e++)l = o[e].removeFromSet(l); if (1 == a.length && 0 == l.length) r = a[0], n = "add", i = e => e.mark(r.addToSet(e.marks)); else { if (0 != a.length || 1 != l.length) return null; r = l[0], n = "remove", i = e => e.mark(r.removeFromSet(e.marks)) } let c = []; for (let e = 0; e < t.childCount; e++)c.push(i(t.child(e))); if (Ui.from(c).eq(e)) return { mark: r, type: n } }(m.parent.content.cut(m.parentOffset, g.parentOffset), y.parent.content.cut(y.parentOffset, p.endA - y.start())))) b = e.state.tr, "add" == D.type ? b.addMark(x, C, D.mark) : b.removeMark(x, C, D.mark); else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) { let t = m.parent.textBetween(m.parentOffset, g.parentOffset); if (e.someProp("handleTextInput", (n => n(e, x, C, t)))) return; b = e.state.tr.insertText(t, x, C) } if (b || (b = e.state.tr.replace(x, C, l.doc.slice(p.start - l.from, p.endB - l.from))), l.sel) { let t = tu(e, b.doc, l.sel); t && !(ma && wa && e.composing && t.empty && (p.start != p.endB || e.input.lastAndroidDelete < Date.now() - 100) && (t.head == x || t.head == b.mapping.map(C) - 1) || da && t.empty && t.head == x) && b.setSelection(t) } w && b.ensureMarks(w), e.dispatch(b.scrollIntoView()) } function tu(e, t, n) { return Math.max(n.anchor, n.head) > t.content.size ? null : Nl(e, t.resolve(n.anchor), t.resolve(n.head)) } function nu(e, t, n) { let r = e.depth, i = t ? e.end() : e.pos; for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount);)r--, i++, t = !1; if (n) { let t = e.node(r).maybeChild(e.indexAfter(r)); for (; t && !t.isLeaf;)t = t.firstChild, i++ } return i } class ru { constructor(e, t) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ac, this.prevDirectPlugins = [], this.pluginViews = [], this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(lu), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : "function" == typeof e ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = su(this), ou(this), this.nodeViews = au(this), this.docView = al(this.state.doc, iu(this), Jc(this), this.dom, this), this.domObserver = new Yc(this, ((e, t, n, r) => eu(this, e, t, n, r))), this.domObserver.start(), function (e) { for (let t in oc) { let n = oc[t]; e.dom.addEventListener(t, e.input.eventHandlers[t] = t => { !dc(e, t) || uc(e, t) || !e.editable && t.type in sc || n(e, t) }) } ya && e.dom.addEventListener("input", (() => null)), cc(e) }(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let e = this._props; this._props = {}; for (let t in e) this._props[t] = e[t]; this._props.state = this.state } return this._props } update(e) { e.handleDOMEvents != this._props.handleDOMEvents && cc(this), this._props = e, e.plugins && (e.plugins.forEach(lu), this.directPlugins = e.plugins), this.updateStateInner(e.state, !0) } setProps(e) { let t = {}; for (let e in this._props) t[e] = this._props[e]; t.state = this.state; for (let n in e) t[n] = e[n]; this.update(t) } updateState(e) { this.updateStateInner(e, this.state.plugins != e.plugins) } updateStateInner(e, t) { let n = this.state, r = !1, i = !1; if (e.storedMarks && this.composing && (kc(this), i = !0), this.state = e, t) { let e = au(this); (function (e, t) { let n = 0, r = 0; for (let r in e) { if (e[r] != t[r]) return !0; n++ } for (let e in t) r++; return n != r })(e, this.nodeViews) && (this.nodeViews = e, r = !0), cc(this) } this.editable = su(this), ou(this); let o = Jc(this), s = iu(this), a = t ? "reset" : e.scrollToSelection > n.scrollToSelection ? "to selection" : "preserve", l = r || !this.docView.matchesNode(e.doc, s, o); !l && e.selection.eq(n.selection) || (i = !0); let c = "preserve" == a && i && null == this.dom.style.overflowAnchor && function (e) { let t, n, r = e.dom.getBoundingClientRect(), i = Math.max(0, r.top); for (let o = (r.left + r.right) / 2, s = i + 1; s < Math.min(innerHeight, r.bottom); s += 5) { let r = e.root.elementFromPoint(o, s); if (!r || r == e.dom || !e.dom.contains(r)) continue; let a = r.getBoundingClientRect(); if (a.top >= i - 20) { t = r, n = a.top; break } } return { refDOM: t, refTop: n, stack: Ia(e.dom) } }(this); if (i) { this.domObserver.stop(); let t = l && (da || ma) && !this.composing && !n.selection.empty && !e.selection.empty && function (e, t) { let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head)); return e.$anchor.start(n) != t.$anchor.start(n) }(n.selection, e.selection); if (l) { let n = ma ? this.trackWrites = this.domSelection().focusNode : null; !r && this.docView.update(e.doc, s, o, this) || (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = al(e.doc, s, o, this.dom, this)), n && !this.trackWrites && (t = !0) } t || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelection()) && function (e) { let t = e.docView.domFromPos(e.state.selection.anchor, 0), n = e.domSelection(); return Sa(t.node, t.offset, n.anchorNode, n.anchorOffset) }(this)) ? Al(this, t) : (Tl(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start() } if (this.updatePluginViews(n), "reset" == a) this.dom.scrollTop = 0; else if ("to selection" == a) { let t = this.domSelection().focusNode; if (this.someProp("handleScrollToSelection", (e => e(this)))); else if (e.selection instanceof Hs) { let n = this.docView.domAfterPos(e.selection.from); 1 == n.nodeType && Pa(this, n.getBoundingClientRect(), t) } else Pa(this, this.coordsAtPos(e.selection.head, 1), t) } else c && function ({ refDOM: e, refTop: t, stack: n }) { let r = e ? e.getBoundingClientRect().top : 0; $a(n, 0 == r ? 0 : r - t) }(c) } destroyPluginViews() { let e; for (; e = this.pluginViews.pop();)e.destroy && e.destroy() } updatePluginViews(e) { if (e && e.plugins == this.state.plugins && this.directPlugins == this.prevDirectPlugins) for (let t = 0; t < this.pluginViews.length; t++) { let n = this.pluginViews[t]; n.update && n.update(this, e) } else { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let e = 0; e < this.directPlugins.length; e++) { let t = this.directPlugins[e]; t.spec.view && this.pluginViews.push(t.spec.view(this)) } for (let e = 0; e < this.state.plugins.length; e++) { let t = this.state.plugins[e]; t.spec.view && this.pluginViews.push(t.spec.view(this)) } } } someProp(e, t) { let n, r = this._props && this._props[e]; if (null != r && (n = t ? t(r) : r)) return n; for (let r = 0; r < this.directPlugins.length; r++) { let i = this.directPlugins[r].props[e]; if (null != i && (n = t ? t(i) : i)) return n } let i = this.state.plugins; if (i) for (let r = 0; r < i.length; r++) { let o = i[r].props[e]; if (null != o && (n = t ? t(o) : o)) return n } } hasFocus() { return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && function (e) { if (e.setActive) return e.setActive(); if (za) return e.focus(za); let t = Ia(e); e.focus(null == za ? { get preventScroll() { return za = { preventScroll: !0 }, !0 } } : void 0), za || (za = !1, $a(t, 0)) }(this.dom), Al(this), this.domObserver.start() } get root() { let e = this._root; if (null == e) for (let e = this.dom.parentNode; e; e = e.parentNode)if (9 == e.nodeType || 11 == e.nodeType && e.host) return e.getSelection || (Object.getPrototypeOf(e).getSelection = () => e.ownerDocument.getSelection()), this._root = e; return e || document } posAtCoords(e) { return Wa(this, e) } coordsAtPos(e, t = 1) { return Ja(this, e, t) } domAtPos(e, t = 0) { return this.docView.domFromPos(e, t) } nodeDOM(e) { let t = this.docView.descAt(e); return t ? t.nodeDOM : null } posAtDOM(e, t, n = -1) { let r = this.docView.posFromDOM(e, t, n); if (null == r) throw new RangeError("DOM position not inside the editor"); return r } endOfTextblock(e, t) { return tl(this, t || this.state, e) } destroy() { this.docView && (!function (e) { e.domObserver.stop(); for (let t in e.input.eventHandlers) e.dom.removeEventListener(t, e.input.eventHandlers[t]); clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout) }(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Jc(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null) } get isDestroyed() { return null == this.docView } dispatchEvent(e) { return function (e, t) { uc(e, t) || !oc[t.type] || !e.editable && t.type in sc || oc[t.type](e, t) }(this, e) } dispatch(e) { let t = this._props.dispatchTransaction; t ? t.call(this, e) : this.updateState(this.state.apply(e)) } domSelection() { return this.root.getSelection() } } function iu(e) { let t = Object.create(null); return t.class = "ProseMirror", t.contenteditable = String(e.editable), t.translate = "no", e.someProp("attributes", (n => { if ("function" == typeof n && (n = n(e.state)), n) for (let e in n) "class" == e && (t.class += " " + n[e]), "style" == e ? t.style = (t.style ? t.style + ";" : "") + n[e] : t[e] || "contenteditable" == e || "nodeName" == e || (t[e] = String(n[e])) })), [_c.node(0, e.state.doc.content.size, t)] } function ou(e) { if (e.markCursor) { let t = document.createElement("img"); t.className = "ProseMirror-separator", t.setAttribute("mark-placeholder", "true"), t.setAttribute("alt", ""), e.cursorWrapper = { dom: t, deco: _c.widget(e.state.selection.head, t, { raw: !0, marks: e.markCursor }) } } else e.cursorWrapper = null } function su(e) { return !e.someProp("editable", (t => !1 === t(e.state))) } function au(e) { let t = Object.create(null); function n(e) { for (let n in e) Object.prototype.hasOwnProperty.call(t, n) || (t[n] = e[n]) } return e.someProp("nodeViews", n), e.someProp("markViews", n), t } function lu(e) { if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } for (var cu = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, uu = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, du = "undefined" != typeof navigator && /Chrome\/(\d+)/.exec(navigator.userAgent), hu = ("undefined" != typeof navigator && /Gecko\/\d+/.test(navigator.userAgent), "undefined" != typeof navigator && /Mac/.test(navigator.platform)), pu = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), fu = hu || du && +du[1] < 57, mu = 0; mu < 10; mu++)cu[48 + mu] = cu[96 + mu] = String(mu); for (mu = 1; mu <= 24; mu++)cu[mu + 111] = "F" + mu; for (mu = 65; mu <= 90; mu++)cu[mu] = String.fromCharCode(mu + 32), uu[mu] = String.fromCharCode(mu); for (var gu in cu) uu.hasOwnProperty(gu) || (uu[gu] = cu[gu]); const yu = "undefined" != typeof navigator && /Mac|iP(hone|[oa]d)/.test(navigator.platform); function vu(e) { let t, n, r, i, o = e.split(/-(?!$)/), s = o[o.length - 1]; "Space" == s && (s = " "); for (let e = 0; e < o.length - 1; e++) { let s = o[e]; if (/^(cmd|meta|m)$/i.test(s)) i = !0; else if (/^a(lt)?$/i.test(s)) t = !0; else if (/^(c|ctrl|control)$/i.test(s)) n = !0; else if (/^s(hift)?$/i.test(s)) r = !0; else { if (!/^mod$/i.test(s)) throw new Error("Unrecognized modifier name: " + s); yu ? i = !0 : n = !0 } } return t && (s = "Alt-" + s), n && (s = "Ctrl-" + s), i && (s = "Meta-" + s), r && (s = "Shift-" + s), s } function bu(e, t, n) { return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), !1 !== n && t.shiftKey && (e = "Shift-" + e), e } function wu(e) { let t = function (e) { let t = Object.create(null); for (let n in e) t[vu(n)] = e[n]; return t }(e); return function (e, n) { let r, i = function (e) { var t = !(fu && (e.ctrlKey || e.altKey || e.metaKey) || pu && e.shiftKey && e.key && 1 == e.key.length || "Unidentified" == e.key) && e.key || (e.shiftKey ? uu : cu)[e.keyCode] || e.key || "Unidentified"; return "Esc" == t && (t = "Escape"), "Del" == t && (t = "Delete"), "Left" == t && (t = "ArrowLeft"), "Up" == t && (t = "ArrowUp"), "Right" == t && (t = "ArrowRight"), "Down" == t && (t = "ArrowDown"), t }(n), o = 1 == i.length && " " != i, s = t[bu(i, n, !o)]; if (s && s(e.state, e.dispatch, e)) return !0; if (o && (n.shiftKey || n.altKey || n.metaKey || i.charCodeAt(0) > 127) && (r = cu[n.keyCode]) && r != i) { let i = t[bu(r, n, !0)]; if (i && i(e.state, e.dispatch, e)) return !0 } else if (o && n.shiftKey) { let r = t[bu(i, n, !0)]; if (r && r(e.state, e.dispatch, e)) return !0 } return !1 } } const Du = (e, t) => !e.selection.empty && (t && t(e.tr.deleteSelection().scrollIntoView()), !0), xu = (e, t, n) => { let { $cursor: r } = e.selection; if (!r || (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0)) return !1; let i = Au(r); if (!i) { let n = r.blockRange(), i = n && ms(n); return null != i && (t && t(e.tr.lift(n, i).scrollIntoView()), !0) } let o = i.nodeBefore; if (!o.type.spec.isolating && Ru(e, i, t)) return !0; if (0 == r.parent.content.size && (Cu(o, "end") || Hs.isSelectable(o))) { let n = xs(e.doc, r.before(), r.after(), eo.empty); if (n && n.slice.size < n.to - n.from) { if (t) { let r = e.tr.step(n); r.setSelection(Cu(o, "end") ? Ls.findFrom(r.doc.resolve(r.mapping.map(i.pos, -1)), -1) : Hs.create(r.doc, i.pos - o.nodeSize)), t(r.scrollIntoView()) } return !0 } } return !(!o.isAtom || i.depth != r.depth - 1) && (t && t(e.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) }; function Cu(e, t, n = !1) { for (let r = e; r; r = "start" == t ? r.firstChild : r.lastChild) { if (r.isTextblock) return !0; if (n && 1 != r.childCount) return !1 } return !1 } const ku = (e, t, n) => { let { $head: r, empty: i } = e.selection, o = r; if (!i) return !1; if (r.parent.isTextblock) { if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0) return !1; o = Au(r) } let s = o && o.nodeBefore; return !(!s || !Hs.isSelectable(s)) && (t && t(e.tr.setSelection(Hs.create(e.doc, o.pos - s.nodeSize)).scrollIntoView()), !0) }; function Au(e) { if (!e.parent.type.spec.isolating) for (let t = e.depth - 1; t >= 0; t--) { if (e.index(t) > 0) return e.doc.resolve(e.before(t + 1)); if (e.node(t).type.spec.isolating) break } return null } const Eu = (e, t, n) => { let { $cursor: r } = e.selection; if (!r || (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size)) return !1; let i = Mu(r); if (!i) return !1; let o = i.nodeAfter; if (Ru(e, i, t)) return !0; if (0 == r.parent.content.size && (Cu(o, "start") || Hs.isSelectable(o))) { let n = xs(e.doc, r.before(), r.after(), eo.empty); if (n && n.slice.size < n.to - n.from) { if (t) { let r = e.tr.step(n); r.setSelection(Cu(o, "start") ? Ls.findFrom(r.doc.resolve(r.mapping.map(i.pos)), 1) : Hs.create(r.doc, r.mapping.map(i.pos))), t(r.scrollIntoView()) } return !0 } } return !(!o.isAtom || i.depth != r.depth - 1) && (t && t(e.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) }, Su = (e, t, n) => { let { $head: r, empty: i } = e.selection, o = r; if (!i) return !1; if (r.parent.isTextblock) { if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size) return !1; o = Mu(r) } let s = o && o.nodeAfter; return !(!s || !Hs.isSelectable(s)) && (t && t(e.tr.setSelection(Hs.create(e.doc, o.pos)).scrollIntoView()), !0) }; function Mu(e) { if (!e.parent.type.spec.isolating) for (let t = e.depth - 1; t >= 0; t--) { let n = e.node(t); if (e.index(t) + 1 < n.childCount) return e.doc.resolve(e.after(t + 1)); if (n.type.spec.isolating) break } return null } const Ou = (e, t) => { let { $head: n, $anchor: r } = e.selection; return !(!n.parent.type.spec.code || !n.sameParent(r)) && (t && t(e.tr.insertText("\n").scrollIntoView()), !0) }; function Tu(e) { for (let t = 0; t < e.edgeCount; t++) { let { type: n } = e.edge(t); if (n.isTextblock && !n.hasRequiredAttrs()) return n } return null } const Fu = (e, t) => { let { $head: n, $anchor: r } = e.selection; if (!n.parent.type.spec.code || !n.sameParent(r)) return !1; let i = n.node(-1), o = n.indexAfter(-1), s = Tu(i.contentMatchAt(o)); if (!s || !i.canReplaceWith(o, o, s)) return !1; if (t) { let r = n.after(), i = e.tr.replaceWith(r, r, s.createAndFill()); i.setSelection(Ls.near(i.doc.resolve(r), 1)), t(i.scrollIntoView()) } return !0 }, Nu = (e, t) => { let n = e.selection, { $from: r, $to: i } = n; if (n instanceof Ws || r.parent.inlineContent || i.parent.inlineContent) return !1; let o = Tu(i.parent.contentMatchAt(i.indexAfter())); if (!o || !o.isTextblock) return !1; if (t) { let n = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, s = e.tr.insert(n, o.createAndFill()); s.setSelection(zs.create(s.doc, n + 1)), t(s.scrollIntoView()) } return !0 }, Bu = (e, t) => { let { $cursor: n } = e.selection; if (!n || n.parent.content.size) return !1; if (n.depth > 1 && n.after() != n.end(-1)) { let r = n.before(); if (vs(e.doc, r)) return t && t(e.tr.split(r).scrollIntoView()), !0 } let r = n.blockRange(), i = r && ms(r); return null != i && (t && t(e.tr.lift(r, i).scrollIntoView()), !0) }, _u = (e, t) => { let { $from: n, $to: r } = e.selection; if (e.selection instanceof Hs && e.selection.node.isBlock) return !(!n.parentOffset || !vs(e.doc, n.pos)) && (t && t(e.tr.split(n.pos).scrollIntoView()), !0); if (!n.parent.isBlock) return !1; if (t) { let i = r.parentOffset == r.parent.content.size, o = e.tr; (e.selection instanceof zs || e.selection instanceof Ws) && o.deleteSelection(); let s = 0 == n.depth ? null : Tu(n.node(-1).contentMatchAt(n.indexAfter(-1))), a = i && s ? [{ type: s }] : void 0, l = vs(o.doc, o.mapping.map(n.pos), 1, a); if (a || l || !vs(o.doc, o.mapping.map(n.pos), 1, s ? [{ type: s }] : void 0) || (s && (a = [{ type: s }]), l = !0), l && (o.split(o.mapping.map(n.pos), 1, a), !i && !n.parentOffset && n.parent.type != s)) { let e = o.mapping.map(n.before()), t = o.doc.resolve(e); s && n.node(-1).canReplaceWith(t.index(), t.index() + 1, s) && o.setNodeMarkup(o.mapping.map(n.before()), s) } t(o.scrollIntoView()) } return !0 }; function Ru(e, t, n) { let r, i, o = t.nodeBefore, s = t.nodeAfter; if (o.type.spec.isolating || s.type.spec.isolating) return !1; if (function (e, t, n) { let r = t.nodeBefore, i = t.nodeAfter, o = t.index(); return !(!(r && i && r.type.compatibleContent(i.type)) || (!r.content.size && t.parent.canReplace(o - 1, o) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), 0) : !t.parent.canReplace(o, o + 1) || !i.isTextblock && !bs(e.doc, t.pos) || (n && n(e.tr.clearIncompatible(t.pos, r.type, r.contentMatchAt(r.childCount)).join(t.pos).scrollIntoView()), 0))) }(e, t, n)) return !0; let a = t.parent.canReplace(t.index(), t.index() + 1); if (a && (r = (i = o.contentMatchAt(o.childCount)).findWrapping(s.type)) && i.matchType(r[0] || s.type).validEnd) { if (n) { let i = t.pos + s.nodeSize, a = Ui.empty; for (let e = r.length - 1; e >= 0; e--)a = Ui.from(r[e].create(null, a)); a = Ui.from(o.copy(a)); let l = e.tr.step(new hs(t.pos - 1, i, t.pos, i, new eo(a, 1, 0), r.length, !0)), c = i + 2 * r.length; bs(l.doc, c) && l.join(c), n(l.scrollIntoView()) } return !0 } let l = Ls.findFrom(t, 1), c = l && l.$from.blockRange(l.$to), u = c && ms(c); if (null != u && u >= t.depth) return n && n(e.tr.lift(c, u).scrollIntoView()), !0; if (a && Cu(s, "start", !0) && Cu(o, "end")) { let r = o, i = []; for (; i.push(r), !r.isTextblock;)r = r.lastChild; let a = s, l = 1; for (; !a.isTextblock; a = a.firstChild)l++; if (r.canReplace(r.childCount, r.childCount, a.content)) { if (n) { let r = Ui.empty; for (let e = i.length - 1; e >= 0; e--)r = Ui.from(i[e].copy(r)); n(e.tr.step(new hs(t.pos - i.length, t.pos + s.nodeSize, t.pos + l, t.pos + s.nodeSize - l, new eo(r, i.length, 0), 0, !0)).scrollIntoView()) } return !0 } } return !1 } function Lu(e) { return function (t, n) { let r = t.selection, i = e < 0 ? r.$from : r.$to, o = i.depth; for (; i.node(o).isInline;) { if (!o) return !1; o-- } return !!i.node(o).isTextblock && (n && n(t.tr.setSelection(zs.create(t.doc, e < 0 ? i.start(o) : i.end(o)))), !0) } } const Pu = Lu(-1), Iu = Lu(1); function $u(e, t = null) { return function (n, r) { let { from: i, to: o } = n.selection, s = !1; return n.doc.nodesBetween(i, o, ((r, i) => { if (s) return !1; if (r.isTextblock && !r.hasMarkup(e, t)) if (r.type == e) s = !0; else { let t = n.doc.resolve(i), r = t.index(); s = t.parent.canReplaceWith(r, r + 1, e) } })), !!s && (r && r(n.tr.setBlockType(i, o, e, t).scrollIntoView()), !0) } } function zu(...e) { return function (t, n, r) { for (let i = 0; i < e.length; i++)if (e[i](t, n, r)) return !0; return !1 } } let ju = zu(Du, xu, ku), Hu = zu(Du, Eu, Su); const Vu = { Enter: zu(Ou, Nu, Bu, _u), "Mod-Enter": Fu, Backspace: ju, "Mod-Backspace": ju, "Shift-Backspace": ju, Delete: Hu, "Mod-Delete": Hu, "Mod-a": (e, t) => (t && t(e.tr.setSelection(new Ws(e.doc))), !0) }, Wu = { "Ctrl-h": Vu.Backspace, "Alt-Backspace": Vu["Mod-Backspace"], "Ctrl-d": Vu.Delete, "Ctrl-Alt-Backspace": Vu["Mod-Delete"], "Alt-Delete": Vu["Mod-Delete"], "Alt-d": Vu["Mod-Delete"], "Ctrl-a": Pu, "Ctrl-e": Iu }; for (let e in Vu) Wu[e] = Vu[e]; "undefined" != typeof navigator ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !("undefined" == typeof os || !os.platform) && os.platform(); function qu(e, t = null) { return function (n, r) { let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = !1, l = s; if (!s) return !1; if (s.depth >= 2 && i.node(s.depth - 1).type.compatibleContent(e) && 0 == s.startIndex) { if (0 == i.index(s.depth - 1)) return !1; let e = n.doc.resolve(s.start - 2); l = new yo(e, e, s.depth), s.endIndex < s.parent.childCount && (s = new yo(i, n.doc.resolve(o.end(s.depth)), s.depth)), a = !0 } let c = gs(l, e, t, s); return !!c && (r && r(function (e, t, n, r, i) { let o = Ui.empty; for (let e = n.length - 1; e >= 0; e--)o = Ui.from(n[e].type.create(n[e].attrs, o)); e.step(new hs(t.start - (r ? 2 : 0), t.end, t.start, t.end, new eo(o, 0, 0), n.length, !0)); let s = 0; for (let e = 0; e < n.length; e++)n[e].type == i && (s = e + 1); let a = n.length - s, l = t.start + n.length - (r ? 2 : 0), c = t.parent; for (let n = t.startIndex, r = t.endIndex, i = !0; n < r; n++, i = !1)!i && vs(e.doc, l, a) && (e.split(l, a), l += 2 * a), l += c.child(n).nodeSize; return e }(n.tr, s, c, a, e).scrollIntoView()), !0) } } function Ku(e) { return function (t, n) { let { $from: r, $to: i } = t.selection, o = r.blockRange(i, (t => t.childCount > 0 && t.firstChild.type == e)); return !!o && (!n || (r.node(o.depth - 1).type == e ? function (e, t, n, r) { let i = e.tr, o = r.end, s = r.$to.end(r.depth); o < s && (i.step(new hs(o - 1, s, o, s, new eo(Ui.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new yo(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth)); return t(i.lift(r, ms(r)).scrollIntoView()), !0 }(t, n, e, o) : function (e, t, n) { let r = e.tr, i = n.parent; for (let e = n.end, t = n.endIndex - 1, o = n.startIndex; t > o; t--)e -= i.child(t).nodeSize, r.delete(e - 1, e + 1); let o = r.doc.resolve(n.start), s = o.nodeAfter; if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize) return !1; let a = 0 == n.startIndex, l = n.endIndex == i.childCount, c = o.node(-1), u = o.index(-1); if (!c.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? Ui.empty : Ui.from(i)))) return !1; let d = o.pos, h = d + s.nodeSize; return r.step(new hs(d - (a ? 1 : 0), h + (l ? 1 : 0), d + 1, h - 1, new eo((a ? Ui.empty : Ui.from(i.copy(Ui.empty))).append(l ? Ui.empty : Ui.from(i.copy(Ui.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), t(r.scrollIntoView()), !0 }(t, n, o))) } } function Ju(e) { const { state: t, transaction: n } = e; let { selection: r } = n, { doc: i } = n, { storedMarks: o } = n; return { ...t, apply: t.apply.bind(t), applyTransaction: t.applyTransaction.bind(t), filterTransaction: t.filterTransaction, plugins: t.plugins, schema: t.schema, reconfigure: t.reconfigure.bind(t), toJSON: t.toJSON.bind(t), get storedMarks() { return o }, get selection() { return r }, get doc() { return i }, get tr() { return r = n.selection, i = n.doc, o = n.storedMarks, n } } } class Uu { constructor(e) { this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state } get hasCustomState() { return !!this.customState } get state() { return this.customState || this.editor.state } get commands() { const { rawCommands: e, editor: t, state: n } = this, { view: r } = t, { tr: i } = n, o = this.buildProps(i); return Object.fromEntries(Object.entries(e).map((([e, t]) => [e, (...e) => { const n = t(...e)(o); return i.getMeta("preventDispatch") || this.hasCustomState || r.dispatch(i), n }]))) } get chain() { return () => this.createChain() } get can() { return () => this.createCan() } createChain(e, t = !0) { const { rawCommands: n, editor: r, state: i } = this, { view: o } = r, s = [], a = !!e, l = e || i.tr, c = { ...Object.fromEntries(Object.entries(n).map((([e, n]) => [e, (...e) => { const r = this.buildProps(l, t), i = n(...e)(r); return s.push(i), c }]))), run: () => (a || !t || l.getMeta("preventDispatch") || this.hasCustomState || o.dispatch(l), s.every((e => !0 === e))) }; return c } createCan(e) { const { rawCommands: t, state: n } = this, r = void 0, i = e || n.tr, o = this.buildProps(i, r), s = Object.fromEntries(Object.entries(t).map((([e, t]) => [e, (...e) => t(...e)({ ...o, dispatch: r })]))); return { ...s, chain: () => this.createChain(i, r) } } buildProps(e, t = !0) { const { rawCommands: n, editor: r, state: i } = this, { view: o } = r; i.storedMarks && e.setStoredMarks(i.storedMarks); const s = { tr: e, editor: r, view: o, state: Ju({ state: i, transaction: e }), dispatch: t ? () => { } : void 0, chain: () => this.createChain(e), can: () => this.createCan(e), get commands() { return Object.fromEntries(Object.entries(n).map((([e, t]) => [e, (...e) => t(...e)(s)]))) } }; return s } } function Gu(e, t, n) { if (void 0 === e.config[t] && e.parent) return Gu(e.parent, t, n); if ("function" == typeof e.config[t]) { return e.config[t].bind({ ...n, parent: e.parent ? Gu(e.parent, t, n) : null }) } return e.config[t] } function Xu(e) { return { baseExtensions: e.filter((e => "extension" === e.type)), nodeExtensions: e.filter((e => "node" === e.type)), markExtensions: e.filter((e => "mark" === e.type)) } } function Yu(e) { const t = [], { nodeExtensions: n, markExtensions: r } = Xu(e), i = [...n, ...r], o = { default: null, rendered: !0, renderHTML: null, parseHTML: null, keepOnSplit: !0, isRequired: !1 }; return e.forEach((e => { const n = Gu(e, "addGlobalAttributes", { name: e.name, options: e.options, storage: e.storage }); if (!n) return; n().forEach((e => { e.types.forEach((n => { Object.entries(e.attributes).forEach((([e, r]) => { t.push({ type: n, name: e, attribute: { ...o, ...r } }) })) })) })) })), i.forEach((e => { const n = { name: e.name, options: e.options, storage: e.storage }, r = Gu(e, "addAttributes", n); if (!r) return; const i = r(); Object.entries(i).forEach((([n, r]) => { const i = { ...o, ...r }; r.isRequired && void 0 === r.default && delete i.default, t.push({ type: e.name, name: n, attribute: i }) })) })), t } function Zu(e, t) { if ("string" == typeof e) { if (!t.nodes[e]) throw Error(`There is no node type named '${e}'. Maybe you forgot to add the extension?`); return t.nodes[e] } return e } function Qu(...e) { return e.filter((e => !!e)).reduce(((e, t) => { const n = { ...e }; return Object.entries(t).forEach((([e, t]) => { n[e] ? n[e] = "class" === e ? [n[e], t].join(" ") : "style" === e ? [n[e], t].join("; ") : t : n[e] = t })), n }), {}) } function ed(e, t) { return t.filter((e => e.attribute.rendered)).map((t => t.attribute.renderHTML ? t.attribute.renderHTML(e.attrs) || {} : { [t.name]: e.attrs[t.name] })).reduce(((e, t) => Qu(e, t)), {}) } function td(e) { return "function" == typeof e } function nd(e, t, ...n) { return td(e) ? t ? e.bind(t)(...n) : e(...n) : e } function rd(e, t) { return e.style ? e : { ...e, getAttrs: n => { const r = e.getAttrs ? e.getAttrs(n) : e.attrs; if (!1 === r) return !1; const i = t.reduce(((e, t) => { const r = t.attribute.parseHTML ? t.attribute.parseHTML(n) : function (e) { return "string" != typeof e ? e : e.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(e) : "true" === e || "false" !== e && e }(n.getAttribute(t.name)); return null == r ? e : { ...e, [t.name]: r } }), {}); return { ...r, ...i } } } } function id(e) { return Object.fromEntries(Object.entries(e).filter((([e, t]) => ("attrs" !== e || !function (e = {}) { return 0 === Object.keys(e).length && e.constructor === Object }(t)) && null != t))) } function od(e) { var t; const n = Yu(e), { nodeExtensions: r, markExtensions: i } = Xu(e), o = null === (t = r.find((e => Gu(e, "topNode")))) || void 0 === t ? void 0 : t.name, s = Object.fromEntries(r.map((t => { const r = n.filter((e => e.type === t.name)), i = { name: t.name, options: t.options, storage: t.storage }, o = id({ ...e.reduce(((e, n) => { const r = Gu(n, "extendNodeSchema", i); return { ...e, ...r ? r(t) : {} } }), {}), content: nd(Gu(t, "content", i)), marks: nd(Gu(t, "marks", i)), group: nd(Gu(t, "group", i)), inline: nd(Gu(t, "inline", i)), atom: nd(Gu(t, "atom", i)), selectable: nd(Gu(t, "selectable", i)), draggable: nd(Gu(t, "draggable", i)), code: nd(Gu(t, "code", i)), defining: nd(Gu(t, "defining", i)), isolating: nd(Gu(t, "isolating", i)), attrs: Object.fromEntries(r.map((e => { var t; return [e.name, { default: null === (t = null == e ? void 0 : e.attribute) || void 0 === t ? void 0 : t.default }] }))) }), s = nd(Gu(t, "parseHTML", i)); s && (o.parseDOM = s.map((e => rd(e, r)))); const a = Gu(t, "renderHTML", i); a && (o.toDOM = e => a({ node: e, HTMLAttributes: ed(e, r) })); const l = Gu(t, "renderText", i); return l && (o.toText = l), [t.name, o] }))), a = Object.fromEntries(i.map((t => { const r = n.filter((e => e.type === t.name)), i = { name: t.name, options: t.options, storage: t.storage }, o = id({ ...e.reduce(((e, n) => { const r = Gu(n, "extendMarkSchema", i); return { ...e, ...r ? r(t) : {} } }), {}), inclusive: nd(Gu(t, "inclusive", i)), excludes: nd(Gu(t, "excludes", i)), group: nd(Gu(t, "group", i)), spanning: nd(Gu(t, "spanning", i)), code: nd(Gu(t, "code", i)), attrs: Object.fromEntries(r.map((e => { var t; return [e.name, { default: null === (t = null == e ? void 0 : e.attribute) || void 0 === t ? void 0 : t.default }] }))) }), s = nd(Gu(t, "parseHTML", i)); s && (o.parseDOM = s.map((e => rd(e, r)))); const a = Gu(t, "renderHTML", i); return a && (o.toDOM = e => a({ mark: e, HTMLAttributes: ed(e, r) })), [t.name, o] }))); return new Po({ topNode: o, nodes: s, marks: a }) } function sd(e, t) { return t.nodes[e] || t.marks[e] || null } function ad(e, t) { return Array.isArray(t) ? t.some((t => ("string" == typeof t ? t : t.name) === e.name)) : t } function ld(e) { return "[object RegExp]" === Object.prototype.toString.call(e) } class cd { constructor(e) { this.find = e.find, this.handler = e.handler } } function ud(e) { var t; const { editor: n, from: r, to: i, text: o, rules: s, plugin: a } = e, { view: l } = n; if (l.composing) return !1; const c = l.state.doc.resolve(r); if (c.parent.type.spec.code || (null === (t = c.nodeBefore || c.nodeAfter) || void 0 === t ? void 0 : t.marks.find((e => e.type.spec.code)))) return !1; let u = !1; const d = ((e, t = 500) => { let n = ""; return e.parent.nodesBetween(Math.max(0, e.parentOffset - t), e.parentOffset, ((t, r, i, o) => { var s, a, l; n += (null === (a = (s = t.type.spec).toText) || void 0 === a ? void 0 : a.call(s, { node: t, pos: r, parent: i, index: o })) || (null === (l = e.nodeBefore) || void 0 === l ? void 0 : l.text) || "%leaf%" })), n })(c) + o; return s.forEach((e => { if (u) return; const t = ((e, t) => { if (ld(t)) return t.exec(e); const n = t(e); if (!n) return null; const r = []; return r.push(n.text), r.index = n.index, r.input = e, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r })(d, e.find); if (!t) return; const s = l.state.tr, c = Ju({ state: l.state, transaction: s }), h = { from: r - (t[0].length - o.length), to: i }, { commands: p, chain: f, can: m } = new Uu({ editor: n, state: c }); null !== e.handler({ state: c, range: h, match: t, commands: p, chain: f, can: m }) && s.steps.length && (s.setMeta(a, { transform: s, from: r, to: i, text: o }), l.dispatch(s), u = !0) })), u } function dd(e) { const { editor: t, rules: n } = e, r = new ta({ state: { init: () => null, apply(e, t) { const n = e.getMeta(r); return n || (e.selectionSet || e.docChanged ? null : t) } }, props: { handleTextInput: (e, i, o, s) => ud({ editor: t, from: i, to: o, text: s, rules: n, plugin: r }), handleDOMEvents: { compositionend: e => (setTimeout((() => { const { $cursor: i } = e.state.selection; i && ud({ editor: t, from: i.pos, to: i.pos, text: "", rules: n, plugin: r }) })), !1) }, handleKeyDown(e, i) { if ("Enter" !== i.key) return !1; const { $cursor: o } = e.state.selection; return !!o && ud({ editor: t, from: o.pos, to: o.pos, text: "\n", rules: n, plugin: r }) } }, isInputRules: !0 }); return r } class hd { constructor(e) { this.find = e.find, this.handler = e.handler } } function pd(e) { const { editor: t, state: n, from: r, to: i, rule: o } = e, { commands: s, chain: a, can: l } = new Uu({ editor: t, state: n }), c = []; n.doc.nodesBetween(r, i, ((e, t) => { if (!e.isTextblock || e.type.spec.code) return; const u = Math.max(r, t), d = Math.min(i, t + e.content.size), h = ((e, t) => { if (ld(t)) return [...e.matchAll(t)]; const n = t(e); return n ? n.map((t => { const n = []; return n.push(t.text), n.index = t.index, n.input = e, n.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), n.push(t.replaceWith)), n })) : [] })(e.textBetween(u - t, d - t, void 0, ""), o.find); h.forEach((e => { if (void 0 === e.index) return; const t = u + e.index + 1, r = t + e[0].length, i = { from: n.tr.mapping.map(t), to: n.tr.mapping.map(r) }, d = o.handler({ state: n, range: i, match: e, commands: s, chain: a, can: l }); c.push(d) })) })); const u = c.every((e => null !== e)); return u } function fd(e) { const { editor: t, rules: n } = e; let r = null, i = !1, o = !1; return n.map((e => new ta({ view(e) { const t = t => { var n; r = (null === (n = e.dom.parentElement) || void 0 === n ? void 0 : n.contains(t.target)) ? e.dom.parentElement : null }; return window.addEventListener("dragstart", t), { destroy() { window.removeEventListener("dragstart", t) } } }, props: { handleDOMEvents: { drop: e => (o = r === e.dom.parentElement, !1), paste: (e, t) => { var n; const r = null === (n = t.clipboardData) || void 0 === n ? void 0 : n.getData("text/html"); return i = !!(null == r ? void 0 : r.includes("data-pm-slice")), !1 } } }, appendTransaction: (n, r, s) => { const a = n[0], l = "paste" === a.getMeta("uiEvent") && !i, c = "drop" === a.getMeta("uiEvent") && !o; if (!l && !c) return; const u = r.doc.content.findDiffStart(s.doc.content), d = r.doc.content.findDiffEnd(s.doc.content); if ("number" != typeof u || !d || u === d.b) return; const h = s.tr, p = Ju({ state: s, transaction: h }); return pd({ editor: t, state: p, from: Math.max(u - 1, 0), to: d.b, rule: e }) && h.steps.length ? h : void 0 } }))) } class md { constructor(e, t) { this.splittableMarks = [], this.editor = t, this.extensions = md.resolve(e), this.schema = od(this.extensions), this.extensions.forEach((e => { var t; this.editor.extensionStorage[e.name] = e.storage; const n = { name: e.name, options: e.options, storage: e.storage, editor: this.editor, type: sd(e.name, this.schema) }; if ("mark" === e.type) { (null === (t = nd(Gu(e, "keepOnSplit", n))) || void 0 === t || t) && this.splittableMarks.push(e.name) } const r = Gu(e, "onBeforeCreate", n); r && this.editor.on("beforeCreate", r); const i = Gu(e, "onCreate", n); i && this.editor.on("create", i); const o = Gu(e, "onUpdate", n); o && this.editor.on("update", o); const s = Gu(e, "onSelectionUpdate", n); s && this.editor.on("selectionUpdate", s); const a = Gu(e, "onTransaction", n); a && this.editor.on("transaction", a); const l = Gu(e, "onFocus", n); l && this.editor.on("focus", l); const c = Gu(e, "onBlur", n); c && this.editor.on("blur", c); const u = Gu(e, "onDestroy", n); u && this.editor.on("destroy", u) })) } static resolve(e) { const t = md.sort(md.flatten(e)), n = function (e) { const t = e.filter(((t, n) => e.indexOf(t) !== n)); return [...new Set(t)] }(t.map((e => e.name))); return n.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${n.map((e => `'${e}'`)).join(", ")}]. This can lead to issues.`), t } static flatten(e) { return e.map((e => { const t = Gu(e, "addExtensions", { name: e.name, options: e.options, storage: e.storage }); return t ? [e, ...this.flatten(t())] : e })).flat(10) } static sort(e) { return e.sort(((e, t) => { const n = Gu(e, "priority") || 100, r = Gu(t, "priority") || 100; return n > r ? -1 : n < r ? 1 : 0 })) } get commands() { return this.extensions.reduce(((e, t) => { const n = Gu(t, "addCommands", { name: t.name, options: t.options, storage: t.storage, editor: this.editor, type: sd(t.name, this.schema) }); return n ? { ...e, ...n() } : e }), {}) } get plugins() { const { editor: e } = this, t = md.sort([...this.extensions].reverse()), n = [], r = [], i = t.map((t => { const i = { name: t.name, options: t.options, storage: t.storage, editor: e, type: sd(t.name, this.schema) }, o = [], s = Gu(t, "addKeyboardShortcuts", i); if (s) { const t = function (e) { return new ta({ props: { handleKeyDown: wu(e) } }) }(Object.fromEntries(Object.entries(s()).map((([t, n]) => [t, () => n({ editor: e })])))); o.push(t) } const a = Gu(t, "addInputRules", i); ad(t, e.options.enableInputRules) && a && n.push(...a()); const l = Gu(t, "addPasteRules", i); ad(t, e.options.enablePasteRules) && l && r.push(...l()); const c = Gu(t, "addProseMirrorPlugins", i); if (c) { const e = c(); o.push(...e) } return o })).flat(); return [dd({ editor: e, rules: n }), ...fd({ editor: e, rules: r }), ...i] } get attributes() { return Yu(this.extensions) } get nodeViews() { const { editor: e } = this, { nodeExtensions: t } = Xu(this.extensions); return Object.fromEntries(t.filter((e => !!Gu(e, "addNodeView"))).map((t => { const n = this.attributes.filter((e => e.type === t.name)), r = { name: t.name, options: t.options, storage: t.storage, editor: e, type: Zu(t.name, this.schema) }, i = Gu(t, "addNodeView", r); if (!i) return []; return [t.name, (r, o, s, a) => { const l = ed(r, n); return i()({ editor: e, node: r, getPos: s, decorations: a, HTMLAttributes: l, extension: t }) }] }))) } } function gd(e) { return "Object" === function (e) { return Object.prototype.toString.call(e).slice(8, -1) }(e) && (e.constructor === Object && Object.getPrototypeOf(e) === Object.prototype) } function yd(e, t) { const n = { ...e }; return gd(e) && gd(t) && Object.keys(t).forEach((r => { gd(t[r]) ? r in e ? n[r] = yd(e[r], t[r]) : Object.assign(n, { [r]: t[r] }) : Object.assign(n, { [r]: t[r] }) })), n } class vd { constructor(e = {}) { this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = nd(Gu(this, "addOptions", { name: this.name }))), this.storage = nd(Gu(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new vd(e) } configure(e = {}) { const t = this.extend(); return t.options = yd(this.options, e), t.storage = nd(Gu(t, "addStorage", { name: t.name, options: t.options })), t } extend(e = {}) { const t = new vd(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = nd(Gu(t, "addOptions", { name: t.name })), t.storage = nd(Gu(t, "addStorage", { name: t.name, options: t.options })), t } } function bd(e, t, n) { const { from: r, to: i } = t, { blockSeparator: o = "\n\n", textSerializers: s = {} } = n || {}; let a = "", l = !0; return e.nodesBetween(r, i, ((e, n, c, u) => { var d; const h = null == s ? void 0 : s[e.type.name]; h ? (e.isBlock && !l && (a += o, l = !0), c && (a += h({ node: e, pos: n, parent: c, index: u, range: t }))) : e.isText ? (a += null === (d = null == e ? void 0 : e.text) || void 0 === d ? void 0 : d.slice(Math.max(r, n) - n, i - n), l = !1) : e.isBlock && !l && (a += o, l = !0) })), a } function wd(e) { return Object.fromEntries(Object.entries(e.nodes).filter((([, e]) => e.spec.toText)).map((([e, t]) => [e, t.spec.toText]))) } const Dd = vd.create({ name: "clipboardTextSerializer", addProseMirrorPlugins() { return [new ta({ key: new ia("clipboardTextSerializer"), props: { clipboardTextSerializer: () => { const { editor: e } = this, { state: t, schema: n } = e, { doc: r, selection: i } = t, { ranges: o } = i, s = Math.min(...o.map((e => e.$from.pos))), a = Math.max(...o.map((e => e.$to.pos))); return bd(r, { from: s, to: a }, { textSerializers: wd(n) }) } } })] } }); function xd(e, t, n = { strict: !0 }) { const r = Object.keys(t); return !r.length || r.every((r => n.strict ? t[r] === e[r] : ld(t[r]) ? t[r].test(e[r]) : t[r] === e[r])) } function Cd(e, t, n = {}) { return e.find((e => e.type === t && xd(e.attrs, n))) } function kd(e, t, n = {}) { return !!Cd(e, t, n) } function Ad(e, t, n = {}) { if (!e || !t) return; let r = e.parent.childAfter(e.parentOffset); if (e.parentOffset === r.offset && 0 !== r.offset && (r = e.parent.childBefore(e.parentOffset)), !r.node) return; const i = Cd([...r.node.marks], t, n); if (!i) return; let o = r.index, s = e.start() + r.offset, a = o + 1, l = s + r.node.nodeSize; for (Cd([...r.node.marks], t, n); o > 0 && i.isInSet(e.parent.child(o - 1).marks);)o -= 1, s -= e.parent.child(o).nodeSize; for (; a < e.parent.childCount && kd([...e.parent.child(a).marks], t, n);)l += e.parent.child(a).nodeSize, a += 1; return { from: s, to: l } } function Ed(e, t) { if ("string" == typeof e) { if (!t.marks[e]) throw Error(`There is no mark type named '${e}'. Maybe you forgot to add the extension?`); return t.marks[e] } return e } function Sd(e) { return e && "object" == typeof e && !Array.isArray(e) && !function (e) { var t; return "class" === (null === (t = e.constructor) || void 0 === t ? void 0 : t.toString().substring(0, 5)) }(e) } function Md(e) { return Sd(e) && e instanceof zs } function Od(e = 0, t = 0, n = 0) { return Math.min(Math.max(e, t), n) } function Td(e, t = null) { if (!t) return null; const n = Ls.atStart(e), r = Ls.atEnd(e); if ("start" === t || !0 === t) return n; if ("end" === t) return r; const i = n.from, o = r.to; return "all" === t ? zs.create(e, Od(0, i, o), Od(e.content.size, i, o)) : zs.create(e, Od(t, i, o), Od(t, i, o)) } function Fd() { return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } function Nd(e) { const t = `<body>${e}</body>`; return (new window.DOMParser).parseFromString(t, "text/html").body } function Bd(e, t, n) { if (n = { slice: !0, parseOptions: {}, ...n }, "object" == typeof e && null !== e) try { return Array.isArray(e) ? Ui.fromArray(e.map((e => t.nodeFromJSON(e)))) : t.nodeFromJSON(e) } catch (r) { return console.warn("[tiptap warn]: Invalid content.", "Passed value:", e, "Error:", r), Bd("", t, n) } if ("string" == typeof e) { const r = $o.fromSchema(t); return n.slice ? r.parseSlice(Nd(e), n.parseOptions).content : r.parse(Nd(e), n.parseOptions) } return Bd("", t, n) } function _d() { return "undefined" != typeof navigator && /Mac/.test(navigator.platform) } function Rd(e, t, n = {}) { const { from: r, to: i, empty: o } = e.selection, s = t ? Zu(t, e.schema) : null, a = []; e.doc.nodesBetween(r, i, ((e, t) => { if (e.isText) return; const n = Math.max(r, t), o = Math.min(i, t + e.nodeSize); a.push({ node: e, from: n, to: o }) })); const l = i - r, c = a.filter((e => !s || s.name === e.node.type.name)).filter((e => xd(e.node.attrs, n, { strict: !1 }))); if (o) return !!c.length; return c.reduce(((e, t) => e + t.to - t.from), 0) >= l } function Ld(e, t) { return t.nodes[e] ? "node" : t.marks[e] ? "mark" : null } function Pd(e, t) { const n = "string" == typeof t ? [t] : t; return Object.keys(e).reduce(((t, r) => (n.includes(r) || (t[r] = e[r]), t)), {}) } function Id(e, t, n = {}) { return Bd(e, t, { slice: !1, parseOptions: n }) } function $d(e, t) { const n = Ed(t, e.schema), { from: r, to: i, empty: o } = e.selection, s = []; o ? (e.storedMarks && s.push(...e.storedMarks), s.push(...e.selection.$head.marks())) : e.doc.nodesBetween(r, i, (e => { s.push(...e.marks) })); const a = s.find((e => e.type.name === n.name)); return a ? { ...a.attrs } : {} } function zd(e, t, n) { return Object.fromEntries(Object.entries(n).filter((([n]) => { const r = e.find((e => e.type === t && e.name === n)); return !!r && r.attribute.keepOnSplit }))) } function jd(e, t) { const n = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks(); if (n) { const r = n.filter((e => null == t ? void 0 : t.includes(e.type.name))); e.tr.ensureMarks(r) } } function Hd(e, t) { for (let n = e.depth; n > 0; n -= 1) { const r = e.node(n); if (t(r)) return { pos: n > 0 ? e.before(n) : 0, start: e.start(n), depth: n, node: r } } } function Vd(e) { return t => Hd(t.$from, e) } function Wd(e, t) { const { nodeExtensions: n } = Xu(t), r = n.find((t => t.name === e)); if (!r) return !1; const i = nd(Gu(r, "group", { name: r.name, options: r.options, storage: r.storage })); return "string" == typeof i && i.split(" ").includes("list") } const qd = (e, t) => { const n = Vd((e => e.type === t))(e.selection); if (!n) return !0; const r = e.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth); if (void 0 === r) return !0; const i = e.doc.nodeAt(r); return n.node.type !== (null == i ? void 0 : i.type) || !bs(e.doc, n.pos) || (e.join(n.pos), !0) }, Kd = (e, t) => { const n = Vd((e => e.type === t))(e.selection); if (!n) return !0; const r = e.doc.resolve(n.start).after(n.depth); if (void 0 === r) return !0; const i = e.doc.nodeAt(r); return n.node.type !== (null == i ? void 0 : i.type) || !bs(e.doc, r) || (e.join(r), !0) }; function Jd(e, t, n = {}) { const { empty: r, ranges: i } = e.selection, o = t ? Ed(t, e.schema) : null; if (r) return !!(e.storedMarks || e.selection.$from.marks()).filter((e => !o || o.name === e.type.name)).find((e => xd(e.attrs, n, { strict: !1 }))); let s = 0; const a = []; if (i.forEach((({ $from: t, $to: n }) => { const r = t.pos, i = n.pos; e.doc.nodesBetween(r, i, ((e, t) => { if (!e.isText && !e.marks.length) return; const n = Math.max(r, t), o = Math.min(i, t + e.nodeSize); s += o - n, a.push(...e.marks.map((e => ({ mark: e, from: n, to: o })))) })) })), 0 === s) return !1; const l = a.filter((e => !o || o.name === e.mark.type.name)).filter((e => xd(e.mark.attrs, n, { strict: !1 }))).reduce(((e, t) => e + t.to - t.from), 0), c = a.filter((e => !o || e.mark.type !== o && e.mark.type.excludes(o))).reduce(((e, t) => e + t.to - t.from), 0); return (l > 0 ? l + c : l) >= s } var Ud = Object.freeze({ __proto__: null, blur: () => ({ editor: e, view: t }) => (requestAnimationFrame((() => { var n; e.isDestroyed || (t.dom.blur(), null === (n = null === window || void 0 === window ? void 0 : window.getSelection()) || void 0 === n || n.removeAllRanges()) })), !0), clearContent: (e = !1) => ({ commands: t }) => t.setContent("", e), clearNodes: () => ({ state: e, tr: t, dispatch: n }) => { const { selection: r } = t, { ranges: i } = r; return !n || (i.forEach((({ $from: n, $to: r }) => { e.doc.nodesBetween(n.pos, r.pos, ((e, n) => { if (e.type.isText) return; const { doc: r, mapping: i } = t, o = r.resolve(i.map(n)), s = r.resolve(i.map(n + e.nodeSize)), a = o.blockRange(s); if (!a) return; const l = ms(a); if (e.type.isTextblock) { const { defaultType: e } = o.parent.contentMatchAt(o.index()); t.setNodeMarkup(a.start, e) } (l || 0 === l) && t.lift(a, l) })) })), !0) }, command: e => t => e(t), createParagraphNear: () => ({ state: e, dispatch: t }) => Nu(e, t), deleteNode: e => ({ tr: t, state: n, dispatch: r }) => { const i = Zu(e, n.schema), o = t.selection.$anchor; for (let e = o.depth; e > 0; e -= 1) { if (o.node(e).type === i) { if (r) { const n = o.before(e), r = o.after(e); t.delete(n, r).scrollIntoView() } return !0 } } return !1 }, deleteRange: e => ({ tr: t, dispatch: n }) => { const { from: r, to: i } = e; return n && t.delete(r, i), !0 }, deleteSelection: () => ({ state: e, dispatch: t }) => Du(e, t), enter: () => ({ commands: e }) => e.keyboardShortcut("Enter"), exitCode: () => ({ state: e, dispatch: t }) => Fu(e, t), extendMarkRange: (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => { const o = Ed(e, r.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: u } = a; if (i) { const e = Ad(l, o, t); if (e && e.from <= c && e.to >= u) { const t = zs.create(s, e.from, e.to); n.setSelection(t) } } return !0 }, first: e => t => { const n = "function" == typeof e ? e(t) : e; for (let e = 0; e < n.length; e += 1)if (n[e](t)) return !0; return !1 }, focus: (e = null, t = {}) => ({ editor: n, view: r, tr: i, dispatch: o }) => { t = { scrollIntoView: !0, ...t }; const s = () => { Fd() && r.dom.focus(), requestAnimationFrame((() => { n.isDestroyed || (r.focus(), (null == t ? void 0 : t.scrollIntoView) && n.commands.scrollIntoView()) })) }; if (r.hasFocus() && null === e || !1 === e) return !0; if (o && null === e && !Md(n.state.selection)) return s(), !0; const a = Td(i.doc, e) || n.state.selection, l = n.state.selection.eq(a); return o && (l || i.setSelection(a), l && i.storedMarks && i.setStoredMarks(i.storedMarks), s()), !0 }, forEach: (e, t) => n => e.every(((e, r) => t(e, { ...n, index: r }))), insertContent: (e, t) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, e, t), insertContentAt: (e, t, n) => ({ tr: r, dispatch: i, editor: o }) => { if (i) { n = { parseOptions: {}, updateSelection: !0, ...n }; const i = Bd(t, o.schema, { parseOptions: { preserveWhitespace: "full", ...n.parseOptions } }); if ("<>" === i.toString()) return !0; let { from: s, to: a } = "number" == typeof e ? { from: e, to: e } : e, l = !0, c = !0; if ((i.toString().startsWith("<") ? i : [i]).forEach((e => { e.check(), l = !!l && (e.isText && 0 === e.marks.length), c = !!c && e.isBlock })), s === a && c) { const { parent: e } = r.doc.resolve(s); e.isTextblock && !e.type.spec.code && !e.childCount && (s -= 1, a += 1) } l ? r.insertText(t, s, a) : r.replaceWith(s, a, i), n.updateSelection && function (e, t, n) { const r = e.steps.length - 1; if (r < t) return; const i = e.steps[r]; if (!(i instanceof ds || i instanceof hs)) return; const o = e.mapping.maps[r]; let s = 0; o.forEach(((e, t, n, r) => { 0 === s && (s = r) })), e.setSelection(Ls.near(e.doc.resolve(s), n)) }(r, r.steps.length - 1, -1) } return !0 }, joinBackward: () => ({ state: e, dispatch: t }) => xu(e, t), joinForward: () => ({ state: e, dispatch: t }) => Eu(e, t), keyboardShortcut: e => ({ editor: t, view: n, tr: r, dispatch: i }) => { const o = function (e) { const t = e.split(/-(?!$)/); let n, r, i, o, s = t[t.length - 1]; "Space" === s && (s = " "); for (let e = 0; e < t.length - 1; e += 1) { const s = t[e]; if (/^(cmd|meta|m)$/i.test(s)) o = !0; else if (/^a(lt)?$/i.test(s)) n = !0; else if (/^(c|ctrl|control)$/i.test(s)) r = !0; else if (/^s(hift)?$/i.test(s)) i = !0; else { if (!/^mod$/i.test(s)) throw new Error(`Unrecognized modifier name: ${s}`); Fd() || _d() ? o = !0 : r = !0 } } return n && (s = `Alt-${s}`), r && (s = `Ctrl-${s}`), o && (s = `Meta-${s}`), i && (s = `Shift-${s}`), s }(e).split(/-(?!$)/), s = o.find((e => !["Alt", "Ctrl", "Meta", "Shift"].includes(e))), a = new KeyboardEvent("keydown", { key: "Space" === s ? " " : s, altKey: o.includes("Alt"), ctrlKey: o.includes("Ctrl"), metaKey: o.includes("Meta"), shiftKey: o.includes("Shift"), bubbles: !0, cancelable: !0 }), l = t.captureTransaction((() => { n.someProp("handleKeyDown", (e => e(n, a))) })); return null == l || l.steps.forEach((e => { const t = e.map(r.mapping); t && i && r.maybeStep(t) })), !0 }, lift: (e, t = {}) => ({ state: n, dispatch: r }) => !!Rd(n, Zu(e, n.schema), t) && ((e, t) => { let { $from: n, $to: r } = e.selection, i = n.blockRange(r), o = i && ms(i); return null != o && (t && t(e.tr.lift(i, o).scrollIntoView()), !0) })(n, r), liftEmptyBlock: () => ({ state: e, dispatch: t }) => Bu(e, t), liftListItem: e => ({ state: t, dispatch: n }) => Ku(Zu(e, t.schema))(t, n), newlineInCode: () => ({ state: e, dispatch: t }) => Ou(e, t), resetAttributes: (e, t) => ({ tr: n, state: r, dispatch: i }) => { let o = null, s = null; const a = Ld("string" == typeof e ? e : e.name, r.schema); return !!a && ("node" === a && (o = Zu(e, r.schema)), "mark" === a && (s = Ed(e, r.schema)), i && n.selection.ranges.forEach((e => { r.doc.nodesBetween(e.$from.pos, e.$to.pos, ((e, r) => { o && o === e.type && n.setNodeMarkup(r, void 0, Pd(e.attrs, t)), s && e.marks.length && e.marks.forEach((i => { s === i.type && n.addMark(r, r + e.nodeSize, s.create(Pd(i.attrs, t))) })) })) })), !0) }, scrollIntoView: () => ({ tr: e, dispatch: t }) => (t && e.scrollIntoView(), !0), selectAll: () => ({ tr: e, commands: t }) => t.setTextSelection({ from: 0, to: e.doc.content.size }), selectNodeBackward: () => ({ state: e, dispatch: t }) => ku(e, t), selectNodeForward: () => ({ state: e, dispatch: t }) => Su(e, t), selectParentNode: () => ({ state: e, dispatch: t }) => ((e, t) => { let n, { $from: r, to: i } = e.selection, o = r.sharedDepth(i); return 0 != o && (n = r.before(o), t && t(e.tr.setSelection(Hs.create(e.doc, n))), !0) })(e, t), selectTextblockEnd: () => ({ state: e, dispatch: t }) => Iu(e, t), selectTextblockStart: () => ({ state: e, dispatch: t }) => Pu(e, t), setContent: (e, t = !1, n = {}) => ({ tr: r, editor: i, dispatch: o }) => { const { doc: s } = r, a = Id(e, i.schema, n); return o && r.replaceWith(0, s.content.size, a).setMeta("preventUpdate", !t), !0 }, setMark: (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => { const { selection: o } = n, { empty: s, ranges: a } = o, l = Ed(e, r.schema); if (i) if (s) { const e = $d(r, l); n.addStoredMark(l.create({ ...e, ...t })) } else a.forEach((e => { const i = e.$from.pos, o = e.$to.pos; r.doc.nodesBetween(i, o, ((e, r) => { const s = Math.max(r, i), a = Math.min(r + e.nodeSize, o); e.marks.find((e => e.type === l)) ? e.marks.forEach((e => { l === e.type && n.addMark(s, a, l.create({ ...e.attrs, ...t })) })) : n.addMark(s, a, l.create(t)) })) })); return !0 }, setMeta: (e, t) => ({ tr: n }) => (n.setMeta(e, t), !0), setNode: (e, t = {}) => ({ state: n, dispatch: r, chain: i }) => { const o = Zu(e, n.schema); return o.isTextblock ? i().command((({ commands: e }) => !!$u(o, t)(n) || e.clearNodes())).command((({ state: e }) => $u(o, t)(e, r))).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1) }, setNodeSelection: e => ({ tr: t, dispatch: n }) => { if (n) { const { doc: n } = t, r = Ls.atStart(n).from, i = Ls.atEnd(n).to, o = Od(e, r, i), s = Hs.create(n, o); t.setSelection(s) } return !0 }, setTextSelection: e => ({ tr: t, dispatch: n }) => { if (n) { const { doc: n } = t, { from: r, to: i } = "number" == typeof e ? { from: e, to: e } : e, o = zs.atStart(n).from, s = zs.atEnd(n).to, a = Od(r, o, s), l = Od(i, o, s), c = zs.create(n, a, l); t.setSelection(c) } return !0 }, sinkListItem: e => ({ state: t, dispatch: n }) => { const r = Zu(e, t.schema); return (i = r, function (e, t) { let { $from: n, $to: r } = e.selection, o = n.blockRange(r, (e => e.childCount > 0 && e.firstChild.type == i)); if (!o) return !1; let s = o.startIndex; if (0 == s) return !1; let a = o.parent, l = a.child(s - 1); if (l.type != i) return !1; if (t) { let n = l.lastChild && l.lastChild.type == a.type, r = Ui.from(n ? i.create() : null), s = new eo(Ui.from(i.create(null, Ui.from(a.type.create(null, r)))), n ? 3 : 1, 0), c = o.start, u = o.end; t(e.tr.step(new hs(c - (n ? 3 : 1), u, c, u, s, 1, !0)).scrollIntoView()) } return !0 })(t, n); var i }, splitBlock: ({ keepMarks: e = !0 } = {}) => ({ tr: t, state: n, dispatch: r, editor: i }) => { const { selection: o, doc: s } = t, { $from: a, $to: l } = o, c = zd(i.extensionManager.attributes, a.node().type.name, a.node().attrs); if (o instanceof Hs && o.node.isBlock) return !(!a.parentOffset || !vs(s, a.pos)) && (r && (e && jd(n, i.extensionManager.splittableMarks), t.split(a.pos).scrollIntoView()), !0); if (!a.parent.isBlock) return !1; if (r) { const r = l.parentOffset === l.parent.content.size; o instanceof zs && t.deleteSelection(); const s = 0 === a.depth ? void 0 : function (e) { for (let t = 0; t < e.edgeCount; t += 1) { const { type: n } = e.edge(t); if (n.isTextblock && !n.hasRequiredAttrs()) return n } return null }(a.node(-1).contentMatchAt(a.indexAfter(-1))); let u = r && s ? [{ type: s, attrs: c }] : void 0, d = vs(t.doc, t.mapping.map(a.pos), 1, u); if (u || d || !vs(t.doc, t.mapping.map(a.pos), 1, s ? [{ type: s }] : void 0) || (d = !0, u = s ? [{ type: s, attrs: c }] : void 0), d && (t.split(t.mapping.map(a.pos), 1, u), s && !r && !a.parentOffset && a.parent.type !== s)) { const e = t.mapping.map(a.before()), n = t.doc.resolve(e); a.node(-1).canReplaceWith(n.index(), n.index() + 1, s) && t.setNodeMarkup(t.mapping.map(a.before()), s) } e && jd(n, i.extensionManager.splittableMarks), t.scrollIntoView() } return !0 }, splitListItem: e => ({ tr: t, state: n, dispatch: r, editor: i }) => { var o; const s = Zu(e, n.schema), { $from: a, $to: l } = n.selection, c = n.selection.node; if (c && c.isBlock || a.depth < 2 || !a.sameParent(l)) return !1; const u = a.node(-1); if (u.type !== s) return !1; const d = i.extensionManager.attributes; if (0 === a.parent.content.size && a.node(-1).childCount === a.indexAfter(-1)) { if (2 === a.depth || a.node(-3).type !== s || a.index(-2) !== a.node(-2).childCount - 1) return !1; if (r) { let e = Ui.empty; const n = a.index(-1) ? 1 : a.index(-2) ? 2 : 3; for (let t = a.depth - n; t >= a.depth - 3; t -= 1)e = Ui.from(a.node(t).copy(e)); const r = a.indexAfter(-1) < a.node(-2).childCount ? 1 : a.indexAfter(-2) < a.node(-3).childCount ? 2 : 3, i = zd(d, a.node().type.name, a.node().attrs), l = (null === (o = s.contentMatch.defaultType) || void 0 === o ? void 0 : o.createAndFill(i)) || void 0; e = e.append(Ui.from(s.createAndFill(null, l) || void 0)); const c = a.before(a.depth - (n - 1)); t.replace(c, a.after(-r), new eo(e, 4 - n, 0)); let u = -1; t.doc.nodesBetween(c, t.doc.content.size, ((e, t) => { if (u > -1) return !1; e.isTextblock && 0 === e.content.size && (u = t + 1) })), u > -1 && t.setSelection(zs.near(t.doc.resolve(u))), t.scrollIntoView() } return !0 } const h = l.pos === a.end() ? u.contentMatchAt(0).defaultType : null, p = zd(d, u.type.name, u.attrs), f = zd(d, a.node().type.name, a.node().attrs); t.delete(a.pos, l.pos); const m = h ? [{ type: s, attrs: p }, { type: h, attrs: f }] : [{ type: s, attrs: p }]; return !!vs(t.doc, a.pos, 2) && (r && t.split(a.pos, 2, m).scrollIntoView(), !0) }, toggleList: (e, t) => ({ editor: n, tr: r, state: i, dispatch: o, chain: s, commands: a, can: l }) => { const { extensions: c } = n.extensionManager, u = Zu(e, i.schema), d = Zu(t, i.schema), { selection: h } = i, { $from: p, $to: f } = h, m = p.blockRange(f); if (!m) return !1; const g = Vd((e => Wd(e.type.name, c)))(h); if (m.depth >= 1 && g && m.depth - g.depth <= 1) { if (g.node.type === u) return a.liftListItem(d); if (Wd(g.node.type.name, c) && u.validContent(g.node.content) && o) return s().command((() => (r.setNodeMarkup(g.pos, u), !0))).command((() => qd(r, u))).command((() => Kd(r, u))).run() } return s().command((() => !!l().wrapInList(u) || a.clearNodes())).wrapInList(u).command((() => qd(r, u))).command((() => Kd(r, u))).run() }, toggleMark: (e, t = {}, n = {}) => ({ state: r, commands: i }) => { const { extendEmptyMarkRange: o = !1 } = n, s = Ed(e, r.schema); return Jd(r, s, t) ? i.unsetMark(s, { extendEmptyMarkRange: o }) : i.setMark(s, t) }, toggleNode: (e, t, n = {}) => ({ state: r, commands: i }) => { const o = Zu(e, r.schema), s = Zu(t, r.schema); return Rd(r, o, n) ? i.setNode(s) : i.setNode(o, n) }, toggleWrap: (e, t = {}) => ({ state: n, commands: r }) => { const i = Zu(e, n.schema); return Rd(n, i, t) ? r.lift(i) : r.wrapIn(i, t) }, undoInputRule: () => ({ state: e, dispatch: t }) => { const n = e.plugins; for (let r = 0; r < n.length; r += 1) { const i = n[r]; let o; if (i.spec.isInputRules && (o = i.getState(e))) { if (t) { const t = e.tr, n = o.transform; for (let e = n.steps.length - 1; e >= 0; e -= 1)t.step(n.steps[e].invert(n.docs[e])); if (o.text) { const n = t.doc.resolve(o.from).marks(); t.replaceWith(o.from, o.to, e.schema.text(o.text, n)) } else t.delete(o.from, o.to) } return !0 } } return !1 }, unsetAllMarks: () => ({ tr: e, dispatch: t }) => { const { selection: n } = e, { empty: r, ranges: i } = n; return r || t && i.forEach((t => { e.removeMark(t.$from.pos, t.$to.pos) })), !0 }, unsetMark: (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => { var o; const { extendEmptyMarkRange: s = !1 } = t, { selection: a } = n, l = Ed(e, r.schema), { $from: c, empty: u, ranges: d } = a; if (!i) return !0; if (u && s) { let { from: e, to: t } = a; const r = null === (o = c.marks().find((e => e.type === l))) || void 0 === o ? void 0 : o.attrs, i = Ad(c, l, r); i && (e = i.from, t = i.to), n.removeMark(e, t, l) } else d.forEach((e => { n.removeMark(e.$from.pos, e.$to.pos, l) })); return n.removeStoredMark(l), !0 }, updateAttributes: (e, t = {}) => ({ tr: n, state: r, dispatch: i }) => { let o = null, s = null; const a = Ld("string" == typeof e ? e : e.name, r.schema); return !!a && ("node" === a && (o = Zu(e, r.schema)), "mark" === a && (s = Ed(e, r.schema)), i && n.selection.ranges.forEach((e => { const i = e.$from.pos, a = e.$to.pos; r.doc.nodesBetween(i, a, ((e, r) => { o && o === e.type && n.setNodeMarkup(r, void 0, { ...e.attrs, ...t }), s && e.marks.length && e.marks.forEach((o => { if (s === o.type) { const l = Math.max(r, i), c = Math.min(r + e.nodeSize, a); n.addMark(l, c, s.create({ ...o.attrs, ...t })) } })) })) })), !0) }, wrapIn: (e, t = {}) => ({ state: n, dispatch: r }) => function (e, t = null) { return function (n, r) { let { $from: i, $to: o } = n.selection, s = i.blockRange(o), a = s && gs(s, e, t); return !!a && (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) } }(Zu(e, n.schema), t)(n, r), wrapInList: (e, t = {}) => ({ state: n, dispatch: r }) => qu(Zu(e, n.schema), t)(n, r) }); const Gd = vd.create({ name: "commands", addCommands: () => ({ ...Ud }) }), Xd = vd.create({ name: "editable", addProseMirrorPlugins() { return [new ta({ key: new ia("editable"), props: { editable: () => this.editor.options.editable } })] } }), Yd = vd.create({ name: "focusEvents", addProseMirrorPlugins() { const { editor: e } = this; return [new ta({ key: new ia("focusEvents"), props: { handleDOMEvents: { focus: (t, n) => { e.isFocused = !0; const r = e.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1); return t.dispatch(r), !1 }, blur: (t, n) => { e.isFocused = !1; const r = e.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1); return t.dispatch(r), !1 } } } })] } }), Zd = vd.create({ name: "keymap", addKeyboardShortcuts() { const e = () => this.editor.commands.first((({ commands: e }) => [() => e.undoInputRule(), () => e.command((({ tr: t }) => { const { selection: n, doc: r } = t, { empty: i, $anchor: o } = n, { pos: s, parent: a } = o, l = Ls.atStart(r).from === s; return !(!(i && l && a.type.isTextblock) || a.textContent.length) && e.clearNodes() })), () => e.deleteSelection(), () => e.joinBackward(), () => e.selectNodeBackward()])), t = () => this.editor.commands.first((({ commands: e }) => [() => e.deleteSelection(), () => e.joinForward(), () => e.selectNodeForward()])), n = { Enter: () => this.editor.commands.first((({ commands: e }) => [() => e.newlineInCode(), () => e.createParagraphNear(), () => e.liftEmptyBlock(), () => e.splitBlock()])), "Mod-Enter": () => this.editor.commands.exitCode(), Backspace: e, "Mod-Backspace": e, "Shift-Backspace": e, Delete: t, "Mod-Delete": t, "Mod-a": () => this.editor.commands.selectAll() }, r = { ...n }, i = { ...n, "Ctrl-h": e, "Alt-Backspace": e, "Ctrl-d": t, "Ctrl-Alt-Backspace": t, "Alt-Delete": t, "Alt-d": t, "Ctrl-a": () => this.editor.commands.selectTextblockStart(), "Ctrl-e": () => this.editor.commands.selectTextblockEnd() }; return Fd() || _d() ? i : r }, addProseMirrorPlugins() { return [new ta({ key: new ia("clearDocument"), appendTransaction: (e, t, n) => { if (!(e.some((e => e.docChanged)) && !t.doc.eq(n.doc))) return; const { empty: r, from: i, to: o } = t.selection, s = Ls.atStart(t.doc).from, a = Ls.atEnd(t.doc).to, l = i === s && o === a, c = 0 === n.doc.textBetween(0, n.doc.content.size, " ", " ").length; if (r || !l || !c) return; const u = n.tr, d = Ju({ state: n, transaction: u }), { commands: h } = new Uu({ editor: this.editor, state: d }); return h.clearNodes(), u.steps.length ? u : void 0 } })] } }), Qd = vd.create({ name: "tabindex", addProseMirrorPlugins() { return [new ta({ key: new ia("tabindex"), props: { attributes: this.editor.isEditable ? { tabindex: "0" } : {} } })] } }); var eh = Object.freeze({ __proto__: null, ClipboardTextSerializer: Dd, Commands: Gd, Editable: Xd, FocusEvents: Yd, Keymap: Zd, Tabindex: Qd }); function th(e, t) { const n = Ld("string" == typeof t ? t : t.name, e.schema); return "node" === n ? function (e, t) { const n = Zu(t, e.schema), { from: r, to: i } = e.selection, o = []; e.doc.nodesBetween(r, i, (e => { o.push(e) })); const s = o.reverse().find((e => e.type.name === n.name)); return s ? { ...s.attrs } : {} }(e, t) : "mark" === n ? $d(e, t) : {} } function nh(e, t) { const n = Go.fromSchema(t).serializeFragment(e), r = document.implementation.createHTMLDocument().createElement("div"); return r.appendChild(n), r.innerHTML } function rh(e, t) { return bd(e, { from: 0, to: e.content.size }, t) } class ih extends class { constructor() { this.callbacks = {} } on(e, t) { return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this } emit(e, ...t) { const n = this.callbacks[e]; return n && n.forEach((e => e.apply(this, t))), this } off(e, t) { const n = this.callbacks[e]; return n && (t ? this.callbacks[e] = n.filter((e => e !== t)) : delete this.callbacks[e]), this } removeAllListeners() { this.callbacks = {} } }{ constructor(e = {}) { super(), this.isFocused = !1, this.extensionStorage = {}, this.options = { element: document.createElement("div"), content: "", injectCSS: !0, injectNonce: void 0, extensions: [], autofocus: !1, editable: !0, editorProps: {}, parseOptions: {}, enableInputRules: !0, enablePasteRules: !0, enableCoreExtensions: !0, onBeforeCreate: () => null, onCreate: () => null, onUpdate: () => null, onSelectionUpdate: () => null, onTransaction: () => null, onFocus: () => null, onBlur: () => null, onDestroy: () => null }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), window.setTimeout((() => { this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this })) }), 0) } get storage() { return this.extensionStorage } get commands() { return this.commandManager.commands } chain() { return this.commandManager.chain() } can() { return this.commandManager.can() } injectCSS() { this.options.injectCSS && document && (this.css = function (e, t) { const n = document.querySelector("style[data-tiptap-style]"); if (null !== n) return n; const r = document.createElement("style"); return t && r.setAttribute("nonce", t), r.setAttribute("data-tiptap-style", ""), r.innerHTML = e, document.getElementsByTagName("head")[0].appendChild(r), r }('.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}', this.options.injectNonce)) } setOptions(e = {}) { this.options = { ...this.options, ...e }, this.view && this.state && !this.isDestroyed && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state)) } setEditable(e) { this.setOptions({ editable: e }) } get isEditable() { return this.options.editable && this.view && this.view.editable } get state() { return this.view.state } registerPlugin(e, t) { const n = td(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], r = this.state.reconfigure({ plugins: n }); this.view.updateState(r) } unregisterPlugin(e) { if (this.isDestroyed) return; const t = "string" == typeof e ? `${e}$` : e.key, n = this.state.reconfigure({ plugins: this.state.plugins.filter((e => !e.key.startsWith(t))) }); this.view.updateState(n) } createExtensionManager() { const e = [...this.options.enableCoreExtensions ? Object.values(eh) : [], ...this.options.extensions].filter((e => ["extension", "node", "mark"].includes(null == e ? void 0 : e.type))); this.extensionManager = new md(e, this) } createCommandManager() { this.commandManager = new Uu({ editor: this }) } createSchema() { this.schema = this.extensionManager.schema } createView() { const e = Id(this.options.content, this.schema, this.options.parseOptions), t = Td(e, this.options.autofocus); this.view = new ru(this.options.element, { ...this.options.editorProps, dispatchTransaction: this.dispatchTransaction.bind(this), state: Qs.create({ doc: e, selection: t || void 0 }) }); const n = this.state.reconfigure({ plugins: this.extensionManager.plugins }); this.view.updateState(n), this.createNodeViews(); this.view.dom.editor = this } createNodeViews() { this.view.setProps({ nodeViews: this.extensionManager.nodeViews }) } captureTransaction(e) { this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1; const t = this.capturedTransaction; return this.capturedTransaction = null, t } dispatchTransaction(e) { if (this.isCapturingTransaction) return this.capturedTransaction ? void e.steps.forEach((e => { var t; return null === (t = this.capturedTransaction) || void 0 === t ? void 0 : t.step(e) })) : void (this.capturedTransaction = e); const t = this.state.apply(e), n = !this.state.selection.eq(t.selection); this.view.updateState(t), this.emit("transaction", { editor: this, transaction: e }), n && this.emit("selectionUpdate", { editor: this, transaction: e }); const r = e.getMeta("focus"), i = e.getMeta("blur"); r && this.emit("focus", { editor: this, event: r.event, transaction: e }), i && this.emit("blur", { editor: this, event: i.event, transaction: e }), e.docChanged && !e.getMeta("preventUpdate") && this.emit("update", { editor: this, transaction: e }) } getAttributes(e) { return th(this.state, e) } isActive(e, t) { const n = "string" == typeof e ? e : null, r = "string" == typeof e ? t : e; return function (e, t, n = {}) { if (!t) return Rd(e, null, n) || Jd(e, null, n); const r = Ld(t, e.schema); return "node" === r ? Rd(e, t, n) : "mark" === r && Jd(e, t, n) }(this.state, n, r) } getJSON() { return this.state.doc.toJSON() } getHTML() { return nh(this.state.doc.content, this.schema) } getText(e) { const { blockSeparator: t = "\n\n", textSerializers: n = {} } = e || {}; return rh(this.state.doc, { blockSeparator: t, textSerializers: { ...n, ...wd(this.schema) } }) } get isEmpty() { return function (e) { var t; const n = null === (t = e.type.createAndFill()) || void 0 === t ? void 0 : t.toJSON(), r = e.toJSON(); return JSON.stringify(n) === JSON.stringify(r) }(this.state.doc) } getCharacterCount() { return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2 } destroy() { this.emit("destroy"), this.view && this.view.destroy(), this.removeAllListeners() } get isDestroyed() { var e; return !(null === (e = this.view) || void 0 === e ? void 0 : e.docView) } } function oh(e) { const t = function (e, t = JSON.stringify) { const n = {}; return e.filter((e => { const r = t(e); return !Object.prototype.hasOwnProperty.call(n, r) && (n[r] = !0) })) }(e); return 1 === t.length ? t : t.filter(((e, n) => { const r = t.filter(((e, t) => t !== n)); return !r.some((t => e.oldRange.from >= t.oldRange.from && e.oldRange.to <= t.oldRange.to && e.newRange.from >= t.newRange.from && e.newRange.to <= t.newRange.to)) })) } function sh(e, t, n) { const r = []; return e === t ? n.resolve(e).marks().forEach((t => { const i = Ad(n.resolve(e - 1), t.type); i && r.push({ mark: t, ...i }) })) : n.nodesBetween(e, t, ((e, t) => { r.push(...e.marks.map((n => ({ from: t, to: t + e.nodeSize, mark: n })))) })), r } function ah(e) { return new cd({ find: e.find, handler: ({ state: t, range: n, match: r }) => { const i = nd(e.getAttributes, void 0, r); if (!1 === i || null === i) return null; const { tr: o } = t, s = r[r.length - 1], a = r[0]; let l = n.to; if (s) { const r = a.search(/\S/), c = n.from + a.indexOf(s), u = c + s.length; if (sh(n.from, n.to, t.doc).filter((t => t.mark.type.excluded.find((n => n === e.type && n !== t.mark.type)))).filter((e => e.to > c)).length) return null; u < n.to && o.delete(u, n.to), c > n.from && o.delete(n.from + r, c), l = n.from + r + s.length, o.addMark(n.from + r, l, e.type.create(i || {})), o.removeStoredMark(e.type) } } }) } function lh(e) { return new cd({ find: e.find, handler: ({ state: t, range: n, match: r }) => { const i = nd(e.getAttributes, void 0, r) || {}, { tr: o } = t, s = n.from; let a = n.to; if (r[1]) { let t = s + r[0].lastIndexOf(r[1]); t > a ? t = a : a = t + r[1].length; const n = r[0][r[0].length - 1]; o.insertText(n, s + r[0].length - 1), o.replaceWith(t, a, e.type.create(i)) } else r[0] && o.replaceWith(s, a, e.type.create(i)) } }) } function ch(e) { return new cd({ find: e.find, handler: ({ state: t, range: n, match: r }) => { const i = t.doc.resolve(n.from), o = nd(e.getAttributes, void 0, r) || {}; if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), e.type)) return null; t.tr.delete(n.from, n.to).setBlockType(n.from, n.from, e.type, o) } }) } function uh(e) { return new cd({ find: e.find, handler: ({ state: t, range: n, match: r }) => { const i = nd(e.getAttributes, void 0, r) || {}, o = t.tr.delete(n.from, n.to), s = o.doc.resolve(n.from).blockRange(), a = s && gs(s, e.type, i); if (!a) return null; o.wrap(s, a); const l = o.doc.resolve(n.from - 1).nodeBefore; l && l.type === e.type && bs(o.doc, n.from - 1) && (!e.joinPredicate || e.joinPredicate(r, l)) && o.join(n.from - 1) } }) } class dh { constructor(e = {}) { this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = nd(Gu(this, "addOptions", { name: this.name }))), this.storage = nd(Gu(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new dh(e) } configure(e = {}) { const t = this.extend(); return t.options = yd(this.options, e), t.storage = nd(Gu(t, "addStorage", { name: t.name, options: t.options })), t } extend(e = {}) { const t = new dh(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = nd(Gu(t, "addOptions", { name: t.name })), t.storage = nd(Gu(t, "addStorage", { name: t.name, options: t.options })), t } } class hh { constructor(e = {}) { this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = nd(Gu(this, "addOptions", { name: this.name }))), this.storage = nd(Gu(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new hh(e) } configure(e = {}) { const t = this.extend(); return t.options = yd(this.options, e), t.storage = nd(Gu(t, "addStorage", { name: t.name, options: t.options })), t } extend(e = {}) { const t = new hh(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = nd(Gu(t, "addOptions", { name: t.name })), t.storage = nd(Gu(t, "addStorage", { name: t.name, options: t.options })), t } } function ph(e) { return new hd({ find: e.find, handler: ({ state: t, range: n, match: r }) => { const i = nd(e.getAttributes, void 0, r); if (!1 === i || null === i) return null; const { tr: o } = t, s = r[r.length - 1], a = r[0]; let l = n.to; if (s) { const r = a.search(/\S/), c = n.from + a.indexOf(s), u = c + s.length; if (sh(n.from, n.to, t.doc).filter((t => t.mark.type.excluded.find((n => n === e.type && n !== t.mark.type)))).filter((e => e.to > c)).length) return null; u < n.to && o.delete(u, n.to), c > n.from && o.delete(n.from + r, c), l = n.from + r + s.length, o.addMark(n.from + r, l, e.type.create(i || {})), o.removeStoredMark(e.type) } } }) } const fh = /^\s*>\s$/, mh = hh.create({ name: "blockquote", addOptions: () => ({ HTMLAttributes: {} }), content: "block+", group: "block", defining: !0, parseHTML: () => [{ tag: "blockquote" }], renderHTML({ HTMLAttributes: e }) { return ["blockquote", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setBlockquote: () => ({ commands: e }) => e.wrapIn(this.name), toggleBlockquote: () => ({ commands: e }) => e.toggleWrap(this.name), unsetBlockquote: () => ({ commands: e }) => e.lift(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() } }, addInputRules() { return [uh({ find: fh, type: this.type })] } }), gh = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/, yh = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g, vh = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/, bh = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g, wh = dh.create({ name: "bold", addOptions: () => ({ HTMLAttributes: {} }), parseHTML: () => [{ tag: "strong" }, { tag: "b", getAttrs: e => "normal" !== e.style.fontWeight && null }, { style: "font-weight", getAttrs: e => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null }], renderHTML({ HTMLAttributes: e }) { return ["strong", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setBold: () => ({ commands: e }) => e.setMark(this.name), toggleBold: () => ({ commands: e }) => e.toggleMark(this.name), unsetBold: () => ({ commands: e }) => e.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-b": () => this.editor.commands.toggleBold(), "Mod-B": () => this.editor.commands.toggleBold() } }, addInputRules() { return [ah({ find: gh, type: this.type }), ah({ find: vh, type: this.type })] }, addPasteRules() { return [ph({ find: yh, type: this.type }), ph({ find: bh, type: this.type })] } }), Dh = /^\s*([-+*])\s$/, xh = hh.create({ name: "bulletList", addOptions: () => ({ itemTypeName: "listItem", HTMLAttributes: {} }), group: "block list", content() { return `${this.options.itemTypeName}+` }, parseHTML: () => [{ tag: "ul" }], renderHTML({ HTMLAttributes: e }) { return ["ul", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { toggleBulletList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName) } }, addKeyboardShortcuts() { return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() } }, addInputRules() { return [uh({ find: Dh, type: this.type })] } }), Ch = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/, kh = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g, Ah = dh.create({ name: "code", addOptions: () => ({ HTMLAttributes: {} }), excludes: "_", code: !0, parseHTML: () => [{ tag: "code" }], renderHTML({ HTMLAttributes: e }) { return ["code", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setCode: () => ({ commands: e }) => e.setMark(this.name), toggleCode: () => ({ commands: e }) => e.toggleMark(this.name), unsetCode: () => ({ commands: e }) => e.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-e": () => this.editor.commands.toggleCode() } }, addInputRules() { return [ah({ find: Ch, type: this.type })] }, addPasteRules() { return [ph({ find: kh, type: this.type })] } }), Eh = /^```([a-z]+)?[\s\n]$/, Sh = /^~~~([a-z]+)?[\s\n]$/, Mh = hh.create({ name: "codeBlock", addOptions: () => ({ languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, HTMLAttributes: {} }), content: "text*", marks: "", group: "block", code: !0, defining: !0, addAttributes() { return { language: { default: null, parseHTML: e => { var t; const { languageClassPrefix: n } = this.options, r = [...(null === (t = e.firstElementChild) || void 0 === t ? void 0 : t.classList) || []].filter((e => e.startsWith(n))).map((e => e.replace(n, "")))[0]; return r || null }, rendered: !1 } } }, parseHTML: () => [{ tag: "pre", preserveWhitespace: "full" }], renderHTML({ node: e, HTMLAttributes: t }) { return ["pre", Qu(this.options.HTMLAttributes, t), ["code", { class: e.attrs.language ? this.options.languageClassPrefix + e.attrs.language : null }, 0]] }, addCommands() { return { setCodeBlock: e => ({ commands: t }) => t.setNode(this.name, e), toggleCodeBlock: e => ({ commands: t }) => t.toggleNode(this.name, "paragraph", e) } }, addKeyboardShortcuts() { return { "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => { const { empty: e, $anchor: t } = this.editor.state.selection, n = 1 === t.pos; return !(!e || t.parent.type.name !== this.name) && (!(!n && t.parent.textContent.length) && this.editor.commands.clearNodes()) }, Enter: ({ editor: e }) => { if (!this.options.exitOnTripleEnter) return !1; const { state: t } = e, { selection: n } = t, { $from: r, empty: i } = n; if (!i || r.parent.type !== this.type) return !1; const o = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith("\n\n"); return !(!o || !s) && e.chain().command((({ tr: e }) => (e.delete(r.pos - 2, r.pos), !0))).exitCode().run() }, ArrowDown: ({ editor: e }) => { if (!this.options.exitOnArrowDown) return !1; const { state: t } = e, { selection: n, doc: r } = t, { $from: i, empty: o } = n; if (!o || i.parent.type !== this.type) return !1; if (!(i.parentOffset === i.parent.nodeSize - 2)) return !1; const s = i.after(); if (void 0 === s) return !1; return !r.nodeAt(s) && e.commands.exitCode() } } }, addInputRules() { return [ch({ find: Eh, type: this.type, getAttributes: e => ({ language: e[1] }) }), ch({ find: Sh, type: this.type, getAttributes: e => ({ language: e[1] }) })] }, addProseMirrorPlugins() { return [new ta({ key: new ia("codeBlockVSCodeHandler"), props: { handlePaste: (e, t) => { if (!t.clipboardData) return !1; if (this.editor.isActive(this.type.name)) return !1; const n = t.clipboardData.getData("text/plain"), r = t.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, o = null == i ? void 0 : i.mode; if (!n || !o) return !1; const { tr: s } = e.state; return s.replaceSelectionWith(this.type.create({ language: o })), s.setSelection(zs.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.insertText(n.replace(/\r\n?/g, "\n")), s.setMeta("paste", !0), e.dispatch(s), !0 } } })] } }), Oh = hh.create({ name: "doc", topNode: !0, content: "block+" }); function Th(e = {}) { return new ta({ view: t => new Fh(t, e) }) } class Fh { constructor(e, t) { this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = t.width || 1, this.color = t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((t => { let n = e => { this[t](e) }; return e.dom.addEventListener(t, n), { name: t, handler: n } })) } destroy() { this.handlers.forEach((({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t))) } update(e, t) { null != this.cursorPos && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay()) } setCursor(e) { e != this.cursorPos && (this.cursorPos = e, null == e ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay()) } updateOverlay() { let e, t = this.editorView.state.doc.resolve(this.cursorPos); if (!t.parent.inlineContent) { let n = t.nodeBefore, r = t.nodeAfter; if (n || r) { let t = this.editorView.nodeDOM(this.cursorPos - (n ? n.nodeSize : 0)).getBoundingClientRect(), i = n ? t.bottom : t.top; n && r && (i = (i + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), e = { left: t.left, right: t.right, top: i - this.width / 2, bottom: i + this.width / 2 } } } if (!e) { let t = this.editorView.coordsAtPos(this.cursorPos); e = { left: t.left - this.width / 2, right: t.left + this.width / 2, top: t.top, bottom: t.bottom } } let n, r, i = this.editorView.dom.offsetParent; if (this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none; background-color: " + this.color), !i || i == document.body && "static" == getComputedStyle(i).position) n = -pageXOffset, r = -pageYOffset; else { let e = i.getBoundingClientRect(); n = e.left - i.scrollLeft, r = e.top - i.scrollTop } this.element.style.left = e.left - n + "px", this.element.style.top = e.top - r + "px", this.element.style.width = e.right - e.left + "px", this.element.style.height = e.bottom - e.top + "px" } scheduleRemoval(e) { clearTimeout(this.timeout), this.timeout = setTimeout((() => this.setCursor(null)), e) } dragover(e) { if (!this.editorView.editable) return; let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), n = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), r = n && n.type.spec.disableDropCursor, i = "function" == typeof r ? r(this.editorView, t) : r; if (t && !i) { let e = t.pos; if (this.editorView.dragging && this.editorView.dragging.slice && (e = Ds(this.editorView.state.doc, e, this.editorView.dragging.slice), null == e)) return this.setCursor(null); this.setCursor(e), this.scheduleRemoval(5e3) } } dragend() { this.scheduleRemoval(20) } drop() { this.scheduleRemoval(20) } dragleave(e) { e.target != this.editorView.dom && this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null) } } const Nh = vd.create({ name: "dropCursor", addOptions: () => ({ color: "currentColor", width: 1, class: void 0 }), addProseMirrorPlugins() { return [Th(this.options)] } }); class Bh extends Ls { constructor(e) { super(e, e) } map(e, t) { let n = e.resolve(t.map(this.head)); return Bh.valid(n) ? new Bh(n) : Ls.near(n) } content() { return eo.empty } eq(e) { return e instanceof Bh && e.head == this.head } toJSON() { return { type: "gapcursor", pos: this.head } } static fromJSON(e, t) { if ("number" != typeof t.pos) throw new RangeError("Invalid input for GapCursor.fromJSON"); return new Bh(e.resolve(t.pos)) } getBookmark() { return new _h(this.anchor) } static valid(e) { let t = e.parent; if (t.isTextblock || !function (e) { for (let t = e.depth; t >= 0; t--) { let n = e.index(t), r = e.node(t); if (0 != n) for (let e = r.child(n - 1); ; e = e.lastChild) { if (0 == e.childCount && !e.inlineContent || e.isAtom || e.type.spec.isolating) return !0; if (e.inlineContent) return !1 } else if (r.type.spec.isolating) return !0 } return !0 }(e) || !function (e) { for (let t = e.depth; t >= 0; t--) { let n = e.indexAfter(t), r = e.node(t); if (n != r.childCount) for (let e = r.child(n); ; e = e.firstChild) { if (0 == e.childCount && !e.inlineContent || e.isAtom || e.type.spec.isolating) return !0; if (e.inlineContent) return !1 } else if (r.type.spec.isolating) return !0 } return !0 }(e)) return !1; let n = t.type.spec.allowGapCursor; if (null != n) return n; let r = t.contentMatchAt(e.index()).defaultType; return r && r.isTextblock } static findGapCursorFrom(e, t, n = !1) { e: for (; ;) { if (!n && Bh.valid(e)) return e; let r = e.pos, i = null; for (let n = e.depth; ; n--) { let o = e.node(n); if (t > 0 ? e.indexAfter(n) < o.childCount : e.index(n) > 0) { i = o.child(t > 0 ? e.indexAfter(n) : e.index(n) - 1); break } if (0 == n) return null; r += t; let s = e.doc.resolve(r); if (Bh.valid(s)) return s } for (; ;) { let o = t > 0 ? i.firstChild : i.lastChild; if (!o) { if (i.isAtom && !i.isText && !Hs.isSelectable(i)) { e = e.doc.resolve(r + i.nodeSize * t), n = !1; continue e } break } i = o, r += t; let s = e.doc.resolve(r); if (Bh.valid(s)) return s } return null } } } Bh.prototype.visible = !1, Bh.findFrom = Bh.findGapCursorFrom, Ls.jsonID("gapcursor", Bh); class _h { constructor(e) { this.pos = e } map(e) { return new _h(e.map(this.pos)) } resolve(e) { let t = e.resolve(this.pos); return Bh.valid(t) ? new Bh(t) : Ls.near(t) } } const Rh = wu({ ArrowLeft: Lh("horiz", -1), ArrowRight: Lh("horiz", 1), ArrowUp: Lh("vert", -1), ArrowDown: Lh("vert", 1) }); function Lh(e, t) { const n = "vert" == e ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left"; return function (e, r, i) { let o = e.selection, s = t > 0 ? o.$to : o.$from, a = o.empty; if (o instanceof zs) { if (!i.endOfTextblock(n) || 0 == s.depth) return !1; a = !1, s = e.doc.resolve(t > 0 ? s.after() : s.before()) } let l = Bh.findGapCursorFrom(s, t, a); return !!l && (r && r(e.tr.setSelection(new Bh(l))), !0) } } function Ph(e, t, n) { if (!e || !e.editable) return !1; let r = e.state.doc.resolve(t); if (!Bh.valid(r)) return !1; let i = e.posAtCoords({ left: n.clientX, top: n.clientY }); return !(i && i.inside > -1 && Hs.isSelectable(e.state.doc.nodeAt(i.inside))) && (e.dispatch(e.state.tr.setSelection(new Bh(r))), !0) } function Ih(e, t) { if ("insertCompositionText" != t.inputType || !(e.state.selection instanceof Bh)) return !1; let { $from: n } = e.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text); if (!r) return !1; let i = Ui.empty; for (let e = r.length - 1; e >= 0; e--)i = Ui.from(r[e].createAndFill(null, i)); let o = e.state.tr.replace(n.pos, n.pos, new eo(i, 0, 0)); return o.setSelection(zs.near(o.doc.resolve(n.pos + 1))), e.dispatch(o), !1 } function $h(e) { if (!(e.selection instanceof Bh)) return null; let t = document.createElement("div"); return t.className = "ProseMirror-gapcursor", Pc.create(e.doc, [_c.widget(e.selection.head, t, { key: "gapcursor" })]) } const zh = vd.create({ name: "gapCursor", addProseMirrorPlugins: () => [new ta({ props: { decorations: $h, createSelectionBetween: (e, t, n) => t.pos == n.pos && Bh.valid(n) ? new Bh(n) : null, handleClick: Ph, handleKeyDown: Rh, handleDOMEvents: { beforeinput: Ih } } })], extendNodeSchema(e) { var t; return { allowGapCursor: null !== (t = nd(Gu(e, "allowGapCursor", { name: e.name, options: e.options, storage: e.storage }))) && void 0 !== t ? t : null } } }), jh = hh.create({ name: "hardBreak", addOptions: () => ({ keepMarks: !0, HTMLAttributes: {} }), inline: !0, group: "inline", selectable: !1, parseHTML: () => [{ tag: "br" }], renderHTML({ HTMLAttributes: e }) { return ["br", Qu(this.options.HTMLAttributes, e)] }, renderText: () => "\n", addCommands() { return { setHardBreak: () => ({ commands: e, chain: t, state: n, editor: r }) => e.first([() => e.exitCode(), () => e.command((() => { const { selection: e, storedMarks: i } = n; if (e.$from.parent.type.spec.isolating) return !1; const { keepMarks: o } = this.options, { splittableMarks: s } = r.extensionManager, a = i || e.$to.parentOffset && e.$from.marks(); return t().insertContent({ type: this.name }).command((({ tr: e, dispatch: t }) => { if (t && a && o) { const t = a.filter((e => s.includes(e.type.name))); e.ensureMarks(t) } return !0 })).run() }))]) } }, addKeyboardShortcuts() { return { "Mod-Enter": () => this.editor.commands.setHardBreak(), "Shift-Enter": () => this.editor.commands.setHardBreak() } } }), Hh = hh.create({ name: "heading", addOptions: () => ({ levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} }), content: "inline*", group: "block", defining: !0, addAttributes: () => ({ level: { default: 1, rendered: !1 } }), parseHTML() { return this.options.levels.map((e => ({ tag: `h${e}`, attrs: { level: e } }))) }, renderHTML({ node: e, HTMLAttributes: t }) { return [`h${this.options.levels.includes(e.attrs.level) ? e.attrs.level : this.options.levels[0]}`, Qu(this.options.HTMLAttributes, t), 0] }, addCommands() { return { setHeading: e => ({ commands: t }) => !!this.options.levels.includes(e.level) && t.setNode(this.name, e), toggleHeading: e => ({ commands: t }) => !!this.options.levels.includes(e.level) && t.toggleNode(this.name, "paragraph", e) } }, addKeyboardShortcuts() { return this.options.levels.reduce(((e, t) => ({ ...e, [`Mod-Alt-${t}`]: () => this.editor.commands.toggleHeading({ level: t }) })), {}) }, addInputRules() { return this.options.levels.map((e => ch({ find: new RegExp(`^(#{1,${e}})\\s$`), type: this.type, getAttributes: { level: e } }))) } }); var Vh = 200, Wh = function () { }; Wh.prototype.append = function (e) { return e.length ? (e = Wh.from(e), !this.length && e || e.length < Vh && this.leafAppend(e) || this.length < Vh && e.leafPrepend(this) || this.appendInner(e)) : this }, Wh.prototype.prepend = function (e) { return e.length ? Wh.from(e).append(this) : this }, Wh.prototype.appendInner = function (e) { return new Kh(this, e) }, Wh.prototype.slice = function (e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.length), e >= t ? Wh.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t)) }, Wh.prototype.get = function (e) { if (!(e < 0 || e >= this.length)) return this.getInner(e) }, Wh.prototype.forEach = function (e, t, n) { void 0 === t && (t = 0), void 0 === n && (n = this.length), t <= n ? this.forEachInner(e, t, n, 0) : this.forEachInvertedInner(e, t, n, 0) }, Wh.prototype.map = function (e, t, n) { void 0 === t && (t = 0), void 0 === n && (n = this.length); var r = []; return this.forEach((function (t, n) { return r.push(e(t, n)) }), t, n), r }, Wh.from = function (e) { return e instanceof Wh ? e : e && e.length ? new qh(e) : Wh.empty }; var qh = function (e) { function t(t) { e.call(this), this.values = t } e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; var n = { length: { configurable: !0 }, depth: { configurable: !0 } }; return t.prototype.flatten = function () { return this.values }, t.prototype.sliceInner = function (e, n) { return 0 == e && n == this.length ? this : new t(this.values.slice(e, n)) }, t.prototype.getInner = function (e) { return this.values[e] }, t.prototype.forEachInner = function (e, t, n, r) { for (var i = t; i < n; i++)if (!1 === e(this.values[i], r + i)) return !1 }, t.prototype.forEachInvertedInner = function (e, t, n, r) { for (var i = t - 1; i >= n; i--)if (!1 === e(this.values[i], r + i)) return !1 }, t.prototype.leafAppend = function (e) { if (this.length + e.length <= Vh) return new t(this.values.concat(e.flatten())) }, t.prototype.leafPrepend = function (e) { if (this.length + e.length <= Vh) return new t(e.flatten().concat(this.values)) }, n.length.get = function () { return this.values.length }, n.depth.get = function () { return 0 }, Object.defineProperties(t.prototype, n), t }(Wh); Wh.empty = new qh([]); var Kh = function (e) { function t(t, n) { e.call(this), this.left = t, this.right = n, this.length = t.length + n.length, this.depth = Math.max(t.depth, n.depth) + 1 } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, t.prototype.getInner = function (e) { return e < this.left.length ? this.left.get(e) : this.right.get(e - this.left.length) }, t.prototype.forEachInner = function (e, t, n, r) { var i = this.left.length; return !(t < i && !1 === this.left.forEachInner(e, t, Math.min(n, i), r)) && (!(n > i && !1 === this.right.forEachInner(e, Math.max(t - i, 0), Math.min(this.length, n) - i, r + i)) && void 0) }, t.prototype.forEachInvertedInner = function (e, t, n, r) { var i = this.left.length; return !(t > i && !1 === this.right.forEachInvertedInner(e, t - i, Math.max(n, i) - i, r + i)) && (!(n < i && !1 === this.left.forEachInvertedInner(e, Math.min(t, i), n, r)) && void 0) }, t.prototype.sliceInner = function (e, t) { if (0 == e && t == this.length) return this; var n = this.left.length; return t <= n ? this.left.slice(e, t) : e >= n ? this.right.slice(e - n, t - n) : this.left.slice(e, n).append(this.right.slice(0, t - n)) }, t.prototype.leafAppend = function (e) { var n = this.right.leafAppend(e); if (n) return new t(this.left, n) }, t.prototype.leafPrepend = function (e) { var n = this.left.leafPrepend(e); if (n) return new t(n, this.right) }, t.prototype.appendInner = function (e) { return this.left.depth >= Math.max(this.right.depth, e.depth) + 1 ? new t(this.left, new t(this.right, e)) : new t(this, e) }, t }(Wh); const Jh = Wh; class Uh { constructor(e, t) { this.items = e, this.eventCount = t } popEvent(e, t) { if (0 == this.eventCount) return null; let n, r, i = this.items.length; for (; ; i--) { if (this.items.get(i - 1).selection) { --i; break } } t && (n = this.remapping(i, this.items.length), r = n.maps.length); let o, s, a = e.tr, l = [], c = []; return this.items.forEach(((e, t) => { if (!e.step) return n || (n = this.remapping(i, t + 1), r = n.maps.length), r--, void c.push(e); if (n) { c.push(new Gh(e.map)); let t, i = e.step.map(n.slice(r)); i && a.maybeStep(i).doc && (t = a.mapping.maps[a.mapping.maps.length - 1], l.push(new Gh(t, void 0, void 0, l.length + c.length))), r--, t && n.appendMap(t, r) } else a.maybeStep(e.step); return e.selection ? (o = n ? e.selection.map(n.slice(r)) : e.selection, s = new Uh(this.items.slice(0, i).append(c.reverse().concat(l)), this.eventCount - 1), !1) : void 0 }), this.items.length, 0), { remaining: s, transform: a, selection: o } } addTransform(e, t, n, r) { let i = [], o = this.eventCount, s = this.items, a = !r && s.length ? s.get(s.length - 1) : null; for (let n = 0; n < e.steps.length; n++) { let l, c = e.steps[n].invert(e.docs[n]), u = new Gh(e.mapping.maps[n], c, t); (l = a && a.merge(u)) && (u = l, n ? i.pop() : s = s.slice(0, s.length - 1)), i.push(u), t && (o++, t = void 0), r || (a = u) } let l = o - n.depth; return l > Yh && (s = function (e, t) { let n; return e.forEach(((e, r) => { if (e.selection && 0 == t--) return n = r, !1 })), e.slice(n) }(s, l), o -= l), new Uh(s.append(i), o) } remapping(e, t) { let n = new rs; return this.items.forEach(((t, r) => { let i = null != t.mirrorOffset && r - t.mirrorOffset >= e ? n.maps.length - t.mirrorOffset : void 0; n.appendMap(t.map, i) }), e, t), n } addMaps(e) { return 0 == this.eventCount ? this : new Uh(this.items.append(e.map((e => new Gh(e)))), this.eventCount) } rebased(e, t) { if (!this.eventCount) return this; let n = [], r = Math.max(0, this.items.length - t), i = e.mapping, o = e.steps.length, s = this.eventCount; this.items.forEach((e => { e.selection && s-- }), r); let a = t; this.items.forEach((t => { let r = i.getMirror(--a); if (null == r) return; o = Math.min(o, r); let l = i.maps[r]; if (t.step) { let o = e.steps[r].invert(e.docs[r]), c = t.selection && t.selection.map(i.slice(a + 1, r)); c && s++, n.push(new Gh(l, o, c)) } else n.push(new Gh(l)) }), r); let l = []; for (let e = t; e < o; e++)l.push(new Gh(i.maps[e])); let c = this.items.slice(0, r).append(l).append(n), u = new Uh(c, s); return u.emptyItemCount() > 500 && (u = u.compress(this.items.length - n.length)), u } emptyItemCount() { let e = 0; return this.items.forEach((t => { t.step || e++ })), e } compress(e = this.items.length) { let t = this.remapping(0, e), n = t.maps.length, r = [], i = 0; return this.items.forEach(((o, s) => { if (s >= e) r.push(o), o.selection && i++; else if (o.step) { let e = o.step.map(t.slice(n)), s = e && e.getMap(); if (n--, s && t.appendMap(s, n), e) { let a = o.selection && o.selection.map(t.slice(n)); a && i++; let l, c = new Gh(s.invert(), e, a), u = r.length - 1; (l = r.length && r[u].merge(c)) ? r[u] = l : r.push(c) } } else o.map && n-- }), this.items.length, 0), new Uh(Jh.from(r.reverse()), i) } } Uh.empty = new Uh(Jh.empty, 0); class Gh { constructor(e, t, n, r) { this.map = e, this.step = t, this.selection = n, this.mirrorOffset = r } merge(e) { if (this.step && e.step && !e.selection) { let t = e.step.merge(this.step); if (t) return new Gh(t.getMap().invert(), t, this.selection) } } } class Xh { constructor(e, t, n, r) { this.done = e, this.undone = t, this.prevRanges = n, this.prevTime = r } } const Yh = 20; function Zh(e) { let t = []; return e.forEach(((e, n, r, i) => t.push(r, i))), t } function Qh(e, t) { if (!e) return null; let n = []; for (let r = 0; r < e.length; r += 2) { let i = t.map(e[r], 1), o = t.map(e[r + 1], -1); i <= o && n.push(i, o) } return n } function ep(e, t, n, r) { let i = rp(t), o = ip.get(t).spec.config, s = (r ? e.undone : e.done).popEvent(t, i); if (!s) return; let a = s.selection.resolve(s.transform.doc), l = (r ? e.done : e.undone).addTransform(s.transform, t.selection.getBookmark(), o, i), c = new Xh(r ? l : s.remaining, r ? s.remaining : l, null, 0); n(s.transform.setSelection(a).setMeta(ip, { redo: r, historyState: c }).scrollIntoView()) } let tp = !1, np = null; function rp(e) { let t = e.plugins; if (np != t) { tp = !1, np = t; for (let e = 0; e < t.length; e++)if (t[e].spec.historyPreserveItems) { tp = !0; break } } return tp } const ip = new ia("history"), op = new ia("closeHistory"); function sp(e = {}) { return e = { depth: e.depth || 100, newGroupDelay: e.newGroupDelay || 500 }, new ta({ key: ip, state: { init: () => new Xh(Uh.empty, Uh.empty, null, 0), apply: (t, n, r) => function (e, t, n, r) { let i, o = n.getMeta(ip); if (o) return o.historyState; n.getMeta(op) && (e = new Xh(e.done, e.undone, null, 0)); let s = n.getMeta("appendedTransaction"); if (0 == n.steps.length) return e; if (s && s.getMeta(ip)) return s.getMeta(ip).redo ? new Xh(e.done.addTransform(n, void 0, r, rp(t)), e.undone, Zh(n.mapping.maps[n.steps.length - 1]), e.prevTime) : new Xh(e.done, e.undone.addTransform(n, void 0, r, rp(t)), null, e.prevTime); if (!1 === n.getMeta("addToHistory") || s && !1 === s.getMeta("addToHistory")) return (i = n.getMeta("rebased")) ? new Xh(e.done.rebased(n, i), e.undone.rebased(n, i), Qh(e.prevRanges, n.mapping), e.prevTime) : new Xh(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), Qh(e.prevRanges, n.mapping), e.prevTime); { let i = 0 == e.prevTime || !s && (e.prevTime < (n.time || 0) - r.newGroupDelay || !function (e, t) { if (!t) return !1; if (!e.docChanged) return !0; let n = !1; return e.mapping.maps[0].forEach(((e, r) => { for (let i = 0; i < t.length; i += 2)e <= t[i + 1] && r >= t[i] && (n = !0) })), n }(n, e.prevRanges)), o = s ? Qh(e.prevRanges, n.mapping) : Zh(n.mapping.maps[n.steps.length - 1]); return new Xh(e.done.addTransform(n, i ? t.selection.getBookmark() : void 0, r, rp(t)), Uh.empty, o, n.time) } }(n, r, t, e) }, config: e, props: { handleDOMEvents: { beforeinput(e, t) { let n = t.inputType, r = "historyUndo" == n ? ap : "historyRedo" == n ? lp : null; return !!r && (t.preventDefault(), r(e.state, e.dispatch)) } } } }) } const ap = (e, t) => { let n = ip.getState(e); return !(!n || 0 == n.done.eventCount) && (t && ep(n, e, t, !1), !0) }, lp = (e, t) => { let n = ip.getState(e); return !(!n || 0 == n.undone.eventCount) && (t && ep(n, e, t, !0), !0) }; const cp = vd.create({ name: "history", addOptions: () => ({ depth: 100, newGroupDelay: 500 }), addCommands: () => ({ undo: () => ({ state: e, dispatch: t }) => ap(e, t), redo: () => ({ state: e, dispatch: t }) => lp(e, t) }), addProseMirrorPlugins() { return [sp(this.options)] }, addKeyboardShortcuts() { return { "Mod-z": () => this.editor.commands.undo(), "Mod-y": () => this.editor.commands.redo(), "Shift-Mod-z": () => this.editor.commands.redo(), "Mod-": () => this.editor.commands.undo(), "Shift-Mod-": () => this.editor.commands.redo() } } }), up = hh.create({ name: "horizontalRule", addOptions: () => ({ HTMLAttributes: {} }), group: "block", parseHTML: () => [{ tag: "hr" }], renderHTML({ HTMLAttributes: e }) { return ["hr", Qu(this.options.HTMLAttributes, e)] }, addCommands() { return { setHorizontalRule: () => ({ chain: e }) => e().insertContent({ type: this.name }).command((({ tr: e, dispatch: t }) => { var n; if (t) { const { $to: t } = e.selection, r = t.end(); if (t.nodeAfter) e.setSelection(zs.create(e.doc, t.pos)); else { const i = null === (n = t.parent.type.contentMatch.defaultType) || void 0 === n ? void 0 : n.create(); i && (e.insert(r, i), e.setSelection(zs.create(e.doc, r))) } e.scrollIntoView() } return !0 })).run() } }, addInputRules() { return [lh({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })] } }), dp = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/, hp = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g, pp = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/, fp = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g, mp = dh.create({ name: "italic", addOptions: () => ({ HTMLAttributes: {} }), parseHTML: () => [{ tag: "em" }, { tag: "i", getAttrs: e => "normal" !== e.style.fontStyle && null }, { style: "font-style=italic" }], renderHTML({ HTMLAttributes: e }) { return ["em", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setItalic: () => ({ commands: e }) => e.setMark(this.name), toggleItalic: () => ({ commands: e }) => e.toggleMark(this.name), unsetItalic: () => ({ commands: e }) => e.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-i": () => this.editor.commands.toggleItalic(), "Mod-I": () => this.editor.commands.toggleItalic() } }, addInputRules() { return [ah({ find: dp, type: this.type }), ah({ find: pp, type: this.type })] }, addPasteRules() { return [ph({ find: hp, type: this.type }), ph({ find: fp, type: this.type })] } }), gp = hh.create({ name: "listItem", addOptions: () => ({ HTMLAttributes: {} }), content: "paragraph block*", defining: !0, parseHTML: () => [{ tag: "li" }], renderHTML({ HTMLAttributes: e }) { return ["li", Qu(this.options.HTMLAttributes, e), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), yp = /^(\d+)\.\s$/, vp = hh.create({ name: "orderedList", addOptions: () => ({ itemTypeName: "listItem", HTMLAttributes: {} }), group: "block list", content() { return `${this.options.itemTypeName}+` }, addAttributes: () => ({ start: { default: 1, parseHTML: e => e.hasAttribute("start") ? parseInt(e.getAttribute("start") || "", 10) : 1 } }), parseHTML: () => [{ tag: "ol" }], renderHTML({ HTMLAttributes: e }) { const { start: t, ...n } = e; return 1 === t ? ["ol", Qu(this.options.HTMLAttributes, n), 0] : ["ol", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { toggleOrderedList: () => ({ commands: e }) => e.toggleList(this.name, this.options.itemTypeName) } }, addKeyboardShortcuts() { return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() } }, addInputRules() { return [uh({ find: yp, type: this.type, getAttributes: e => ({ start: +e[1] }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1] })] } }), bp = hh.create({ name: "paragraph", priority: 1e3, addOptions: () => ({ HTMLAttributes: {} }), group: "block", content: "inline*", parseHTML: () => [{ tag: "p" }], renderHTML({ HTMLAttributes: e }) { return ["p", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setParagraph: () => ({ commands: e }) => e.setNode(this.name) } }, addKeyboardShortcuts() { return { "Mod-Alt-0": () => this.editor.commands.setParagraph() } } }), wp = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/, Dp = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g, xp = dh.create({ name: "strike", addOptions: () => ({ HTMLAttributes: {} }), parseHTML: () => [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: !1, getAttrs: e => !!e.includes("line-through") && {} }], renderHTML({ HTMLAttributes: e }) { return ["s", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setStrike: () => ({ commands: e }) => e.setMark(this.name), toggleStrike: () => ({ commands: e }) => e.toggleMark(this.name), unsetStrike: () => ({ commands: e }) => e.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-x": () => this.editor.commands.toggleStrike() } }, addInputRules() { return [ah({ find: wp, type: this.type })] }, addPasteRules() { return [ph({ find: Dp, type: this.type })] } }), Cp = hh.create({ name: "text", group: "inline" }), kp = vd.create({ name: "starterKit", addExtensions() { var e, t, n, r, i, o, s, a, l, c, u, d, h, p, f, m, g, y; const v = []; return !1 !== this.options.blockquote && v.push(mh.configure(null === (e = this.options) || void 0 === e ? void 0 : e.blockquote)), !1 !== this.options.bold && v.push(wh.configure(null === (t = this.options) || void 0 === t ? void 0 : t.bold)), !1 !== this.options.bulletList && v.push(xh.configure(null === (n = this.options) || void 0 === n ? void 0 : n.bulletList)), !1 !== this.options.code && v.push(Ah.configure(null === (r = this.options) || void 0 === r ? void 0 : r.code)), !1 !== this.options.codeBlock && v.push(Mh.configure(null === (i = this.options) || void 0 === i ? void 0 : i.codeBlock)), !1 !== this.options.document && v.push(Oh.configure(null === (o = this.options) || void 0 === o ? void 0 : o.document)), !1 !== this.options.dropcursor && v.push(Nh.configure(null === (s = this.options) || void 0 === s ? void 0 : s.dropcursor)), !1 !== this.options.gapcursor && v.push(zh.configure(null === (a = this.options) || void 0 === a ? void 0 : a.gapcursor)), !1 !== this.options.hardBreak && v.push(jh.configure(null === (l = this.options) || void 0 === l ? void 0 : l.hardBreak)), !1 !== this.options.heading && v.push(Hh.configure(null === (c = this.options) || void 0 === c ? void 0 : c.heading)), !1 !== this.options.history && v.push(cp.configure(null === (u = this.options) || void 0 === u ? void 0 : u.history)), !1 !== this.options.horizontalRule && v.push(up.configure(null === (d = this.options) || void 0 === d ? void 0 : d.horizontalRule)), !1 !== this.options.italic && v.push(mp.configure(null === (h = this.options) || void 0 === h ? void 0 : h.italic)), !1 !== this.options.listItem && v.push(gp.configure(null === (p = this.options) || void 0 === p ? void 0 : p.listItem)), !1 !== this.options.orderedList && v.push(vp.configure(null === (f = this.options) || void 0 === f ? void 0 : f.orderedList)), !1 !== this.options.paragraph && v.push(bp.configure(null === (m = this.options) || void 0 === m ? void 0 : m.paragraph)), !1 !== this.options.strike && v.push(xp.configure(null === (g = this.options) || void 0 === g ? void 0 : g.strike)), !1 !== this.options.text && v.push(Cp.configure(null === (y = this.options) || void 0 === y ? void 0 : y.text)), v } }); function Ap(e) { this.j = {}, this.jr = [], this.jd = null, this.t = e } Ap.prototype = { accepts: function () { return !!this.t }, tt: function (e, t) { if (t && t.j) return this.j[e] = t, t; var n = t, r = this.j[e]; if (r) return n && (r.t = n), r; r = Ep(); var i = Tp(this, e); return i ? (Object.assign(r.j, i.j), r.jr.append(i.jr), r.jr = i.jd, r.t = n || i.t) : r.t = n, this.j[e] = r, r } }; var Ep = function () { return new Ap }, Sp = function (e) { return new Ap(e) }, Mp = function (e, t, n) { e.j[t] || (e.j[t] = n) }, Op = function (e, t, n) { e.jr.push([t, n]) }, Tp = function (e, t) { var n = e.j[t]; if (n) return n; for (var r = 0; r < e.jr.length; r++) { var i = e.jr[r][0], o = e.jr[r][1]; if (i.test(t)) return o } return e.jd }, Fp = function (e, t, n) { for (var r = 0; r < t.length; r++)Mp(e, t[r], n) }, Np = function (e, t) { for (var n = 0; n < t.length; n++) { var r = t[n][0], i = t[n][1]; Mp(e, r, i) } }, Bp = function (e, t, n, r) { for (var i, o = 0, s = t.length; o < s && (i = e.j[t[o]]);)e = i, o++; if (o >= s) return []; for (; o < s - 1;)i = r(), Mp(e, t[o], i), e = i, o++; Mp(e, t[s - 1], n) }, _p = "DOMAIN", Rp = "LOCALHOST", Lp = "TLD", Pp = "NUM", Ip = "PROTOCOL", $p = "MAILTO", zp = "WS", jp = "NL", Hp = "OPENBRACE", Vp = "OPENBRACKET", Wp = "OPENANGLEBRACKET", qp = "OPENPAREN", Kp = "CLOSEBRACE", Jp = "CLOSEBRACKET", Up = "CLOSEANGLEBRACKET", Gp = "CLOSEPAREN", Xp = "AMPERSAND", Yp = "APOSTROPHE", Zp = "ASTERISK", Qp = "AT", ef = "BACKSLASH", tf = "BACKTICK", nf = "CARET", rf = "COLON", of = "COMMA", sf = "DOLLAR", af = "DOT", lf = "EQUALS", cf = "EXCLAMATION", uf = "HYPHEN", df = "PERCENT", hf = "PIPE", pf = "PLUS", ff = "POUND", mf = "QUERY", gf = "QUOTE", yf = "SEMI", vf = "SLASH", bf = "TILDE", wf = "UNDERSCORE", Df = "SYM", xf = Object.freeze({ __proto__: null, DOMAIN: _p, LOCALHOST: Rp, TLD: Lp, NUM: Pp, PROTOCOL: Ip, MAILTO: $p, WS: zp, NL: jp, OPENBRACE: Hp, OPENBRACKET: Vp, OPENANGLEBRACKET: Wp, OPENPAREN: qp, CLOSEBRACE: Kp, CLOSEBRACKET: Jp, CLOSEANGLEBRACKET: Up, CLOSEPAREN: Gp, AMPERSAND: Xp, APOSTROPHE: Yp, ASTERISK: Zp, AT: Qp, BACKSLASH: ef, BACKTICK: tf, CARET: nf, COLON: rf, COMMA: of, DOLLAR: sf, DOT: af, EQUALS: lf, EXCLAMATION: cf, HYPHEN: uf, PERCENT: df, PIPE: hf, PLUS: pf, POUND: ff, QUERY: mf, QUOTE: gf, SEMI: yf, SLASH: vf, TILDE: bf, UNDERSCORE: wf, SYM: Df }), Cf = "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw vermgensberater-ctb vermgensberatung-pwb                                                                                                                                                        ".split(" "), kf = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/, Af = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/, Ef = /\uFE0F/, Sf = /\d/, Mf = /\s/; function Of() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = Ep(), n = Sp(Pp), r = Sp(_p), i = Ep(), o = Sp(zp), s = [[Sf, r], [kf, r], [Af, r], [Ef, r]], a = function () { var e = Sp(_p); return e.j = { "-": i }, e.jr = [].concat(s), e }, l = function (e) { var t = a(); return t.t = e, t }; Np(t, [["'", Sp(Yp)], ["{", Sp(Hp)], ["[", Sp(Vp)], ["<", Sp(Wp)], ["(", Sp(qp)], ["}", Sp(Kp)], ["]", Sp(Jp)], [">", Sp(Up)], [")", Sp(Gp)], ["&", Sp(Xp)], ["*", Sp(Zp)], ["@", Sp(Qp)], ["`", Sp(tf)], ["^", Sp(nf)], [":", Sp(rf)], [",", Sp(of)], ["$", Sp(sf)], [".", Sp(af)], ["=", Sp(lf)], ["!", Sp(cf)], ["-", Sp(uf)], ["%", Sp(df)], ["|", Sp(hf)], ["+", Sp(pf)], ["#", Sp(ff)], ["?", Sp(mf)], ['"', Sp(gf)], ["/", Sp(vf)], [";", Sp(yf)], ["~", Sp(bf)], ["_", Sp(wf)], ["\\", Sp(ef)]]), Mp(t, "\n", Sp(jp)), Op(t, Mf, o), Mp(o, "\n", Ep()), Op(o, Mf, o); for (var c = 0; c < Cf.length; c++)Bp(t, Cf[c], l(Lp), a); var u = a(), d = a(), h = a(), p = a(); Bp(t, "file", u, a), Bp(t, "ftp", d, a), Bp(t, "http", h, a), Bp(t, "mailto", p, a); var f = a(), m = Sp(Ip), g = Sp($p); Mp(d, "s", f), Mp(d, ":", m), Mp(h, "s", f), Mp(h, ":", m), Mp(u, ":", m), Mp(f, ":", m), Mp(p, ":", g); for (var y = a(), v = 0; v < e.length; v++)Bp(t, e[v], y, a); return Mp(y, ":", m), Bp(t, "localhost", l(Rp), a), Op(t, Sf, n), Op(t, kf, r), Op(t, Af, r), Op(t, Ef, r), Op(n, Sf, n), Op(n, kf, r), Op(n, Af, r), Op(n, Ef, r), Mp(n, "-", i), Mp(r, "-", i), Mp(i, "-", i), Op(r, Sf, r), Op(r, kf, r), Op(r, Af, r), Op(r, Ef, r), Op(i, Sf, r), Op(i, kf, r), Op(i, Af, r), Op(i, Ef, r), t.jd = Sp(Df), t } function Tf(e) { return Tf = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) { return typeof e } : function (e) { return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e }, Tf(e) } var Ff = { defaultProtocol: "http", events: null, format: Bf, formatHref: Bf, nl2br: !1, tagName: "a", target: null, rel: null, validate: !0, truncate: 0, className: null, attributes: null, ignoreTags: [] }; function Nf(e) { e = e || {}, this.defaultProtocol = "defaultProtocol" in e ? e.defaultProtocol : Ff.defaultProtocol, this.events = "events" in e ? e.events : Ff.events, this.format = "format" in e ? e.format : Ff.format, this.formatHref = "formatHref" in e ? e.formatHref : Ff.formatHref, this.nl2br = "nl2br" in e ? e.nl2br : Ff.nl2br, this.tagName = "tagName" in e ? e.tagName : Ff.tagName, this.target = "target" in e ? e.target : Ff.target, this.rel = "rel" in e ? e.rel : Ff.rel, this.validate = "validate" in e ? e.validate : Ff.validate, this.truncate = "truncate" in e ? e.truncate : Ff.truncate, this.className = "className" in e ? e.className : Ff.className, this.attributes = e.attributes || Ff.attributes, this.ignoreTags = []; for (var t = ("ignoreTags" in e ? e.ignoreTags : Ff.ignoreTags), n = 0; n < t.length; n++)this.ignoreTags.push(t[n].toUpperCase()) } function Bf(e) { return e } Nf.prototype = { resolve: function (e) { var t = e.toHref(this.defaultProtocol); return { formatted: this.get("format", e.toString(), e), formattedHref: this.get("formatHref", t, e), tagName: this.get("tagName", t, e), className: this.get("className", t, e), target: this.get("target", t, e), rel: this.get("rel", t, e), events: this.getObject("events", t, e), attributes: this.getObject("attributes", t, e), truncate: this.get("truncate", t, e) } }, check: function (e) { return this.get("validate", e.toString(), e) }, get: function (e, t, n) { var r, i = this[e]; if (!i) return i; switch (Tf(i)) { case "function": return i(t, n.t); case "object": return "function" == typeof (r = n.t in i ? i[n.t] : Ff[e]) ? r(t, n.t) : r }return i }, getObject: function (e, t, n) { var r = this[e]; return "function" == typeof r ? r(t, n.t) : r } }; function _f() { } function Rf(e, t) { function n(t, n) { this.t = e, this.v = t, this.tk = n } return function (e, t) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = Object.create(e.prototype); for (var i in n) r[i] = n[i]; r.constructor = t, t.prototype = r }(_f, n, t), n } _f.prototype = { t: "token", isLink: !1, toString: function () { return this.v }, toHref: function () { return this.toString() }, startIndex: function () { return this.tk[0].s }, endIndex: function () { return this.tk[this.tk.length - 1].e }, toObject: function () { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ff.defaultProtocol; return { type: this.t, value: this.v, isLink: this.isLink, href: this.toHref(e), start: this.startIndex(), end: this.endIndex() } } }; var Lf = Rf("email", { isLink: !0 }), Pf = Rf("email", { isLink: !0, toHref: function () { return "mailto:" + this.toString() } }), If = Rf("text"), $f = Rf("nl"), zf = Rf("url", { isLink: !0, toHref: function () { for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : Ff.defaultProtocol, t = this.tk, n = !1, r = !1, i = [], o = 0; t[o].t === Ip;)n = !0, i.push(t[o].v), o++; for (; t[o].t === vf;)r = !0, i.push(t[o].v), o++; for (; o < t.length; o++)i.push(t[o].v); return i = i.join(""), n || r || (i = "".concat(e, "://").concat(i)), i }, hasProtocol: function () { return this.tk[0].t === Ip } }), jf = Object.freeze({ __proto__: null, MultiToken: _f, Base: _f, createTokenClass: Rf, MailtoEmail: Lf, Email: Pf, Text: If, Nl: $f, Url: zf }); function Hf() { var e = Ep(), t = Ep(), n = Ep(), r = Ep(), i = Ep(), o = Ep(), s = Ep(), a = Sp(zf), l = Ep(), c = Sp(zf), u = Sp(zf), d = Ep(), h = Ep(), p = Ep(), f = Ep(), m = Ep(), g = Sp(zf), y = Sp(zf), v = Sp(zf), b = Sp(zf), w = Ep(), D = Ep(), x = Ep(), C = Ep(), k = Ep(), A = Ep(), E = Sp(Pf), S = Ep(), M = Sp(Pf), O = Sp(Lf), T = Ep(), F = Ep(), N = Ep(), B = Ep(), _ = Sp($f); Mp(e, jp, _), Mp(e, Ip, t), Mp(e, $p, n), Mp(t, vf, r), Mp(r, vf, i), Mp(e, Lp, o), Mp(e, _p, o), Mp(e, Rp, a), Mp(e, Pp, o), Mp(i, Lp, u), Mp(i, _p, u), Mp(i, Pp, u), Mp(i, Rp, u), Mp(o, af, s), Mp(k, af, A), Mp(s, Lp, a), Mp(s, _p, o), Mp(s, Pp, o), Mp(s, Rp, o), Mp(A, Lp, E), Mp(A, _p, k), Mp(A, Pp, k), Mp(A, Rp, k), Mp(a, af, s), Mp(E, af, A), Mp(a, rf, l), Mp(a, vf, u), Mp(l, Pp, c), Mp(c, vf, u), Mp(E, rf, S), Mp(S, Pp, M); var R = [Xp, Zp, Qp, ef, tf, nf, sf, _p, lf, uf, Rp, Pp, df, hf, pf, ff, Ip, vf, Df, bf, Lp, wf], L = [Yp, Up, Kp, Jp, Gp, rf, of, af, cf, Wp, Hp, Vp, qp, mf, gf, yf]; Mp(u, Hp, h), Mp(u, Vp, p), Mp(u, Wp, f), Mp(u, qp, m), Mp(d, Hp, h), Mp(d, Vp, p), Mp(d, Wp, f), Mp(d, qp, m), Mp(h, Kp, u), Mp(p, Jp, u), Mp(f, Up, u), Mp(m, Gp, u), Mp(g, Kp, u), Mp(y, Jp, u), Mp(v, Up, u), Mp(b, Gp, u), Mp(w, Kp, u), Mp(D, Jp, u), Mp(x, Up, u), Mp(C, Gp, u), Fp(h, R, g), Fp(p, R, y), Fp(f, R, v), Fp(m, R, b), Fp(h, L, w), Fp(p, L, D), Fp(f, L, x), Fp(m, L, C), Fp(g, R, g), Fp(y, R, y), Fp(v, R, v), Fp(b, R, b), Fp(g, L, g), Fp(y, L, y), Fp(v, L, v), Fp(b, L, b), Fp(w, R, g), Fp(D, R, y), Fp(x, R, v), Fp(C, R, b), Fp(w, L, w), Fp(D, L, D), Fp(x, L, x), Fp(C, L, C), Fp(u, R, u), Fp(d, R, u), Fp(u, L, d), Fp(d, L, d), Mp(n, Lp, O), Mp(n, _p, O), Mp(n, Pp, O), Mp(n, Rp, O), Fp(O, R, O), Fp(O, L, T), Fp(T, R, O), Fp(T, L, T); var P = [Xp, Yp, Zp, ef, tf, nf, Kp, sf, _p, lf, uf, Pp, Hp, df, hf, pf, ff, mf, vf, Df, bf, Lp, wf]; return Fp(o, P, F), Mp(o, Qp, N), Fp(a, P, F), Mp(a, Qp, N), Fp(s, P, F), Fp(F, P, F), Mp(F, Qp, N), Mp(F, af, B), Fp(B, P, F), Mp(N, Lp, k), Mp(N, _p, k), Mp(N, Pp, k), Mp(N, Rp, E), e } function Vf(e, t, n) { var r = n[0].s, i = n[n.length - 1].e; return new e(t.substr(r, i - r), n) } var Wf = "undefined" != typeof console && console && console.warn || function () { }, qf = { scanner: null, parser: null, pluginQueue: [], customProtocols: [], initialized: !1 }; function Kf(e) { if (qf.initialized && Wf('linkifyjs: already initialized - will not register custom protocol "'.concat(e, '" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.')), !/^[a-z-]+$/.test(e)) throw Error("linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported"); qf.customProtocols.push(e) } function Jf(e) { return qf.initialized || function () { qf.scanner = { start: Of(qf.customProtocols), tokens: xf }, qf.parser = { start: Hf(), tokens: jf }; for (var e = { createTokenClass: Rf }, t = 0; t < qf.pluginQueue.length; t++)qf.pluginQueue[t][1]({ scanner: qf.scanner, parser: qf.parser, utils: e }); qf.initialized = !0 }(), function (e, t, n) { for (var r = n.length, i = 0, o = [], s = []; i < r;) { for (var a = e, l = null, c = null, u = 0, d = null, h = -1; i < r && !(l = Tp(a, n[i].t));)s.push(n[i++]); for (; i < r && (c = l || Tp(a, n[i].t));)l = null, (a = c).accepts() ? (h = 0, d = a) : h >= 0 && h++, i++, u++; if (h < 0) for (var p = i - u; p < i; p++)s.push(n[p]); else { s.length > 0 && (o.push(Vf(If, t, s)), s = []), i -= h, u -= h; var f = d.t, m = n.slice(i - u, i); o.push(Vf(f, t, m)) } } return s.length > 0 && o.push(Vf(If, t, s)), o }(qf.parser.start, e, function (e, t) { for (var n = function (e) { for (var t = [], n = e.length, r = 0; r < n;) { var i = e.charCodeAt(r), o = void 0, s = i < 55296 || i > 56319 || r + 1 === n || (o = e.charCodeAt(r + 1)) < 56320 || o > 57343 ? e[r] : e.slice(r, r + 2); t.push(s), r += s.length } return t }(t.replace(/[A-Z]/g, (function (e) { return e.toLowerCase() }))), r = n.length, i = [], o = 0, s = 0; s < r;) { for (var a = e, l = null, c = 0, u = null, d = -1, h = -1; s < r && (l = Tp(a, n[s]));)(a = l).accepts() ? (d = 0, h = 0, u = a) : d >= 0 && (d += n[s].length, h++), c += n[s].length, o += n[s].length, s++; o -= d, s -= h, c -= d, i.push({ t: u.t, v: t.substr(o - c, c), s: o - c, e: o }) } return i }(qf.scanner.start, e)) } function Uf(e) { for (var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = Jf(e), r = [], i = 0; i < n.length; i++) { var o = n[i]; !o.isLink || t && o.t !== t || r.push(o.toObject()) } return r } function Gf(e) { var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = Jf(e); return 1 === n.length && n[0].isLink && (!t || n[0].t === t) } function Xf(e) { return new ta({ key: new ia("autolink"), appendTransaction: (t, n, r) => { const i = t.some((e => e.docChanged)) && !n.doc.eq(r.doc), o = t.some((e => e.getMeta("preventAutolink"))); if (!i || o) return; const { tr: s } = r, a = function (e, t) { const n = new _s(e); return t.forEach((e => { e.steps.forEach((e => { n.step(e) })) })), n }(n.doc, [...t]), { mapping: l } = a, c = function (e) { const { mapping: t, steps: n } = e, r = []; return t.maps.forEach(((e, i) => { const o = []; if (e.ranges.length) e.forEach(((e, t) => { o.push({ from: e, to: t }) })); else { const { from: e, to: t } = n[i]; if (void 0 === e || void 0 === t) return; o.push({ from: e, to: t }) } o.forEach((({ from: e, to: n }) => { const o = t.slice(i).map(e, -1), s = t.slice(i).map(n), a = t.invert().map(o, -1), l = t.invert().map(s); r.push({ oldRange: { from: a, to: l }, newRange: { from: o, to: s } }) })) })), oh(r) }(a); return c.forEach((({ oldRange: t, newRange: i }) => { sh(t.from, t.to, n.doc).filter((t => t.mark.type === e.type)).forEach((t => { const i = sh(l.map(t.from), l.map(t.to), r.doc).filter((t => t.mark.type === e.type)); if (!i.length) return; const o = i[0], a = n.doc.textBetween(t.from, t.to, void 0, " "), c = r.doc.textBetween(o.from, o.to, void 0, " "), u = Gf(a), d = Gf(c); u && !d && s.removeMark(o.from, o.to, e.type) })), function (e, t, n) { const r = []; return e.nodesBetween(t.from, t.to, ((e, t) => { n(e) && r.push({ node: e, pos: t }) })), r }(r.doc, i, (e => e.isTextblock)).forEach((t => { Uf(r.doc.textBetween(t.pos, t.pos + t.node.nodeSize, void 0, " ")).filter((e => e.isLink)).filter((t => !e.validate || e.validate(t.value))).map((e => ({ ...e, from: t.pos + e.start + 1, to: t.pos + e.end + 1 }))).filter((e => { const t = i.from >= e.from && i.from <= e.to, n = i.to >= e.from && i.to <= e.to; return t || n })).forEach((t => { s.addMark(t.from, t.to, e.type.create({ href: t.href })) })) })) })), s.steps.length ? s : void 0 } }) } const Yf = dh.create({ name: "link", priority: 1e3, keepOnSplit: !1, onCreate() { this.options.protocols.forEach(Kf) }, inclusive() { return this.options.autolink }, addOptions: () => ({ openOnClick: !0, linkOnPaste: !0, autolink: !0, protocols: [], HTMLAttributes: { target: "_blank", rel: "noopener noreferrer nofollow", class: null }, validate: void 0 }), addAttributes() { return { href: { default: null }, target: { default: this.options.HTMLAttributes.target }, class: { default: this.options.HTMLAttributes.class } } }, parseHTML: () => [{ tag: 'a[href]:not([href *= "javascript:" i])' }], renderHTML({ HTMLAttributes: e }) { return ["a", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setLink: e => ({ chain: t }) => t().setMark(this.name, e).setMeta("preventAutolink", !0).run(), toggleLink: e => ({ chain: t }) => t().toggleMark(this.name, e, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(), unsetLink: () => ({ chain: e }) => e().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() } }, addPasteRules() { return [ph({ find: e => Uf(e).filter((e => !this.options.validate || this.options.validate(e.value))).filter((e => e.isLink)).map((e => ({ text: e.value, index: e.start, data: e }))), type: this.type, getAttributes: e => { var t; return { href: null === (t = e.data) || void 0 === t ? void 0 : t.href } } })] }, addProseMirrorPlugins() { const e = []; return this.options.autolink && e.push(Xf({ type: this.type, validate: this.options.validate })), this.options.openOnClick && e.push(function (e) { return new ta({ key: new ia("handleClickLink"), props: { handleClick: (t, n, r) => { var i; const o = th(t.state, e.type.name); return !(!(null === (i = r.target) || void 0 === i ? void 0 : i.closest("a")) || !o.href || (window.open(o.href, o.target), 0)) } } }) }({ type: this.type })), this.options.linkOnPaste && e.push(function (e) { return new ta({ key: new ia("handlePasteLink"), props: { handlePaste: (t, n, r) => { const { state: i } = t, { selection: o } = i, { empty: s } = o; if (s) return !1; let a = ""; r.content.forEach((e => { a += e.textContent })); const l = Uf(a).find((e => e.isLink && e.value === a)); return !(!a || !l || (e.editor.commands.setMark(e.type, { href: l.href }), 0)) } } }) }({ editor: this.editor, type: this.type })), e } }), Zf = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/, Qf = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g, em = dh.create({ name: "highlight", addOptions: () => ({ multicolor: !1, HTMLAttributes: {} }), addAttributes() { return this.options.multicolor ? { color: { default: null, parseHTML: e => e.getAttribute("data-color") || e.style.backgroundColor, renderHTML: e => e.color ? { "data-color": e.color, style: `background-color: ${e.color}` } : {} } } : {} }, parseHTML: () => [{ tag: "mark" }], renderHTML({ HTMLAttributes: e }) { return ["mark", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setHighlight: e => ({ commands: t }) => t.setMark(this.name, e), toggleHighlight: e => ({ commands: t }) => t.toggleMark(this.name, e), unsetHighlight: () => ({ commands: e }) => e.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-h": () => this.editor.commands.toggleHighlight() } }, addInputRules() { return [ah({ find: Zf, type: this.type })] }, addPasteRules() { return [ph({ find: Qf, type: this.type })] } }), tm = dh.create({ name: "underline", addOptions: () => ({ HTMLAttributes: {} }), parseHTML: () => [{ tag: "u" }, { style: "text-decoration", consuming: !1, getAttrs: e => !!e.includes("underline") && {} }], renderHTML({ HTMLAttributes: e }) { return ["u", Qu(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setUnderline: () => ({ commands: e }) => e.setMark(this.name), toggleUnderline: () => ({ commands: e }) => e.toggleMark(this.name), unsetUnderline: () => ({ commands: e }) => e.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-u": () => this.editor.commands.toggleUnderline(), "Mod-U": () => this.editor.commands.toggleUnderline() } } }), nm = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, rm = hh.create({ name: "image", addOptions: () => ({ inline: !1, allowBase64: !1, HTMLAttributes: {} }), inline() { return this.options.inline }, group() { return this.options.inline ? "inline" : "block" }, draggable: !0, addAttributes: () => ({ src: { default: null }, alt: { default: null }, title: { default: null } }), parseHTML() { return [{ tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])' }] }, renderHTML({ HTMLAttributes: e }) { return ["img", Qu(this.options.HTMLAttributes, e)] }, addCommands() { return { setImage: e => ({ commands: t }) => t.insertContent({ type: this.name, attrs: e }) } }, addInputRules() { return [lh({ find: nm, type: this.type, getAttributes: e => { const [, , t, n, r] = e; return { src: n, alt: t, title: r } } })] } }); let im, om; if ("undefined" != typeof WeakMap) { let e = new WeakMap; im = t => e.get(t), om = (t, n) => (e.set(t, n), n) } else { let e = [], t = 10, n = 0; im = t => { for (let n = 0; n < e.length; n += 2)if (e[n] == t) return e[n + 1] }, om = (r, i) => (n == t && (n = 0), e[n++] = r, e[n++] = i) } class sm { constructor(e, t, n, r) { this.left = e, this.top = t, this.right = n, this.bottom = r } } class am { constructor(e, t, n, r) { this.width = e, this.height = t, this.map = n, this.problems = r } findCell(e) { for (let t = 0; t < this.map.length; t++) { let n = this.map[t]; if (n != e) continue; let r = t % this.width, i = t / this.width | 0, o = r + 1, s = i + 1; for (let e = 1; o < this.width && this.map[t + e] == n; e++)o++; for (let e = 1; s < this.height && this.map[t + this.width * e] == n; e++)s++; return new sm(r, i, o, s) } throw new RangeError("No cell with offset " + e + " found") } colCount(e) { for (let t = 0; t < this.map.length; t++)if (this.map[t] == e) return t % this.width; throw new RangeError("No cell with offset " + e + " found") } nextCell(e, t, n) { let { left: r, right: i, top: o, bottom: s } = this.findCell(e); return "horiz" == t ? (n < 0 ? 0 == r : i == this.width) ? null : this.map[o * this.width + (n < 0 ? r - 1 : i)] : (n < 0 ? 0 == o : s == this.height) ? null : this.map[r + this.width * (n < 0 ? o - 1 : s)] } rectBetween(e, t) { let { left: n, right: r, top: i, bottom: o } = this.findCell(e), { left: s, right: a, top: l, bottom: c } = this.findCell(t); return new sm(Math.min(n, s), Math.min(i, l), Math.max(r, a), Math.max(o, c)) } cellsInRect(e) { let t = [], n = {}; for (let r = e.top; r < e.bottom; r++)for (let i = e.left; i < e.right; i++) { let o = r * this.width + i, s = this.map[o]; n[s] || (n[s] = !0, i == e.left && i && this.map[o - 1] == s || r == e.top && r && this.map[o - this.width] == s || t.push(s)) } return t } positionAt(e, t, n) { for (let r = 0, i = 0; ; r++) { let o = i + n.child(r).nodeSize; if (r == e) { let n = t + e * this.width, r = (e + 1) * this.width; for (; n < r && this.map[n] < i;)n++; return n == r ? o - 1 : this.map[n] } i = o } } static get(e) { return im(e) || om(e, function (e) { if ("table" != e.type.spec.tableRole) throw new RangeError("Not a table node: " + e.type.name); let t = function (e) { let t = -1, n = !1; for (let r = 0; r < e.childCount; r++) { let i = e.child(r), o = 0; if (n) for (let t = 0; t < r; t++) { let n = e.child(t); for (let e = 0; e < n.childCount; e++) { let i = n.child(e); t + i.attrs.rowspan > r && (o += i.attrs.colspan) } } for (let e = 0; e < i.childCount; e++) { let t = i.child(e); o += t.attrs.colspan, t.attrs.rowspan > 1 && (n = !0) } -1 == t ? t = o : t != o && (t = Math.max(t, o)) } return t }(e), n = e.childCount, r = [], i = 0, o = null, s = []; for (let e = 0, i = t * n; e < i; e++)r[e] = 0; for (let a = 0, l = 0; a < n; a++) { let c = e.child(a); l++; for (let e = 0; ; e++) { for (; i < r.length && 0 != r[i];)i++; if (e == c.childCount) break; let u = c.child(e), { colspan: d, rowspan: h, colwidth: p } = u.attrs; for (let e = 0; e < h; e++) { if (e + a >= n) { (o || (o = [])).push({ type: "overlong_rowspan", pos: l, n: h - e }); break } let c = i + e * t; for (let e = 0; e < d; e++) { 0 == r[c + e] ? r[c + e] = l : (o || (o = [])).push({ type: "collision", row: a, pos: l, n: d - e }); let n = p && p[e]; if (n) { let r = (c + e) % t * 2, i = s[r]; null == i || i != n && 1 == s[r + 1] ? (s[r] = n, s[r + 1] = 1) : i == n && s[r + 1]++ } } } i += d, l += u.nodeSize } let u = (a + 1) * t, d = 0; for (; i < u;)0 == r[i++] && d++; d && (o || (o = [])).push({ type: "missing", row: a, n: d }), l++ } let a = new am(t, n, r, o), l = !1; for (let e = 0; !l && e < s.length; e += 2)null != s[e] && s[e + 1] < n && (l = !0); l && function (e, t, n) { e.problems || (e.problems = []); for (let r = 0, i = {}; r < e.map.length; r++) { let o = e.map[r]; if (i[o]) continue; i[o] = !0; let s = n.nodeAt(o), a = null; for (let n = 0; n < s.attrs.colspan; n++) { let i = t[2 * ((r + n) % e.width)]; null == i || s.attrs.colwidth && s.attrs.colwidth[n] == i || ((a || (a = lm(s.attrs)))[n] = i) } a && e.problems.unshift({ type: "colwidth mismatch", pos: o, colwidth: a }) } }(a, s, e); return a }(e)) } } function lm(e) { if (e.colwidth) return e.colwidth.slice(); let t = []; for (let n = 0; n < e.colspan; n++)t.push(0); return t } function cm(e) { let t = e.cached.tableNodeTypes; if (!t) { t = e.cached.tableNodeTypes = {}; for (let n in e.nodes) { let r = e.nodes[n], i = r.spec.tableRole; i && (t[i] = r) } } return t } const um = new ia("selectingCells"); function dm(e) { for (let t = e.depth - 1; t > 0; t--)if ("row" == e.node(t).type.spec.tableRole) return e.node(0).resolve(e.before(t + 1)); return null } function hm(e) { let t = e.selection.$head; for (let e = t.depth; e > 0; e--)if ("row" == t.node(e).type.spec.tableRole) return !0; return !1 } function pm(e) { let t = e.selection; return t.$anchorCell ? t.$anchorCell.pos > t.$headCell.pos ? t.$anchorCell : t.$headCell : t.node && "cell" == t.node.type.spec.tableRole ? t.$anchor : dm(t.$head) || function (e) { for (let t = e.nodeAfter, n = e.pos; t; t = t.firstChild, n++) { let r = t.type.spec.tableRole; if ("cell" == r || "header_cell" == r) return e.doc.resolve(n) } for (let t = e.nodeBefore, n = e.pos; t; t = t.lastChild, n--) { let r = t.type.spec.tableRole; if ("cell" == r || "header_cell" == r) return e.doc.resolve(n - t.nodeSize) } }(t.$head) } function fm(e) { return "row" == e.parent.type.spec.tableRole && e.nodeAfter } function mm(e, t) { return e.depth == t.depth && e.pos >= t.start(-1) && e.pos <= t.end(-1) } function gm(e, t, n) { let r = e.start(-1), i = am.get(e.node(-1)).nextCell(e.pos - r, t, n); return null == i ? null : e.node(0).resolve(r + i) } function ym(e, t, n) { let r = {}; for (let t in e) r[t] = e[t]; return r[t] = n, r } function vm(e, t, n = 1) { let r = ym(e, "colspan", e.colspan - n); return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(t, n), r.colwidth.some((e => e > 0)) || (r.colwidth = null)), r } function bm(e, t, n = 1) { let r = ym(e, "colspan", e.colspan + n); if (r.colwidth) { r.colwidth = r.colwidth.slice(); for (let e = 0; e < n; e++)r.colwidth.splice(t, 0, 0) } return r } class wm extends Ls { constructor(e, t = e) { let n = e.node(-1), r = am.get(n), i = e.start(-1), o = r.rectBetween(e.pos - i, t.pos - i), s = e.node(0), a = r.cellsInRect(o).filter((e => e != t.pos - i)); a.unshift(t.pos - i); let l = a.map((e => { let t = n.nodeAt(e), r = e + i + 1; return new Ps(s.resolve(r), s.resolve(r + t.content.size)) })); super(l[0].$from, l[0].$to, l), this.$anchorCell = e, this.$headCell = t } map(e, t) { let n = e.resolve(t.map(this.$anchorCell.pos)), r = e.resolve(t.map(this.$headCell.pos)); if (fm(n) && fm(r) && mm(n, r)) { let e = this.$anchorCell.node(-1) != n.node(-1); return e && this.isRowSelection() ? wm.rowSelection(n, r) : e && this.isColSelection() ? wm.colSelection(n, r) : new wm(n, r) } return zs.between(n, r) } content() { let e = this.$anchorCell.node(-1), t = am.get(e), n = this.$anchorCell.start(-1), r = t.rectBetween(this.$anchorCell.pos - n, this.$headCell.pos - n), i = {}, o = []; for (let n = r.top; n < r.bottom; n++) { let s = []; for (let o = n * t.width + r.left, a = r.left; a < r.right; a++, o++) { let n = t.map[o]; if (!i[n]) { i[n] = !0; let o = t.findCell(n), a = e.nodeAt(n), l = r.left - o.left, c = o.right - r.right; if (l > 0 || c > 0) { let e = a.attrs; l > 0 && (e = vm(e, 0, l)), c > 0 && (e = vm(e, e.colspan - c, c)), a = o.left < r.left ? a.type.createAndFill(e) : a.type.create(e, a.content) } if (o.top < r.top || o.bottom > r.bottom) { let e = ym(a.attrs, "rowspan", Math.min(o.bottom, r.bottom) - Math.max(o.top, r.top)); a = o.top < r.top ? a.type.createAndFill(e) : a.type.create(e, a.content) } s.push(a) } } o.push(e.child(n).copy(Ui.from(s))) } const s = this.isColSelection() && this.isRowSelection() ? e : o; return new eo(Ui.from(s), 1, 1) } replace(e, t = eo.empty) { let n = e.steps.length, r = this.ranges; for (let i = 0; i < r.length; i++) { let { $from: o, $to: s } = r[i], a = e.mapping.slice(n); e.replace(a.map(o.pos), a.map(s.pos), i ? eo.empty : t) } let i = Ls.findFrom(e.doc.resolve(e.mapping.slice(n).map(this.to)), -1); i && e.setSelection(i) } replaceWith(e, t) { this.replace(e, new eo(Ui.from(t), 0, 0)) } forEachCell(e) { let t = this.$anchorCell.node(-1), n = am.get(t), r = this.$anchorCell.start(-1), i = n.cellsInRect(n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r)); for (let n = 0; n < i.length; n++)e(t.nodeAt(i[n]), r + i[n]) } isColSelection() { let e = this.$anchorCell.index(-1), t = this.$headCell.index(-1); if (Math.min(e, t) > 0) return !1; let n = e + this.$anchorCell.nodeAfter.attrs.rowspan, r = t + this.$headCell.nodeAfter.attrs.rowspan; return Math.max(n, r) == this.$headCell.node(-1).childCount } static colSelection(e, t = e) { let n = am.get(e.node(-1)), r = e.start(-1), i = n.findCell(e.pos - r), o = n.findCell(t.pos - r), s = e.node(0); return i.top <= o.top ? (i.top > 0 && (e = s.resolve(r + n.map[i.left])), o.bottom < n.height && (t = s.resolve(r + n.map[n.width * (n.height - 1) + o.right - 1]))) : (o.top > 0 && (t = s.resolve(r + n.map[o.left])), i.bottom < n.height && (e = s.resolve(r + n.map[n.width * (n.height - 1) + i.right - 1]))), new wm(e, t) } isRowSelection() { let e = am.get(this.$anchorCell.node(-1)), t = this.$anchorCell.start(-1), n = e.colCount(this.$anchorCell.pos - t), r = e.colCount(this.$headCell.pos - t); if (Math.min(n, r) > 0) return !1; let i = n + this.$anchorCell.nodeAfter.attrs.colspan, o = r + this.$headCell.nodeAfter.attrs.colspan; return Math.max(i, o) == e.width } eq(e) { return e instanceof wm && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos } static rowSelection(e, t = e) { let n = am.get(e.node(-1)), r = e.start(-1), i = n.findCell(e.pos - r), o = n.findCell(t.pos - r), s = e.node(0); return i.left <= o.left ? (i.left > 0 && (e = s.resolve(r + n.map[i.top * n.width])), o.right < n.width && (t = s.resolve(r + n.map[n.width * (o.top + 1) - 1]))) : (o.left > 0 && (t = s.resolve(r + n.map[o.top * n.width])), i.right < n.width && (e = s.resolve(r + n.map[n.width * (i.top + 1) - 1]))), new wm(e, t) } toJSON() { return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos } } static fromJSON(e, t) { return new wm(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, n = t) { return new wm(e.resolve(t), e.resolve(n)) } getBookmark() { return new Dm(this.$anchorCell.pos, this.$headCell.pos) } } wm.prototype.visible = !1, Ls.jsonID("cell", wm); class Dm { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new Dm(e.map(this.anchor), e.map(this.head)) } resolve(e) { let t = e.resolve(this.anchor), n = e.resolve(this.head); return "row" == t.parent.type.spec.tableRole && "row" == n.parent.type.spec.tableRole && t.index() < t.parent.childCount && n.index() < n.parent.childCount && mm(t, n) ? new wm(t, n) : Ls.near(n, 1) } } function xm(e) { if (!(e.selection instanceof wm)) return null; let t = []; return e.selection.forEachCell(((e, n) => { t.push(_c.node(n, n + e.nodeSize, { class: "selectedCell" })) })), Pc.create(e.doc, t) } function Cm(e) { if (!e.size) return null; let { content: t, openStart: n, openEnd: r } = e; for (; 1 == t.childCount && (n > 0 && r > 0 || "table" == t.firstChild.type.spec.tableRole);)n--, r--, t = t.firstChild.content; let i = t.firstChild, o = i.type.spec.tableRole, s = i.type.schema, a = []; if ("row" == o) for (let e = 0; e < t.childCount; e++) { let i = t.child(e).content, o = e ? 0 : Math.max(0, n - 1), l = e < t.childCount - 1 ? 0 : Math.max(0, r - 1); (o || l) && (i = km(cm(s).row, new eo(i, o, l)).content), a.push(i) } else { if ("cell" != o && "header_cell" != o) return null; a.push(n || r ? km(cm(s).row, new eo(t, n, r)).content : t) } return function (e, t) { let n = []; for (let e = 0; e < t.length; e++) { let r = t[e]; for (let t = r.childCount - 1; t >= 0; t--) { let { rowspan: i, colspan: o } = r.child(t).attrs; for (let t = e; t < e + i; t++)n[t] = (n[t] || 0) + o } } let r = 0; for (let e = 0; e < n.length; e++)r = Math.max(r, n[e]); for (let i = 0; i < n.length; i++)if (i >= t.length && t.push(Ui.empty), n[i] < r) { let o = cm(e).cell.createAndFill(), s = []; for (let e = n[i]; e < r; e++)s.push(o); t[i] = t[i].append(Ui.from(s)) } return { height: t.length, width: r, rows: t } }(s, a) } function km(e, t) { let n = e.createAndFill(); return new _s(n).replace(0, n.content.size, t).doc } function Am(e, t, n, r, i, o, s, a) { if (0 == s || s == t.height) return !1; let l = !1; for (let c = i; c < o; c++) { let i = s * t.width + c, o = t.map[i]; if (t.map[i - t.width] == o) { l = !0; let i = n.nodeAt(o), { top: u, left: d } = t.findCell(o); e.setNodeMarkup(e.mapping.slice(a).map(o + r), null, ym(i.attrs, "rowspan", s - u)), e.insert(e.mapping.slice(a).map(t.positionAt(s, d, n)), i.type.createAndFill(ym(i.attrs, "rowspan", u + i.attrs.rowspan - s))), c += i.attrs.colspan - 1 } } return l } function Em(e, t, n, r, i, o, s, a) { if (0 == s || s == t.width) return !1; let l = !1; for (let c = i; c < o; c++) { let i = c * t.width + s, o = t.map[i]; if (t.map[i - 1] == o) { l = !0; let i = n.nodeAt(o), u = t.colCount(o), d = e.mapping.slice(a).map(o + r); e.setNodeMarkup(d, null, vm(i.attrs, s - u, i.attrs.colspan - (s - u))), e.insert(d + i.nodeSize, i.type.createAndFill(vm(i.attrs, 0, s - u))), c += i.attrs.rowspan - 1 } } return l } function Sm(e, t, n, r, i) { let o = n ? e.doc.nodeAt(n - 1) : e.doc, s = am.get(o), { top: a, left: l } = r, c = l + i.width, u = a + i.height, d = e.tr, h = 0; function p() { o = n ? d.doc.nodeAt(n - 1) : d.doc, s = am.get(o), h = d.mapping.maps.length } (function (e, t, n, r, i, o, s) { let a, l, c = cm(e.doc.type.schema); if (i > t.width) for (let o = 0, u = 0; o < t.height; o++) { let d = n.child(o); u += d.nodeSize; let h, p = []; h = null == d.lastChild || d.lastChild.type == c.cell ? a || (a = c.cell.createAndFill()) : l || (l = c.header_cell.createAndFill()); for (let e = t.width; e < i; e++)p.push(h); e.insert(e.mapping.slice(s).map(u - 1 + r), p) } if (o > t.height) { let u = []; for (let e = 0, r = (t.height - 1) * t.width; e < Math.max(t.width, i); e++) { let i = !(e >= t.width) && n.nodeAt(t.map[r + e]).type == c.header_cell; u.push(i ? l || (l = c.header_cell.createAndFill()) : a || (a = c.cell.createAndFill())) } let d = c.row.create(null, Ui.from(u)), h = []; for (let e = t.height; e < o; e++)h.push(d); e.insert(e.mapping.slice(s).map(r + n.nodeSize - 2), h) } return !(!a && !l) })(d, s, o, n, c, u, h) && p(), Am(d, s, o, n, l, c, a, h) && p(), Am(d, s, o, n, l, c, u, h) && p(), Em(d, s, o, n, a, u, l, h) && p(), Em(d, s, o, n, a, u, c, h) && p(); for (let e = a; e < u; e++) { let t = s.positionAt(e, l, o), r = s.positionAt(e, c, o); d.replace(d.mapping.slice(h).map(t + n), d.mapping.slice(h).map(r + n), new eo(i.rows[e - a], 0, 0)) } p(), d.setSelection(new wm(d.doc.resolve(n + s.positionAt(a, l, o)), d.doc.resolve(n + s.positionAt(u - 1, c - 1, o)))), t(d) } const Mm = wu({ ArrowLeft: Tm("horiz", -1), ArrowRight: Tm("horiz", 1), ArrowUp: Tm("vert", -1), ArrowDown: Tm("vert", 1), "Shift-ArrowLeft": Fm("horiz", -1), "Shift-ArrowRight": Fm("horiz", 1), "Shift-ArrowUp": Fm("vert", -1), "Shift-ArrowDown": Fm("vert", 1), Backspace: Nm, "Mod-Backspace": Nm, Delete: Nm, "Mod-Delete": Nm }); function Om(e, t, n) { return !n.eq(e.selection) && (t && t(e.tr.setSelection(n).scrollIntoView()), !0) } function Tm(e, t) { return (n, r, i) => { let o = n.selection; if (o instanceof wm) return Om(n, r, Ls.near(o.$headCell, t)); if ("horiz" != e && !o.empty) return !1; let s = Lm(i, e, t); if (null == s) return !1; if ("horiz" == e) return Om(n, r, Ls.near(n.doc.resolve(o.head + t), t)); { let i, o = n.doc.resolve(s), a = gm(o, e, t); return i = a ? Ls.near(a, 1) : t < 0 ? Ls.near(n.doc.resolve(o.before(-1)), -1) : Ls.near(n.doc.resolve(o.after(-1)), 1), Om(n, r, i) } } } function Fm(e, t) { return (n, r, i) => { let o = n.selection; if (!(o instanceof wm)) { let r = Lm(i, e, t); if (null == r) return !1; o = new wm(n.doc.resolve(r)) } let s = gm(o.$headCell, e, t); return !!s && Om(n, r, new wm(o.$anchorCell, s)) } } function Nm(e, t) { let n = e.selection; if (!(n instanceof wm)) return !1; if (t) { let r = e.tr, i = cm(e.schema).cell.createAndFill().content; n.forEachCell(((e, t) => { e.content.eq(i) || r.replace(r.mapping.map(t + 1), r.mapping.map(t + e.nodeSize - 1), new eo(i, 0, 0)) })), r.docChanged && t(r) } return !0 } function Bm(e, t) { let n = dm(e.state.doc.resolve(t)); return !!n && (e.dispatch(e.state.tr.setSelection(new wm(n))), !0) } function _m(e, t, n) { if (!hm(e.state)) return !1; let r = Cm(n), i = e.state.selection; if (i instanceof wm) { r || (r = { width: 1, height: 1, rows: [Ui.from(km(cm(e.state.schema).cell, n))] }); let t = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), s = am.get(t).rectBetween(i.$anchorCell.pos - o, i.$headCell.pos - o); return r = function ({ width: e, height: t, rows: n }, r, i) { if (e != r) { let t = [], i = []; for (let e = 0; e < n.length; e++) { let o = n[e], s = []; for (let n = t[e] || 0, i = 0; n < r; i++) { let a = o.child(i % o.childCount); n + a.attrs.colspan > r && (a = a.type.create(vm(a.attrs, a.attrs.colspan, n + a.attrs.colspan - r), a.content)), s.push(a), n += a.attrs.colspan; for (let n = 1; n < a.attrs.rowspan; n++)t[e + n] = (t[e + n] || 0) + a.attrs.colspan } i.push(Ui.from(s)) } n = i, e = r } if (t != i) { let e = []; for (let r = 0, o = 0; r < i; r++, o++) { let s = [], a = n[o % t]; for (let e = 0; e < a.childCount; e++) { let t = a.child(e); r + t.attrs.rowspan > i && (t = t.type.create(ym(t.attrs, "rowspan", Math.max(1, i - t.attrs.rowspan)), t.content)), s.push(t) } e.push(Ui.from(s)) } n = e, t = i } return { width: e, height: t, rows: n } }(r, s.right - s.left, s.bottom - s.top), Sm(e.state, e.dispatch, o, s, r), !0 } if (r) { let t = pm(e.state), n = t.start(-1); return Sm(e.state, e.dispatch, n, am.get(t.node(-1)).findCell(t.pos - n), r), !0 } return !1 } function Rm(e, t) { if (t.ctrlKey || t.metaKey) return; let n, r = Pm(e, t.target); if (t.shiftKey && e.state.selection instanceof wm) i(e.state.selection.$anchorCell, t), t.preventDefault(); else if (t.shiftKey && r && null != (n = dm(e.state.selection.$anchor)) && Im(e, t).pos != n.pos) i(n, t), t.preventDefault(); else if (!r) return; function i(t, n) { let r = Im(e, n), i = null == um.getState(e.state); if (!r || !mm(t, r)) { if (!i) return; r = t } let o = new wm(t, r); if (i || !e.state.selection.eq(o)) { let n = e.state.tr.setSelection(o); i && n.setMeta(um, t.pos), e.dispatch(n) } } function o() { e.root.removeEventListener("mouseup", o), e.root.removeEventListener("dragstart", o), e.root.removeEventListener("mousemove", s), null != um.getState(e.state) && e.dispatch(e.state.tr.setMeta(um, -1)) } function s(n) { let s, a = um.getState(e.state); if (null != a) s = e.state.doc.resolve(a); else if (Pm(e, n.target) != r && (s = Im(e, t), !s)) return o(); s && i(s, n) } e.root.addEventListener("mouseup", o), e.root.addEventListener("dragstart", o), e.root.addEventListener("mousemove", s) } function Lm(e, t, n) { if (!(e.state.selection instanceof zs)) return null; let { $head: r } = e.state.selection; for (let i = r.depth - 1; i >= 0; i--) { let o = r.node(i); if ((n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount)) return null; if ("cell" == o.type.spec.tableRole || "header_cell" == o.type.spec.tableRole) { let o = r.before(i), s = "vert" == t ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left"; return e.endOfTextblock(s) ? o : null } } return null } function Pm(e, t) { for (; t && t != e.dom; t = t.parentNode)if ("TD" == t.nodeName || "TH" == t.nodeName) return t } function Im(e, t) { let n = e.posAtCoords({ left: t.clientX, top: t.clientY }); return n && n ? dm(e.state.doc.resolve(n.pos)) : null } const $m = new ia("fix-tables"); function zm(e, t, n, r) { let i = e.childCount, o = t.childCount; e: for (let s = 0, a = 0; s < o; s++) { let o = t.child(s); for (let t = a, r = Math.min(i, s + 3); t < r; t++)if (e.child(t) == o) { a = t + 1, n += o.nodeSize; continue e } r(o, n), a < i && e.child(a).sameMarkup(o) ? zm(e.child(a), o, n + 1, r) : o.nodesBetween(0, o.content.size, r, n + 1), n += o.nodeSize } } function jm(e, t) { let n, r = (t, r) => { "table" == t.type.spec.tableRole && (n = function (e, t, n, r) { let i = am.get(t); if (!i.problems) return r; r || (r = e.tr); let o, s, a = []; for (let e = 0; e < i.height; e++)a.push(0); for (let e = 0; e < i.problems.length; e++) { let o = i.problems[e]; if ("collision" == o.type) { let e = t.nodeAt(o.pos); for (let t = 0; t < e.attrs.rowspan; t++)a[o.row + t] += o.n; r.setNodeMarkup(r.mapping.map(n + 1 + o.pos), null, vm(e.attrs, e.attrs.colspan - o.n, o.n)) } else if ("missing" == o.type) a[o.row] += o.n; else if ("overlong_rowspan" == o.type) { let e = t.nodeAt(o.pos); r.setNodeMarkup(r.mapping.map(n + 1 + o.pos), null, ym(e.attrs, "rowspan", e.attrs.rowspan - o.n)) } else if ("colwidth mismatch" == o.type) { let e = t.nodeAt(o.pos); r.setNodeMarkup(r.mapping.map(n + 1 + o.pos), null, ym(e.attrs, "colwidth", o.colwidth)) } } for (let e = 0; e < a.length; e++)a[e] && (null == o && (o = e), s = e); for (let l = 0, c = n + 1; l < i.height; l++) { let n = t.child(l), i = c + n.nodeSize, u = a[l]; if (u > 0) { let t = "cell"; n.firstChild && (t = n.firstChild.type.spec.tableRole); let a = []; for (let n = 0; n < u; n++)a.push(cm(e.schema)[t].createAndFill()); let d = 0 != l && o != l - 1 || s != l ? i - 1 : c + 1; r.insert(r.mapping.map(d), a) } c = i } return r.setMeta($m, { fixTables: !0 }) }(e, t, r, n)) }; return t ? t.doc != e.doc && zm(t.doc, e.doc, 0, r) : e.doc.descendants(r), n } function Hm(e) { let t, n = e.selection, r = pm(e), i = r.node(-1), o = r.start(-1), s = am.get(i); return t = n instanceof wm ? s.rectBetween(n.$anchorCell.pos - o, n.$headCell.pos - o) : s.findCell(r.pos - o), t.tableStart = o, t.map = s, t.table = i, t } function Vm(e, { map: t, tableStart: n, table: r }, i) { let o = i > 0 ? -1 : 0; (function (e, t, n) { let r = cm(t.type.schema).header_cell; for (let i = 0; i < e.height; i++)if (t.nodeAt(e.map[n + i * e.width]).type != r) return !1; return !0 })(t, r, i + o) && (o = 0 == i || i == t.width ? null : 0); for (let s = 0; s < t.height; s++) { let a = s * t.width + i; if (i > 0 && i < t.width && t.map[a - 1] == t.map[a]) { let o = t.map[a], l = r.nodeAt(o); e.setNodeMarkup(e.mapping.map(n + o), null, bm(l.attrs, i - t.colCount(o))), s += l.attrs.rowspan - 1 } else { let l = null == o ? cm(r.type.schema).cell : r.nodeAt(t.map[a + o]).type, c = t.positionAt(s, i, r); e.insert(e.mapping.map(n + c), l.createAndFill()) } } return e } function Wm(e, { map: t, table: n, tableStart: r }, i) { let o = e.mapping.maps.length; for (let s = 0; s < t.height;) { let a = s * t.width + i, l = t.map[a], c = n.nodeAt(l); if (i > 0 && t.map[a - 1] == l || i < t.width - 1 && t.map[a + 1] == l) e.setNodeMarkup(e.mapping.slice(o).map(r + l), null, vm(c.attrs, i - t.colCount(l))); else { let t = e.mapping.slice(o).map(r + l); e.delete(t, t + c.nodeSize) } s += c.attrs.rowspan } } function qm(e, { map: t, tableStart: n, table: r }, i) { let o = n; for (let e = 0; e < i; e++)o += r.child(e).nodeSize; let s = [], a = i > 0 ? -1 : 0; (function (e, t, n) { let r = cm(t.type.schema).header_cell; for (let i = 0; i < e.width; i++)if (t.nodeAt(e.map[i + n * e.width]).type != r) return !1; return !0 })(t, r, i + a) && (a = 0 == i || i == t.height ? null : 0); for (let o = 0, l = t.width * i; o < t.width; o++, l++)if (i > 0 && i < t.height && t.map[l] == t.map[l - t.width]) { let i = t.map[l], s = r.nodeAt(i).attrs; e.setNodeMarkup(n + i, null, ym(s, "rowspan", s.rowspan + 1)), o += s.colspan - 1 } else { let e = null == a ? cm(r.type.schema).cell : r.nodeAt(t.map[l + a * t.width]).type; s.push(e.createAndFill()) } return e.insert(o, cm(r.type.schema).row.create(null, s)), e } function Km(e, { map: t, table: n, tableStart: r }, i) { let o = 0; for (let e = 0; e < i; e++)o += n.child(e).nodeSize; let s = o + n.child(i).nodeSize, a = e.mapping.maps.length; e.delete(o + r, s + r); for (let o = 0, s = i * t.width; o < t.width; o++, s++) { let l = t.map[s]; if (i > 0 && l == t.map[s - t.width]) { let t = n.nodeAt(l).attrs; e.setNodeMarkup(e.mapping.slice(a).map(l + r), null, ym(t, "rowspan", t.rowspan - 1)), o += t.colspan - 1 } else if (i < t.width && l == t.map[s + t.width]) { let s = n.nodeAt(l), c = s.type.create(ym(s.attrs, "rowspan", s.attrs.rowspan - 1), s.content), u = t.positionAt(i + 1, o, n); e.insert(e.mapping.slice(a).map(r + u), c), o += s.attrs.colspan - 1 } } } function Jm(e) { let t = e.content; return 1 == t.childCount && t.firstChild.isTextblock && 0 == t.firstChild.childCount } function Um(e, t) { let n = e.selection; if (!(n instanceof wm) || n.$anchorCell.pos == n.$headCell.pos) return !1; let r = Hm(e), { map: i } = r; if (function ({ width: e, height: t, map: n }, r) { let i = r.top * e + r.left, o = i, s = (r.bottom - 1) * e + r.left, a = i + (r.right - r.left - 1); for (let t = r.top; t < r.bottom; t++) { if (r.left > 0 && n[o] == n[o - 1] || r.right < e && n[a] == n[a + 1]) return !0; o += e, a += e } for (let o = r.left; o < r.right; o++) { if (r.top > 0 && n[i] == n[i - e] || r.bottom < t && n[s] == n[s + e]) return !0; i++, s++ } return !1 }(i, r)) return !1; if (t) { let n, o, s = e.tr, a = {}, l = Ui.empty; for (let e = r.top; e < r.bottom; e++)for (let t = r.left; t < r.right; t++) { let c = i.map[e * i.width + t], u = r.table.nodeAt(c); if (!a[c]) if (a[c] = !0, null == n) n = c, o = u; else { Jm(u) || (l = l.append(u.content)); let e = s.mapping.map(c + r.tableStart); s.delete(e, e + u.nodeSize) } } if (s.setNodeMarkup(n + r.tableStart, null, ym(bm(o.attrs, o.attrs.colspan, r.right - r.left - o.attrs.colspan), "rowspan", r.bottom - r.top)), l.size) { let e = n + 1 + o.content.size, t = Jm(o) ? n + 1 : e; s.replaceWith(t + r.tableStart, e + r.tableStart, l) } s.setSelection(new wm(s.doc.resolve(n + r.tableStart))), t(s) } return !0 } function Gm(e, t) { const n = cm(e.schema); return (r = ({ node: e }) => n[e.type.spec.tableRole], (e, t) => { let n, i, o = e.selection; if (o instanceof wm) { if (o.$anchorCell.pos != o.$headCell.pos) return !1; n = o.$anchorCell.nodeAfter, i = o.$anchorCell.pos } else { if (n = function (e) { for (let t = e.depth; t > 0; t--) { const n = e.node(t).type.spec.tableRole; if ("cell" === n || "header_cell" === n) return e.node(t) } return null }(o.$from), !n) return !1; i = dm(o.$from).pos } if (1 == n.attrs.colspan && 1 == n.attrs.rowspan) return !1; if (t) { let s = n.attrs, a = [], l = s.colwidth; s.rowspan > 1 && (s = ym(s, "rowspan", 1)), s.colspan > 1 && (s = ym(s, "colspan", 1)); let c, u = Hm(e), d = e.tr; for (let e = 0; e < u.right - u.left; e++)a.push(l ? ym(s, "colwidth", l && l[e] ? [l[e]] : null) : s); for (let e = u.top; e < u.bottom; e++) { let t = u.map.positionAt(e, u.left, u.table); e == u.top && (t += n.nodeSize); for (let i = u.left, o = 0; i < u.right; i++, o++)i == u.left && e == u.top || d.insert(c = d.mapping.map(t + u.tableStart, 1), r({ node: n, row: e, col: i }).createAndFill(a[o])) } d.setNodeMarkup(i, r({ node: n, row: u.top, col: u.left }), a[0]), o instanceof wm && d.setSelection(new wm(d.doc.resolve(o.$anchorCell.pos), c && d.doc.resolve(c))), t(d) } return !0 })(e, t); var r } function Xm(e, t, n) { const r = t.map.cellsInRect({ left: 0, top: 0, right: "row" == e ? t.map.width : 1, bottom: "column" == e ? t.map.height : 1 }); for (let e = 0; e < r.length; e++) { const i = t.table.nodeAt(r[e]); if (i && i.type !== n.header_cell) return !1 } return !0 } function Ym(e, t) { return (t = t || { useDeprecatedLogic: !1 }).useDeprecatedLogic ? function (e) { return function (t, n) { if (!hm(t)) return !1; if (n) { let r = cm(t.schema), i = Hm(t), o = t.tr, s = i.map.cellsInRect("column" == e ? new sm(i.left, 0, i.right, i.map.height) : "row" == e ? new sm(0, i.top, i.map.width, i.bottom) : i), a = s.map((e => i.table.nodeAt(e))); for (let e = 0; e < s.length; e++)a[e].type == r.header_cell && o.setNodeMarkup(i.tableStart + s[e], r.cell, a[e].attrs); if (0 == o.steps.length) for (let e = 0; e < s.length; e++)o.setNodeMarkup(i.tableStart + s[e], r.header_cell, a[e].attrs); n(o) } return !0 } }(e) : function (t, n) { if (!hm(t)) return !1; if (n) { let r = cm(t.schema), i = Hm(t), o = t.tr, s = Xm("row", i, r), a = Xm("column", i, r), l = ("column" === e ? s : "row" === e && a) ? 1 : 0, c = "column" == e ? new sm(0, l, 1, i.map.height) : "row" == e ? new sm(l, 0, i.map.width, 1) : i, u = "column" == e ? a ? r.cell : r.header_cell : "row" == e ? s ? r.cell : r.header_cell : r.cell; i.map.cellsInRect(c).forEach((e => { const t = e + i.tableStart, n = o.doc.nodeAt(t); n && o.setNodeMarkup(t, u, n.attrs) })), n(o) } return !0 } } Ym("row", { useDeprecatedLogic: !0 }), Ym("column", { useDeprecatedLogic: !0 }); let Zm = Ym("cell", { useDeprecatedLogic: !0 }); function Qm(e) { return function (t, n) { if (!hm(t)) return !1; let r = function (e, t) { if (t < 0) { let t = e.nodeBefore; if (t) return e.pos - t.nodeSize; for (let t = e.index(-1) - 1, n = e.before(); t >= 0; t--) { let r = e.node(-1).child(t); if (r.childCount) return n - 1 - r.lastChild.nodeSize; n -= r.nodeSize } } else { if (e.index() < e.parent.childCount - 1) return e.pos + e.nodeAfter.nodeSize; let t = e.node(-1); for (let n = e.indexAfter(-1), r = e.after(); n < t.childCount; n++) { let e = t.child(n); if (e.childCount) return r + 1; r += e.nodeSize } } }(pm(t), e); if (null != r) { if (n) { let e = t.doc.resolve(r); n(t.tr.setSelection(zs.between(e, (i = e, i.node(0).resolve(i.pos + i.nodeAfter.nodeSize)))).scrollIntoView()) } var i; return !0 } } } class eg { constructor(e, t) { this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), tg(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody")) } update(e) { return e.type == this.node.type && (this.node = e, tg(e, this.colgroup, this.table, this.cellMinWidth), !0) } ignoreMutation(e) { return "attributes" == e.type && (e.target == this.table || this.colgroup.contains(e.target)) } } function tg(e, t, n, r, i, o) { let s = 0, a = !0, l = t.firstChild, c = e.firstChild; for (let e = 0, n = 0; e < c.childCount; e++) { let { colspan: u, colwidth: d } = c.child(e).attrs; for (let e = 0; e < u; e++, n++) { let c = i == n ? o : d && d[e], u = c ? c + "px" : ""; s += c || r, c || (a = !1), l ? (l.style.width != u && (l.style.width = u), l = l.nextSibling) : t.appendChild(document.createElement("col")).style.width = u } } for (; l;) { let e = l.nextSibling; l.parentNode.removeChild(l), l = e } a ? (n.style.width = s + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = s + "px") } const ng = new ia("tableColumnResizing"); function rg({ handleWidth: e = 5, cellMinWidth: t = 25, View: n = eg, lastColumnResizable: r = !0 } = {}) { let i = new ta({ key: ng, state: { init(e, r) { return this.spec.props.nodeViews[cm(r.schema).table.name] = (e, r) => new n(e, t, r), new ig(-1, !1) }, apply: (e, t) => t.apply(e) }, props: { attributes: e => ng.getState(e).activeHandle > -1 ? { class: "resize-cursor" } : null, handleDOMEvents: { mousemove(t, n) { !function (e, t, n, r, i) { let o = ng.getState(e.state); if (!o.dragging) { let r = function (e) { for (; e && "TD" != e.nodeName && "TH" != e.nodeName;)e = e.classList.contains("ProseMirror") ? null : e.parentNode; return e }(t.target), s = -1; if (r) { let { left: i, right: o } = r.getBoundingClientRect(); t.clientX - i <= n ? s = og(e, t, "left") : o - t.clientX <= n && (s = og(e, t, "right")) } if (s != o.activeHandle) { if (!i && -1 !== s) { let t = e.state.doc.resolve(s), n = t.node(-1), r = am.get(n), i = t.start(-1); if (r.colCount(t.pos - i) + t.nodeAfter.attrs.colspan - 1 == r.width - 1) return } ag(e, s) } } }(t, n, e, 0, r) }, mouseleave(e) { !function (e) { let t = ng.getState(e.state); t.activeHandle > -1 && !t.dragging && ag(e, -1) }(e) }, mousedown(e, n) { !function (e, t, n) { let r = ng.getState(e.state); if (-1 == r.activeHandle || r.dragging) return !1; let i = e.state.doc.nodeAt(r.activeHandle), o = function (e, t, { colspan: n, colwidth: r }) { let i = r && r[r.length - 1]; if (i) return i; let o = e.domAtPos(t), s = o.node.childNodes[o.offset].offsetWidth, a = n; if (r) for (let e = 0; e < n; e++)r[e] && (s -= r[e], a--); return s / a }(e, r.activeHandle, i.attrs); function s(t) { window.removeEventListener("mouseup", s), window.removeEventListener("mousemove", a); let r = ng.getState(e.state); r.dragging && (!function (e, t, n) { let r = e.state.doc.resolve(t), i = r.node(-1), o = am.get(i), s = r.start(-1), a = o.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = e.state.tr; for (let e = 0; e < o.height; e++) { let t = e * o.width + a; if (e && o.map[t] == o.map[t - o.width]) continue; let r = o.map[t], { attrs: c } = i.nodeAt(r), u = 1 == c.colspan ? 0 : a - o.colCount(r); if (c.colwidth && c.colwidth[u] == n) continue; let d = c.colwidth ? c.colwidth.slice() : lg(c.colspan); d[u] = n, l.setNodeMarkup(s + r, null, ym(c, "colwidth", d)) } l.docChanged && e.dispatch(l) }(e, r.activeHandle, sg(r.dragging, t, n)), e.dispatch(e.state.tr.setMeta(ng, { setDragging: null }))) } function a(t) { if (!t.which) return s(t); let r = ng.getState(e.state), i = sg(r.dragging, t, n); !function (e, t, n, r) { let i = e.state.doc.resolve(t), o = i.node(-1), s = i.start(-1), a = am.get(o).colCount(i.pos - s) + i.nodeAfter.attrs.colspan - 1, l = e.domAtPos(i.start(-1)).node; for (; "TABLE" != l.nodeName;)l = l.parentNode; tg(o, l.firstChild, l, r, a, n) }(e, r.activeHandle, i, n) } e.dispatch(e.state.tr.setMeta(ng, { setDragging: { startX: t.clientX, startWidth: o } })), window.addEventListener("mouseup", s), window.addEventListener("mousemove", a), t.preventDefault() }(e, n, t) } }, decorations(e) { let t = ng.getState(e); if (t.activeHandle > -1) return function (e, t) { let n = [], r = e.doc.resolve(t), i = r.node(-1), o = am.get(i), s = r.start(-1), a = o.colCount(r.pos - s) + r.nodeAfter.attrs.colspan; for (let e = 0; e < o.height; e++) { let t = a + e * o.width - 1; if (!(a != o.width && o.map[t] == o.map[t + 1] || 0 != e && o.map[t - 1] == o.map[t - 1 - o.width])) { let e = o.map[t], r = s + e + i.nodeAt(e).nodeSize - 1, a = document.createElement("div"); a.className = "column-resize-handle", n.push(_c.widget(r, a)) } } return Pc.create(e.doc, n) }(e, t.activeHandle) }, nodeViews: {} } }); return i } class ig { constructor(e, t) { this.activeHandle = e, this.dragging = t } apply(e) { let t = this, n = e.getMeta(ng); if (n && null != n.setHandle) return new ig(n.setHandle, null); if (n && void 0 !== n.setDragging) return new ig(t.activeHandle, n.setDragging); if (t.activeHandle > -1 && e.docChanged) { let n = e.mapping.map(t.activeHandle, -1); fm(e.doc.resolve(n)) || (n = null), t = new ig(n, t.dragging) } return t } } function og(e, t, n) { let r = e.posAtCoords({ left: t.clientX, top: t.clientY }); if (!r) return -1; let { pos: i } = r, o = dm(e.state.doc.resolve(i)); if (!o) return -1; if ("right" == n) return o.pos; let s = am.get(o.node(-1)), a = o.start(-1), l = s.map.indexOf(o.pos - a); return l % s.width == 0 ? -1 : a + s.map[l - 1] } function sg(e, t, n) { let r = t.clientX - e.startX; return Math.max(n, e.startWidth + r) } function ag(e, t) { e.dispatch(e.state.tr.setMeta(ng, { setHandle: t })) } function lg(e) { let t = []; for (let n = 0; n < e; n++)t.push(0); return t } function cg({ allowTableNodeSelection: e = !1 } = {}) { return new ta({ key: um, state: { init: () => null, apply(e, t) { let n = e.getMeta(um); if (null != n) return -1 == n ? null : n; if (null == t || !e.docChanged) return t; let { deleted: r, pos: i } = e.mapping.mapResult(t); return r ? null : i } }, props: { decorations: xm, handleDOMEvents: { mousedown: Rm }, createSelectionBetween(e) { if (null != um.getState(e.state)) return e.state.selection }, handleTripleClick: Bm, handleKeyDown: Mm, handlePaste: _m }, appendTransaction: (t, n, r) => function (e, t, n) { let r, i, o = (t || e).selection, s = (t || e).doc; if (o instanceof Hs && (i = o.node.type.spec.tableRole)) { if ("cell" == i || "header_cell" == i) r = wm.create(s, o.from); else if ("row" == i) { let e = s.resolve(o.from + 1); r = wm.rowSelection(e, e) } else if (!n) { let e = am.get(o.node), t = o.from + 1, n = t + e.map[e.width * e.height - 1]; r = wm.create(s, t + 1, n) } } else o instanceof zs && function ({ $from: e, $to: t }) { if (e.pos == t.pos || e.pos < e.pos - 6) return !1; let n = e.pos, r = t.pos, i = e.depth; for (; i >= 0 && !(e.after(i + 1) < e.end(i)); i--, n++); for (let e = t.depth; e >= 0 && !(t.before(e + 1) > t.start(e)); e--, r--); return n == r && /row|table/.test(e.node(i).type.spec.tableRole) }(o) ? r = zs.create(s, o.from) : o instanceof zs && function ({ $from: e, $to: t }) { let n, r; for (let t = e.depth; t > 0; t--) { let r = e.node(t); if ("cell" === r.type.spec.tableRole || "header_cell" === r.type.spec.tableRole) { n = r; break } } for (let e = t.depth; e > 0; e--) { let n = t.node(e); if ("cell" === n.type.spec.tableRole || "header_cell" === n.type.spec.tableRole) { r = n; break } } return n !== r && 0 === t.parentOffset }(o) && (r = zs.create(s, o.$from.start(), o.$from.end())); return r && (t || (t = e.tr)).setSelection(r), t }(r, jm(r, n), e) }) } function ug(e, t, n, r, i, o) { let s = 0, a = !0, l = t.firstChild; const c = e.firstChild; for (let e = 0, n = 0; e < c.childCount; e += 1) { const { colspan: u, colwidth: d } = c.child(e).attrs; for (let e = 0; e < u; e += 1, n += 1) { const c = i === n ? o : d && d[e], u = c ? `${c}px` : ""; s += c || r, c || (a = !1), l ? (l.style.width !== u && (l.style.width = u), l = l.nextSibling) : t.appendChild(document.createElement("col")).style.width = u } } for (; l;) { const e = l.nextSibling; l.parentNode.removeChild(l), l = e } a ? (n.style.width = `${s}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${s}px`) } class dg { constructor(e, t) { this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), ug(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody")) } update(e) { return e.type === this.node.type && (this.node = e, ug(e, this.colgroup, this.table, this.cellMinWidth), !0) } ignoreMutation(e) { return "attributes" === e.type && (e.target === this.table || this.colgroup.contains(e.target)) } } function hg(e, t) { return t ? e.createChecked(null, t) : e.createAndFill() } function pg(e, t, n, r, i) { const o = function (e) { if (e.cached.tableNodeTypes) return e.cached.tableNodeTypes; const t = {}; return Object.keys(e.nodes).forEach((n => { const r = e.nodes[n]; r.spec.tableRole && (t[r.spec.tableRole] = r) })), e.cached.tableNodeTypes = t, t }(e), s = [], a = []; for (let e = 0; e < n; e += 1) { const e = hg(o.cell, i); if (e && a.push(e), r) { const e = hg(o.header_cell, i); e && s.push(e) } } const l = []; for (let e = 0; e < t; e += 1)l.push(o.row.createChecked(null, r && 0 === e ? s : a)); return o.table.createChecked(null, l) } const fg = ({ editor: e }) => { const { selection: t } = e.state; if (!(t instanceof wm)) return !1; let n = 0; const r = Hd(t.ranges[0].$from, (e => "table" === e.type.name)); null == r || r.node.descendants((e => { if ("table" === e.type.name) return !1;["tableCell", "tableHeader"].includes(e.type.name) && (n += 1) })); return n === t.ranges.length && (e.commands.deleteTable(), !0) }, mg = hh.create({ name: "table", addOptions: () => ({ HTMLAttributes: {}, resizable: !1, handleWidth: 5, cellMinWidth: 25, View: dg, lastColumnResizable: !0, allowTableNodeSelection: !1 }), content: "tableRow+", tableRole: "table", isolating: !0, group: "block", parseHTML: () => [{ tag: "table" }], renderHTML({ HTMLAttributes: e }) { return ["table", Qu(this.options.HTMLAttributes, e), ["tbody", 0]] }, addCommands: () => ({ insertTable: ({ rows: e = 3, cols: t = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: i, editor: o }) => { const s = pg(o.schema, e, t, n); if (i) { const e = r.selection.anchor + 1; r.replaceSelectionWith(s).scrollIntoView().setSelection(zs.near(r.doc.resolve(e))) } return !0 }, addColumnBefore: () => ({ state: e, dispatch: t }) => function (e, t) { if (!hm(e)) return !1; if (t) { let n = Hm(e); t(Vm(e.tr, n, n.left)) } return !0 }(e, t), addColumnAfter: () => ({ state: e, dispatch: t }) => function (e, t) { if (!hm(e)) return !1; if (t) { let n = Hm(e); t(Vm(e.tr, n, n.right)) } return !0 }(e, t), deleteColumn: () => ({ state: e, dispatch: t }) => function (e, t) { if (!hm(e)) return !1; if (t) { let n = Hm(e), r = e.tr; if (0 == n.left && n.right == n.map.width) return !1; for (let e = n.right - 1; Wm(r, n, e), e != n.left; e--)n.table = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc, n.map = am.get(n.table); t(r) } return !0 }(e, t), addRowBefore: () => ({ state: e, dispatch: t }) => function (e, t) { if (!hm(e)) return !1; if (t) { let n = Hm(e); t(qm(e.tr, n, n.top)) } return !0 }(e, t), addRowAfter: () => ({ state: e, dispatch: t }) => function (e, t) { if (!hm(e)) return !1; if (t) { let n = Hm(e); t(qm(e.tr, n, n.bottom)) } return !0 }(e, t), deleteRow: () => ({ state: e, dispatch: t }) => function (e, t) { if (!hm(e)) return !1; if (t) { let n = Hm(e), r = e.tr; if (0 == n.top && n.bottom == n.map.height) return !1; for (let e = n.bottom - 1; Km(r, n, e), e != n.top; e--)n.table = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc, n.map = am.get(n.table); t(r) } return !0 }(e, t), deleteTable: () => ({ state: e, dispatch: t }) => function (e, t) { let n = e.selection.$anchor; for (let r = n.depth; r > 0; r--)if ("table" == n.node(r).type.spec.tableRole) return t && t(e.tr.delete(n.before(r), n.after(r)).scrollIntoView()), !0; return !1 }(e, t), mergeCells: () => ({ state: e, dispatch: t }) => Um(e, t), splitCell: () => ({ state: e, dispatch: t }) => Gm(e, t), toggleHeaderColumn: () => ({ state: e, dispatch: t }) => Ym("column")(e, t), toggleHeaderRow: () => ({ state: e, dispatch: t }) => Ym("row")(e, t), toggleHeaderCell: () => ({ state: e, dispatch: t }) => Zm(e, t), mergeOrSplit: () => ({ state: e, dispatch: t }) => !!Um(e, t) || Gm(e, t), setCellAttribute: (e, t) => ({ state: n, dispatch: r }) => function (e, t) { return function (n, r) { if (!hm(n)) return !1; let i = pm(n); if (i.nodeAfter.attrs[e] === t) return !1; if (r) { let o = n.tr; n.selection instanceof wm ? n.selection.forEachCell(((n, r) => { n.attrs[e] !== t && o.setNodeMarkup(r, null, ym(n.attrs, e, t)) })) : o.setNodeMarkup(i.pos, null, ym(i.nodeAfter.attrs, e, t)), r(o) } return !0 } }(e, t)(n, r), goToNextCell: () => ({ state: e, dispatch: t }) => Qm(1)(e, t), goToPreviousCell: () => ({ state: e, dispatch: t }) => Qm(-1)(e, t), fixTables: () => ({ state: e, dispatch: t }) => (t && jm(e), !0), setCellSelection: e => ({ tr: t, dispatch: n }) => { if (n) { const n = wm.create(t.doc, e.anchorCell, e.headCell); t.setSelection(n) } return !0 } }), addKeyboardShortcuts() { return { Tab: () => !!this.editor.commands.goToNextCell() || !!this.editor.can().addRowAfter() && this.editor.chain().addRowAfter().goToNextCell().run(), "Shift-Tab": () => this.editor.commands.goToPreviousCell(), Backspace: fg, "Mod-Backspace": fg, Delete: fg, "Mod-Delete": fg } }, addProseMirrorPlugins() { return [...this.options.resizable && this.editor.isEditable ? [rg({ handleWidth: this.options.handleWidth, cellMinWidth: this.options.cellMinWidth, View: this.options.View, lastColumnResizable: this.options.lastColumnResizable })] : [], cg({ allowTableNodeSelection: this.options.allowTableNodeSelection })] }, extendNodeSchema: e => ({ tableRole: nd(Gu(e, "tableRole", { name: e.name, options: e.options, storage: e.storage })) }) }), gg = hh.create({ name: "tableRow", addOptions: () => ({ HTMLAttributes: {} }), content: "(tableCell | tableHeader)*", tableRole: "row", parseHTML: () => [{ tag: "tr" }], renderHTML({ HTMLAttributes: e }) { return ["tr", Qu(this.options.HTMLAttributes, e), 0] } }), yg = hh.create({ name: "tableCell", addOptions: () => ({ HTMLAttributes: {} }), content: "block+", addAttributes: () => ({ colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: e => { const t = e.getAttribute("colwidth"); return t ? [parseInt(t, 10)] : null } } }), tableRole: "cell", isolating: !0, parseHTML: () => [{ tag: "td" }], renderHTML({ HTMLAttributes: e }) { return ["td", Qu(this.options.HTMLAttributes, e), 0] } }), vg = hh.create({ name: "tableHeader", addOptions: () => ({ HTMLAttributes: {} }), content: "block+", addAttributes: () => ({ colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: e => { const t = e.getAttribute("colwidth"); return t ? [parseInt(t, 10)] : null } } }), tableRole: "header_cell", isolating: !0, parseHTML: () => [{ tag: "th" }], renderHTML({ HTMLAttributes: e }) { return ["th", Qu(this.options.HTMLAttributes, e), 0] } }); class bg { constructor({ editor: e, element: t, view: n, tippyOptions: r = {}, shouldShow: i }) { this.preventHide = !1, this.shouldShow = ({ view: e, state: t, from: n, to: r }) => { const { doc: i, selection: o } = t, { empty: s } = o, a = !i.textBetween(n, r).length && Md(t.selection); return !(!e.hasFocus() || s || a) }, this.mousedownHandler = () => { this.preventHide = !0 }, this.dragstartHandler = () => { this.hide() }, this.focusHandler = () => { setTimeout((() => this.update(this.editor.view))) }, this.blurHandler = ({ event: e }) => { var t; this.preventHide ? this.preventHide = !1 : (null == e ? void 0 : e.relatedTarget) && (null === (t = this.element.parentNode) || void 0 === t ? void 0 : t.contains(e.relatedTarget)) || this.hide() }, this.editor = e, this.element = t, this.view = n, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = r, this.element.remove(), this.element.style.visibility = "visible" } createTooltip() { const { element: e } = this.editor.options, t = !!e.parentElement; !this.tippy && t && (this.tippy = $i(e, { duration: 0, getReferenceClientRect: null, content: this.element, interactive: !0, trigger: "manual", placement: "top", hideOnClick: "toggle", ...this.tippyOptions }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", (e => { this.blurHandler({ event: e }) }))) } update(e, t) { var n, r, i; const { state: o, composing: s } = e, { doc: a, selection: l } = o, c = t && t.doc.eq(a) && t.selection.eq(l); if (s || c) return; this.createTooltip(); const { ranges: u } = l, d = Math.min(...u.map((e => e.$from.pos))), h = Math.max(...u.map((e => e.$to.pos))); (null === (n = this.shouldShow) || void 0 === n ? void 0 : n.call(this, { editor: this.editor, view: e, state: o, oldState: t, from: d, to: h })) ? (null === (r = this.tippy) || void 0 === r || r.setProps({ getReferenceClientRect: (null === (i = this.tippyOptions) || void 0 === i ? void 0 : i.getReferenceClientRect) || (() => { if (Sd(t = o.selection) && t instanceof Hs) { const t = e.nodeDOM(d); if (t) return t.getBoundingClientRect() } var t; return function (e, t, n) { const r = e.state.doc.content.size, i = Od(t, 0, r), o = Od(n, 0, r), s = e.coordsAtPos(i), a = e.coordsAtPos(o, -1), l = Math.min(s.top, a.top), c = Math.max(s.bottom, a.bottom), u = Math.min(s.left, a.left), d = Math.max(s.right, a.right), h = { top: l, bottom: c, left: u, right: d, width: d - u, height: c - l, x: u, y: l }; return { ...h, toJSON: () => h } }(e, d, h) }) }), this.show()) : this.hide() } show() { var e; null === (e = this.tippy) || void 0 === e || e.show() } hide() { var e; null === (e = this.tippy) || void 0 === e || e.hide() } destroy() { var e; null === (e = this.tippy) || void 0 === e || e.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler) } } const wg = e => new ta({ key: "string" == typeof e.pluginKey ? new ia(e.pluginKey) : e.pluginKey, view: t => new bg({ view: t, ...e }) }), Dg = vd.create({ name: "bubbleMenu", addOptions: () => ({ element: null, tippyOptions: {}, pluginKey: "bubbleMenu", shouldShow: null }), addProseMirrorPlugins() { return this.options.element ? [wg({ pluginKey: this.options.pluginKey, editor: this.editor, element: this.options.element, tippyOptions: this.options.tippyOptions, shouldShow: this.options.shouldShow })] : [] } }), xg = vd.create({ name: "textAlign", addOptions: () => ({ types: [], alignments: ["left", "center", "right", "justify"], defaultAlignment: "left" }), addGlobalAttributes() { return [{ types: this.options.types, attributes: { textAlign: { default: this.options.defaultAlignment, parseHTML: e => e.style.textAlign || this.options.defaultAlignment, renderHTML: e => e.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${e.textAlign}` } } } }] }, addCommands() { return { setTextAlign: e => ({ commands: t }) => !!this.options.alignments.includes(e) && this.options.types.every((n => t.updateAttributes(n, { textAlign: e }))), unsetTextAlign: () => ({ commands: e }) => this.options.types.every((t => e.resetAttributes(t, "textAlign"))) } }, addKeyboardShortcuts() { return { "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"), "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"), "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"), "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify") } } }), Cg = hh.create({ name: "iframe", group: "block", atom: !0, addOptions: function () { return { allowFullscreen: !0, HTMLAttributes: { class: "iframe-wrapper" } } }, addAttributes: function () { var e = this; return { src: { default: null }, frameborder: { default: 0 }, width: { default: 300 }, height: { default: 300 }, allowfullscreen: { default: this.options.allowFullscreen, parseHTML: function () { return e.options.allowFullscreen } } } }, parseHTML: function () { return [{ tag: "iframe" }] }, renderHTML: function (e) { var t = e.HTMLAttributes; return ["div", this.options.HTMLAttributes, ["iframe", t]] }, addCommands: function () { var e = this; return { setIframe: function (t) { return function (n) { var r = n.tr, i = n.dispatch, o = r.selection, s = e.type.create(t); return i && r.replaceRangeWith(o.from, o.to, s), !0 } } } } }), kg = hh.create({ name: "embed-file", group: "block", atom: !0, addOptions: function () { return { allowFullscreen: !0, HTMLAttributes: { class: "embed-file-wrapper" } } }, addAttributes: function () { var e = this; return { src: { default: null }, frameborder: { default: 0 }, width: { default: 300 }, height: { default: 300 }, allowfullscreen: { default: this.options.allowFullscreen, parseHTML: function () { return e.options.allowFullscreen } } } }, parseHTML: function () { return [{ tag: "iframe" }] }, renderHTML: function (e) { var t = e.HTMLAttributes; return ["div", this.options.HTMLAttributes, ["iframe", t]] }, addCommands: function () { var e = this; return { setEmbedFile: function (t) { return function (n) { var r = n.tr, i = n.dispatch, o = r.selection, s = e.type.create(t); return i && r.replaceRangeWith(o.from, o.to, s), !0 } } } } }); document.addEventListener("alpine:init", (function () { En.data("editor", (function (e) { return { editor: null, content: e, updatedAt: Date.now(), iframe: { src: "", width: 500, height: 500 }, active: { undo: !1, redo: !1, heading1: !1, heading2: !1, heading3: !1, heading4: !1, bold: !1, italic: !1, underline: !1, highlight: !1, paragraph: !1, orderedList: !1, bulletList: !1, image: !1, link: !1, strike: !1, blockquote: !1, table: !1, alignLeft: !1, alignRight: !1, alignCenter: !1, alignJustify: !1, iframe: !1, embedFile: !1, code: !1 }, lfm: function (e, t, n) { if ("file" === t) var r = window.prompt("width:", "500"), i = window.prompt("height:", "500"); var o = n && n.prefix ? n.prefix : "/laravel-filemanager"; window.open(o + "?type=" + t || "file", "FileManager", "width=700,height=600"); var s = this; window.SetUrl = function (e) { var n = e.map((function (e) { return e.url })).join(","); "image" === t ? s.setImage(n) : s.setEmbedFileUpload(n, r, i) } }, uploadImage: function (e) { this.lfm("lfm", "image", { prefix: e }) }, uploadFile: function (e) { this.lfm("lfm", "file", { prefix: e }) }, setImage: function (e) { e ? En.raw(this.editor).chain().focus().setImage({ src: e }).run() : console.log("image url not found") }, setEmbedFileUpload: function (e, t, n) { e ? En.raw(this.editor).chain().focus().setEmbedFile({ src: e, width: t, height: n }).run() : console.log("image url not found") }, toggleClass: function (e) { this.activeMenu.includes(e) ? this.activeMenu = this.activeMenu.filter((function (t) { return t !== e })) : this.activeMenu.push(e) }, toggleHeading: function (e) { En.raw(this.editor).chain().toggleHeading({ level: e }).focus().run() }, toggleBold: function () { En.raw(this.editor).chain().toggleBold().focus().run() }, toggleItalic: function () { En.raw(this.editor).chain().toggleItalic().focus().run() }, toggleUnderline: function () { En.raw(this.editor).chain().toggleUnderline().focus().run() }, toggleParagraph: function () { En.raw(this.editor).chain().setParagraph().focus().run() }, toggleList: function (e) { "bullet" === e ? En.raw(this.editor).chain().toggleBulletList().focus().run() : En.raw(this.editor).chain().toggleOrderedList().focus().run() }, addTable: function (e, t) { En.raw(this.editor).chain().focus().insertTable({ rows: e, cols: t, withHeaderRow: !0 }).run() }, addColumnBefore: function () { En.raw(this.editor).chain().addColumnBefore().focus().run() }, addColumnAfter: function () { En.raw(this.editor).chain().addColumnAfter().focus().run() }, deleteColumn: function () { En.raw(this.editor).chain().deleteColumn().focus().run() }, addRowBefore: function () { En.raw(this.editor).chain().addRowBefore().focus().run() }, addRowAfter: function () { En.raw(this.editor).chain().addRowAfter().focus().run() }, deleteRow: function () { En.raw(this.editor).chain().deleteRow().focus().run() }, deleteTable: function () { En.raw(this.editor).chain().deleteTable().focus().run() }, mergeCells: function () { En.raw(this.editor).chain().mergeCells().focus().run() }, splitCells: function () { En.raw(this.editor).chain().splitCell().focus().run() }, toggleHeaderColumn: function () { En.raw(this.editor).chain().toggleHeaderColumn().focus().run() }, toggleHeaderRow: function () { En.raw(this.editor).chain().toggleHeaderRow().focus().run() }, toggleHeaderCell: function () { En.raw(this.editor).chain().toggleHeaderCell().focus().run() }, mergeOrSplit: function () { En.raw(this.editor).chain().mergeOrSplit().focus().run() }, fixTable: function () { En.raw(this.editor).chain().fixTables().focus().run() }, goToNextCell: function () { En.raw(this.editor).chain().goToNextCell().focus().run() }, goToPreviousCell: function () { En.raw(this.editor).chain().goToPreviousCell().focus().run() }, addLink: function () { En.raw(this.editor).chain().setLink().focus().run() }, toggleStrikeThrough: function () { En.raw(this.editor).chain().toggleStrike().focus().run() }, toggleHighlight: function (e) { En.raw(this.editor).chain().toggleHighlight().focus().run() }, toggleBlockquote: function () { En.raw(this.editor).chain().toggleBlockquote().focus().run() }, undo: function () { En.raw(this.editor).chain().undo().focus().run() }, redo: function () { En.raw(this.editor).chain().redo().focus().run() }, toggleTextAlign: function (e) { En.raw(this.editor).chain().focus().setTextAlign(e).run() }, toggleCode: function () { En.raw(this.editor).chain().toggleCode().focus().run() }, setIframe: function () { var e = window.prompt("URL"), t = window.prompt("width"), n = window.prompt("height"); En.raw(this.editor).chain().focus().setIframe({ src: e, width: t, height: n }).run() }, setTippy: function () { Object.entries(this.active).forEach((function (e) { var t = null, n = document.querySelector("#".concat(e[0], "-btn")); n && (t = n.getAttribute("data-title")), null === t && (t = e[0]), $i("#".concat(e[0], "-btn"), { content: t }) })) }, init: function () { var e = this; this.editor = new ih({ element: e.$refs.editorReference, extensions: [Yf, kp.configure({ history: !0, dropcursor: !0 }), rm.configure({ HTMLAttributes: { class: "img-responsive" } }), tm, em, mg.configure({ resizable: !0, HTMLAttributes: { class: "table table-bordered table-sm" } }), gg, vg, yg, Dg.configure({ element: document.querySelector(".menu") }), xg.configure({ types: ["heading", "paragraph"] }), Cg, kg], content: e.content, onTransaction: function (t) { var n = t.editor; e.setTippy(), e.content = n.getHTML(), e.active.bold = n.isActive("bold"), e.active.italic = n.isActive("italic"), e.active.underline = n.isActive("underline"), e.active.highlight = n.isActive("highlight"), e.active.marker = n.isActive("marker"), e.active.orderedList = n.isActive("orderedList"), e.active.bulletList = n.isActive("bulletList"), e.active.image = n.isActive("image"), e.active.link = n.isActive("link"), e.active.strike = n.isActive("strike"), e.active.blockquote = n.isActive("blockquote"), e.active.table = n.isActive("table"), e.active.heading1 = n.isActive("heading", { level: 1 }), e.active.heading2 = n.isActive("heading", { level: 2 }), e.active.heading3 = n.isActive("heading", { level: 3 }), e.active.heading4 = n.isActive("heading", { level: 4 }), e.active.alignLeft = n.isActive({ textAlign: "left" }), e.active.alignCenter = n.isActive({ textAlign: "center" }), e.active.alignRight = n.isActive({ textAlign: "right" }), e.active.alignJustify = n.isActive({ textAlign: "justify" }), e.active.iframe = n.isActive("iframe"), e.active.code = n.isActive("code") }, onUpdate: function (t) { var n = t.editor; e.updatedAt = Date.now(), e.content = n.getHTML() }, onSelectionUpdate: function (t) { t.editor; e.updatedAt = Date.now() }, onFocus: function (e) { e.editor, e.event } }) } } })) })), document.querySelectorAll('[data-tippy-toggle="tippy"]').forEach((function (e) { var t = e.getAttribute("data-tippy-title"); $i(e, { content: t }) })), En.plugin(Tn), window.Alpine = En, En.start() })() })();